// 
//                    GNU LESSER GENERAL PUBLIC LICENSE
//                        Version 3, 29 June 2007
// 
//  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
//  Everyone is permitted to copy and distribute verbatim copies of this
//  license document, but changing it is not allowed.
// 
// 
//   This version of the GNU Lesser General Public License incorporates
// the terms and conditions of version 3 of the GNU General Public
// License, supplemented by the additional permissions listed below.
// 
//   0. Additional Definitions.
// 
//   As used herein, "this License" refers to version 3 of the GNU Lesser
// General Public License, and the "GNU GPL" refers to version 3 of the
// GNU General Public License.
// 
//   "The Library" refers to a covered work governed by this License,
// other than an Application or a Combined Work as defined below.
// 
//   An "Application" is any work that makes use of an interface provided
// by the Library, but which is not otherwise based on the Library.
// Defining a subclass of a class defined by the Library is deemed a mode
// of using an interface provided by the Library.
// 
//   A "Combined Work" is a work produced by combining or linking an
// Application with the Library.  The particular version of the Library
// with which the Combined Work was made is also called the "Linked
// Version".
// 
//   The "Minimal Corresponding Source" for a Combined Work means the
// Corresponding Source for the Combined Work, excluding any source code
// for portions of the Combined Work that, considered in isolation, are
// based on the Application, and not on the Linked Version.
// 
//   The "Corresponding Application Code" for a Combined Work means the
// object code and/or source code for the Application, including any data
// and utility programs needed for reproducing the Combined Work from the
// Application, but excluding the System Libraries of the Combined Work.
// 
//   1. Exception to Section 3 of the GNU GPL.
// 
//   You may convey a covered work under sections 3 and 4 of this License
// without being bound by section 3 of the GNU GPL.
// 
//   2. Conveying Modified Versions.
// 
//   If you modify a copy of the Library, and, in your modifications, a
// facility refers to a function or data to be supplied by an Application
// that uses the facility (other than as an argument passed when the
// facility is invoked), then you may convey a copy of the modified
// version:
// 
//    a) under this License, provided that you make a good faith effort
//    to ensure that, in the event an Application does not supply the
//    function or data, the facility still operates, and performs
//    whatever part of its purpose remains meaningful, or
// 
//    b) under the GNU GPL, with none of the additional permissions of
//    this License applicable to that copy.
// 
//   3. Object Code Incorporating Material from Library Header Files.
// 
//   The object code form of an Application may incorporate material from
// a header file that is part of the Library.  You may convey such object
// code under terms of your choice, provided that, if the incorporated
// material is not limited to numerical parameters, data structure
// layouts and accessors, or small macros, inline functions and templates
// (ten or fewer lines in length), you do both of the following:
// 
//    a) Give prominent notice with each copy of the object code that the
//    Library is used in it and that the Library and its use are covered
//    by this License.
// 
//    b) Accompany the object code with a copy of the GNU GPL and this
//    license document.
// 
//   4. Combined Works.
// 
//   You may convey a Combined Work under terms of your choice that,
// taken together, effectively do not restrict modification of the
// portions of the Library contained in the Combined Work and reverse
// engineering for debugging such modifications, if you also do each of
// the following:
// 
//    a) Give prominent notice with each copy of the Combined Work that
//    the Library is used in it and that the Library and its use are
//    covered by this License.
// 
//    b) Accompany the Combined Work with a copy of the GNU GPL and this
//    license document.
// 
//    c) For a Combined Work that displays copyright notices during
//    execution, include the copyright notice for the Library among these
//    notices, as well as a reference directing the user to the copies of
//    the GNU GPL and this license document.
// 
//    d) Do one of the following:
// 
//        0) Convey the Minimal Corresponding Source under the terms of
//        this License, and the Corresponding Application Code in a form
//        suitable for, and under terms that permit, the user to
//        recombine or relink the Application with a modified version of
//        the Linked Version to produce a modified Combined Work, in the
//        manner specified by section 6 of the GNU GPL for conveying
//        Corresponding Source.
// 
//        1) Use a suitable shared library mechanism for linking with the
//        Library.  A suitable mechanism is one that (a) uses at run time
//        a copy of the Library already present on the user's computer
//        system, and (b) will operate properly with a modified version
//        of the Library that is interface-compatible with the Linked
//        Version.
// 
//    e) Provide Installation Information, but only if you would
//    otherwise be required to provide such information under section 6
//    of the GNU GPL, and only to the extent that such information is
//    necessary to install and execute a modified version of the Combined
//    Work produced by recombining or relinking the Application with a
//    modified version of the Linked Version. (If you use option 4d0, the
//    Installation Information must accompany the Minimal Corresponding
//    Source and Corresponding Application Code. If you use option 4d1,
//    you must provide the Installation Information in the manner
//    specified by section 6 of the GNU GPL for conveying Corresponding
//    Source.)
// 
//   5. Combined Libraries.
// 
//   You may place library facilities that are a work based on the
// Library side by side in a single library together with other library
// facilities that are not Applications and are not covered by this
// License, and convey such a combined library under terms of your
// choice, if you do both of the following:
// 
//    a) Accompany the combined library with a copy of the same work
//    based on the Library, uncombined with any other library facilities,
//    conveyed under the terms of this License.
// 
//    b) Give prominent notice with the combined library that part of it
//    is a work based on the Library, and explaining where to find the
//    accompanying uncombined form of the same work.
// 
//   6. Revised Versions of the GNU Lesser General Public License.
// 
//   The Free Software Foundation may publish revised and/or new versions
// of the GNU Lesser General Public License from time to time. Such new
// versions will be similar in spirit to the present version, but may
// differ in detail to address new problems or concerns.
// 
//   Each version is given a distinguishing version number. If the
// Library as you received it specifies that a certain numbered version
// of the GNU Lesser General Public License "or any later version"
// applies to it, you have the option of following the terms and
// conditions either of that published version or of any later version
// published by the Free Software Foundation. If the Library as you
// received it does not specify a version number of the GNU Lesser
// General Public License, you may choose any version of the GNU Lesser
// General Public License ever published by the Free Software Foundation.
// 
//   If the Library as you received it specifies that a proxy can decide
// whether future versions of the GNU Lesser General Public License shall
// apply, that proxy's public statement of acceptance of any version is
// permanent authorization for you to choose that version for the
// Library.
// 
// ----------------------------------------------------------------------
// 
// The AZUL library (package "azul-dll") is provided under
// the terms of the GNU Library General Public License (LGPL)
// with the following modifications:
// 
// 1. Modifications to feature flags to enable / disable existing
//    features in AZUL do not constitute a modified or derivative work.
// 
// 2. Static linking of applications and widgets to the AZUL library
//    does not constitute a derivative work and does not require the
//    author to provide source code for the application or widget,
//    use the shared AZUL libraries, or link their applications or
//    widgets against a user-supplied version of AZUL.
// 
// 3. This license is not implicitly compatible with future versions
//    of the LGPL (invalidating section 6).
// 
// 4. You do not have to provide a copy of the LGPL license with programs
//   that are linked to the AZUL library, nor do you have to identify
//   the AZUL license in your program or documentation as required by
//   section 6 of the LGPL.
// 
//   However, programs must still identify their use of AZUL. The
//   following example statement can be included in user documentation
//   to satisfy this requirement:
// 
// ----------------------------------------------------------------------
// 
// [program] is based in part on the work of the AZUL GUI toolkit
// (https://azul.rs). The AZUL GUI toolkit uses the following libraries
// under the following licenses:
// 
// $$CONTRIBUTORS_AND_LICENSES_SEE_PYTHON_SCRIPT$$
// 
// To generate the full text of the license for the license, please visit
// https://spdx.org/licenses/ and replace the license author in the source
// text in any given license with the name of the author.
#![no_std]
#![allow(non_upper_case_globals)]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico",
)]

//! Auto-generated public Rust API for the Azul GUI toolkit version " + version + "

extern crate alloc;
#[cfg(feature = "serde-support")]
extern crate serde;
#[cfg(feature = "serde-support")]
#[macro_use(Serialize, Deserialize)]
extern crate serde_derive;

/// Module to re-export common structs (`App`, `AppConfig`, `Css`, `Dom`, `WindowCreateOptions`, `RefAny`, `LayoutInfo`)
pub mod prelude {
    pub use crate::app::*;
    pub use crate::window::*;
    pub use crate::callbacks::*;
    pub use crate::menu::*;
    pub use crate::dom::*;
    pub use crate::css::*;
    pub use crate::style::*;
    pub use crate::gl::*;
    pub use crate::image::*;
    pub use crate::font::*;
    pub use crate::svg::*;
    pub use crate::xml::*;
    pub use crate::fs::*;
    pub use crate::dialog::*;
    pub use crate::clipboard::*;
    pub use crate::time::*;
    pub use crate::task::*;
    pub use crate::str::*;
    pub use crate::vec::*;
    pub use crate::option::*;
    pub use crate::error::*;
}

mod dll {
    #[cfg(not(feature = "link_static"))]
    impl AzString {
        #[inline]
        pub fn as_str(&self) -> &str {
            unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }
        }
        #[inline]
        pub fn as_bytes(&self) -> &[u8] {
            unsafe { core::slice::from_raw_parts(self.vec.ptr, self.vec.len) }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzCallback                          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzLayoutCallbackInner               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzMarshaledLayoutCallbackInner      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzRenderImageCallback               { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzIFrameCallback                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzTimerCallback                     { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzWriteBackCallback                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzThreadDestructorFn                { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzLibraryReceiveThreadMsgFn         { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzLibrarySendThreadMsgFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzCheckThreadFinishedFn             { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzGetSystemTimeFn                   { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzCreateThreadFn                    { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzThreadRecvFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzThreadReceiverDestructorFn        { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzThreadSenderDestructorFn          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzInstantPtrDestructorFn            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzInstantPtrCloneFn                 { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzThreadSendFn                      { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}

    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzFileInputOnPathChangeCallback             { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzCheckBoxOnToggleCallback                  { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzColorInputOnValueChangeCallback           { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzTextInputOnTextInputCallback              { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzTextInputOnVirtualKeyDownCallback         { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzTextInputOnFocusLostCallback              { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNumberInputOnFocusLostCallback            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNumberInputOnValueChangeCallback          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeAddedCallback              { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeRemovedCallback            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeDraggedCallback            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeGraphDraggedCallback       { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeConnectedCallback          { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeInputDisconnectedCallback  { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeOutputDisconnectedCallback { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzNodeGraphOnNodeFieldEditedCallback        { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}
    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for AzDropDownOnChoiceChangeCallback            { fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result { write!(f, "{:x}", self.cb as usize) }}

    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzLayoutCallbackInner { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzMarshaledLayoutCallbackInner { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzRenderImageCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzIFrameCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzTimerCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzWriteBackCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzThreadDestructorFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzLibraryReceiveThreadMsgFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzLibrarySendThreadMsgFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzCheckThreadFinishedFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzGetSystemTimeFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzCreateThreadFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzThreadRecvFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzThreadReceiverDestructorFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzThreadSenderDestructorFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzInstantPtrDestructorFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzInstantPtrCloneFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzThreadSendFn { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }

    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzFileInputOnPathChangeCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzCheckBoxOnToggleCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzColorInputOnValueChangeCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzTextInputOnTextInputCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzTextInputOnVirtualKeyDownCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzTextInputOnFocusLostCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNumberInputOnFocusLostCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNumberInputOnValueChangeCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeAddedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeRemovedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeDraggedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeGraphDraggedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeConnectedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeInputDisconnectedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeOutputDisconnectedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzNodeGraphOnNodeFieldEditedCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialEq for AzDropDownOnChoiceChangeCallback { fn eq(&self, rhs: &Self) -> bool { (self.cb as usize).eq(&(rhs.cb as usize)) } }

    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzLayoutCallbackInner { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzMarshaledLayoutCallbackInner { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzRenderImageCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzIFrameCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzTimerCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzWriteBackCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzThreadDestructorFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzLibraryReceiveThreadMsgFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzLibrarySendThreadMsgFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzCheckThreadFinishedFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzGetSystemTimeFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzCreateThreadFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzThreadRecvFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzThreadReceiverDestructorFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzThreadSenderDestructorFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzInstantPtrDestructorFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzInstantPtrCloneFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzThreadSendFn { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }

    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzFileInputOnPathChangeCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzCheckBoxOnToggleCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzColorInputOnValueChangeCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzTextInputOnTextInputCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzTextInputOnVirtualKeyDownCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzTextInputOnFocusLostCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNumberInputOnFocusLostCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNumberInputOnValueChangeCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) }}
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeAddedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeRemovedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeDraggedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeGraphDraggedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeConnectedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeInputDisconnectedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeOutputDisconnectedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzNodeGraphOnNodeFieldEditedCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }
    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for AzDropDownOnChoiceChangeCallback { fn partial_cmp(&self, rhs: &Self) -> Option<::core::cmp::Ordering> { (self.cb as usize).partial_cmp(&(rhs.cb as usize)) } }    #[cfg(not(feature = "link_static"))]
    mod dynamic_link {
    use core::ffi::c_void;

    /// Main application class
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzApp {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// Configuration to set which messages should be logged.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAppLogLevel {
        Off,
        Error,
        Warn,
        Info,
        Debug,
        Trace,
    }

    /// Version of the layout solver to use - future binary versions of azul may have more fields here, necessary so that old compiled applications don't break with newer releases of azul. Newer layout versions are opt-in only.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzLayoutSolver {
        Default,
    }

    /// Whether the renderer has VSync enabled
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzVsync {
        Enabled,
        Disabled,
        DontCare,
    }

    /// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzSrgb {
        Enabled,
        Disabled,
        DontCare,
    }

    /// Does the renderer render using hardware acceleration? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzHwAcceleration {
        Enabled,
        Disabled,
        DontCare,
    }

    /// Offset in physical pixels (integer units)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLayoutPoint {
        pub x: isize,
        pub y: isize,
    }

    /// Size in physical pixels (integer units)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLayoutSize {
        pub width: isize,
        pub height: isize,
    }

    /// Re-export of rust-allocated (stack based) `IOSHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzIOSHandle {
        pub ui_window: *mut c_void,
        pub ui_view: *mut c_void,
        pub ui_view_controller: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `MacOSHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzMacOSHandle {
        pub ns_window: *mut c_void,
        pub ns_view: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `XlibHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzXlibHandle {
        pub window: u64,
        pub display: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `XcbHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzXcbHandle {
        pub window: u32,
        pub connection: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `WaylandHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzWaylandHandle {
        pub surface: *mut c_void,
        pub display: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `WindowsHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzWindowsHandle {
        pub hwnd: *mut c_void,
        pub hinstance: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `WebHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzWebHandle {
        pub id: u32,
    }

    /// Re-export of rust-allocated (stack based) `AndroidHandle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzAndroidHandle {
        pub a_native_window: *mut c_void,
    }

    /// X11 window hint: Type of window
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzXWindowType {
        Desktop,
        Dock,
        Toolbar,
        Menu,
        Utility,
        Splash,
        Dialog,
        DropdownMenu,
        PopupMenu,
        Tooltip,
        Notification,
        Combo,
        Dnd,
        Normal,
    }

    /// Same as `LayoutPoint`, but uses `i32` instead of `isize`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzPhysicalPositionI32 {
        pub x: i32,
        pub y: i32,
    }

    /// Same as `LayoutPoint`, but uses `u32` instead of `isize`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzPhysicalSizeU32 {
        pub width: u32,
        pub height: u32,
    }

    /// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[derive(Default)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLogicalPosition {
        pub x: f32,
        pub y: f32,
    }

    /// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLogicalSize {
        pub width: f32,
        pub height: f32,
    }

    /// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see wether the window icon has changed.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzIconKey {
        pub id: usize,
    }

    /// Symbolic name for a keyboard key, does **not** take the keyboard locale into account
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzVirtualKeyCode {
        Key1,
        Key2,
        Key3,
        Key4,
        Key5,
        Key6,
        Key7,
        Key8,
        Key9,
        Key0,
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
        I,
        J,
        K,
        L,
        M,
        N,
        O,
        P,
        Q,
        R,
        S,
        T,
        U,
        V,
        W,
        X,
        Y,
        Z,
        Escape,
        F1,
        F2,
        F3,
        F4,
        F5,
        F6,
        F7,
        F8,
        F9,
        F10,
        F11,
        F12,
        F13,
        F14,
        F15,
        F16,
        F17,
        F18,
        F19,
        F20,
        F21,
        F22,
        F23,
        F24,
        Snapshot,
        Scroll,
        Pause,
        Insert,
        Home,
        Delete,
        End,
        PageDown,
        PageUp,
        Left,
        Up,
        Right,
        Down,
        Back,
        Return,
        Space,
        Compose,
        Caret,
        Numlock,
        Numpad0,
        Numpad1,
        Numpad2,
        Numpad3,
        Numpad4,
        Numpad5,
        Numpad6,
        Numpad7,
        Numpad8,
        Numpad9,
        NumpadAdd,
        NumpadDivide,
        NumpadDecimal,
        NumpadComma,
        NumpadEnter,
        NumpadEquals,
        NumpadMultiply,
        NumpadSubtract,
        AbntC1,
        AbntC2,
        Apostrophe,
        Apps,
        Asterisk,
        At,
        Ax,
        Backslash,
        Calculator,
        Capital,
        Colon,
        Comma,
        Convert,
        Equals,
        Grave,
        Kana,
        Kanji,
        LAlt,
        LBracket,
        LControl,
        LShift,
        LWin,
        Mail,
        MediaSelect,
        MediaStop,
        Minus,
        Mute,
        MyComputer,
        NavigateForward,
        NavigateBackward,
        NextTrack,
        NoConvert,
        OEM102,
        Period,
        PlayPause,
        Plus,
        Power,
        PrevTrack,
        RAlt,
        RBracket,
        RControl,
        RShift,
        RWin,
        Semicolon,
        Slash,
        Sleep,
        Stop,
        Sysrq,
        Tab,
        Underline,
        Unlabeled,
        VolumeDown,
        VolumeUp,
        Wake,
        WebBack,
        WebFavorites,
        WebForward,
        WebHome,
        WebRefresh,
        WebSearch,
        WebStop,
        Yen,
        Copy,
        Paste,
        Cut,
    }

    /// State of the window frame (minimized, maximized, fullscreen or normal window)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzWindowFrame {
        Normal,
        Minimized,
        Maximized,
        Fullscreen,
    }

    /// Debugging information, will be rendered as an overlay on top of the UI
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzDebugState {
        pub profiler_dbg: bool,
        pub render_target_dbg: bool,
        pub texture_cache_dbg: bool,
        pub gpu_time_queries: bool,
        pub gpu_sample_queries: bool,
        pub disable_batching: bool,
        pub epochs: bool,
        pub echo_driver_messages: bool,
        pub show_overdraw: bool,
        pub gpu_cache_dbg: bool,
        pub texture_cache_dbg_clear_evicted: bool,
        pub picture_caching_dbg: bool,
        pub primitive_dbg: bool,
        pub zoom_dbg: bool,
        pub small_screen: bool,
        pub disable_opaque_pass: bool,
        pub disable_alpha_pass: bool,
        pub disable_clip_masks: bool,
        pub disable_text_prims: bool,
        pub disable_gradient_prims: bool,
        pub obscure_images: bool,
        pub glyph_flashing: bool,
        pub smart_profiler: bool,
        pub invalidation_dbg: bool,
        pub tile_cache_logging_dbg: bool,
        pub profiler_capture: bool,
        pub force_picture_invalidation: bool,
    }

    /// Current icon of the mouse cursor
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzMouseCursorType {
        Default,
        Crosshair,
        Hand,
        Arrow,
        Move,
        Text,
        Wait,
        Help,
        Progress,
        NotAllowed,
        ContextMenu,
        Cell,
        VerticalText,
        Alias,
        Copy,
        NoDrop,
        Grab,
        Grabbing,
        AllScroll,
        ZoomIn,
        ZoomOut,
        EResize,
        NResize,
        NeResize,
        NwResize,
        SResize,
        SeResize,
        SwResize,
        WResize,
        EwResize,
        NsResize,
        NeswResize,
        NwseResize,
        ColResize,
        RowResize,
    }

    /// Renderer type of the current windows OpenGL context
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzRendererType {
        Hardware,
        Software,
    }

    /// Re-export of rust-allocated (stack based) `MacWindowOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzMacWindowOptions {
        pub _reserved: u8,
    }

    /// Re-export of rust-allocated (stack based) `WasmWindowOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzWasmWindowOptions {
        pub _reserved: u8,
    }

    /// Re-export of rust-allocated (stack based) `FullScreenMode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzFullScreenMode {
        SlowFullScreen,
        FastFullScreen,
        SlowWindowed,
        FastWindowed,
    }

    /// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzWindowTheme {
        DarkMode,
        LightMode,
    }

    /// Current state of touch devices / touch inputs
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzTouchState {
        pub unused: u8,
    }

    /// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzMarshaledLayoutCallbackInner {
        pub cb: AzMarshaledLayoutCallbackType,
    }

    /// `AzMarshaledLayoutCallbackType` struct
    pub type AzMarshaledLayoutCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRefAny, AzLayoutCallbackInfo) -> AzStyledDom;

    /// C-ABI stable wrapper over a `LayoutCallbackType`
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzLayoutCallbackInner {
        pub cb: AzLayoutCallbackType,
    }

    /// `AzLayoutCallbackType` struct
    pub type AzLayoutCallbackType = extern "C" fn(&mut AzRefAny, &mut AzLayoutCallbackInfo) -> AzStyledDom;

    /// C-ABI stable wrapper over a `CallbackType`
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzCallback {
        pub cb: AzCallbackType,
    }

    /// `AzCallbackType` struct
    pub type AzCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

    /// Which type of image should be updated: background image (the CSS background) or content image (the <img src=""> content)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzUpdateImageType {
        Background,
        Content,
    }

    /// Specifies if the screen should be updated after the callback function has returned
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzUpdate {
        DoNothing,
        RefreshDom,
        RefreshDomAllWindows,
    }

    /// Index of a Node in the internal `NodeDataContainer`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzNodeId {
        pub inner: usize,
    }

    /// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzDomId {
        pub inner: usize,
    }

    /// Re-export of rust-allocated (stack based) `PositionInfoInner` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzPositionInfoInner {
        pub x_offset: f32,
        pub y_offset: f32,
        pub static_x_offset: f32,
        pub static_y_offset: f32,
    }

    /// How should an animation repeat (loop, ping-pong, etc.)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAnimationRepeat {
        NoRepeat,
        Loop,
        PingPong,
    }

    /// How many times should an animation repeat
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAnimationRepeatCount {
        Times(usize),
        Infinite,
    }

    /// C-ABI wrapper over an `IFrameCallbackType`
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzIFrameCallback {
        pub cb: AzIFrameCallbackType,
    }

    /// `AzIFrameCallbackType` struct
    pub type AzIFrameCallbackType = extern "C" fn(&mut AzRefAny, &mut AzIFrameCallbackInfo) -> AzIFrameCallbackReturn;

    /// Re-export of rust-allocated (stack based) `RenderImageCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzRenderImageCallback {
        pub cb: AzRenderImageCallbackType,
    }

    /// `AzRenderImageCallbackType` struct
    pub type AzRenderImageCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRenderImageCallbackInfo) -> AzImageRef;

    /// Re-export of rust-allocated (stack based) `TimerCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzTimerCallback {
        pub cb: AzTimerCallbackType,
    }

    /// `AzTimerCallbackType` struct
    pub type AzTimerCallbackType = extern "C" fn(&mut AzRefAny, &mut AzTimerCallbackInfo) -> AzTimerCallbackReturn;

    /// `AzWriteBackCallbackType` struct
    pub type AzWriteBackCallbackType = extern "C" fn(&mut AzRefAny, &mut AzRefAny, &mut AzCallbackInfo) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `WriteBackCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzWriteBackCallback {
        pub cb: AzWriteBackCallbackType,
    }

    /// Re-export of rust-allocated (stack based) `ThreadCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadCallback {
        pub cb: AzThreadCallbackType,
    }

    /// `AzThreadCallbackType` struct
    pub type AzThreadCallbackType = extern "C" fn(AzRefAny, AzThreadSender, AzThreadReceiver);

    /// `AzRefAnyDestructorType` struct
    pub type AzRefAnyDestructorType = extern "C" fn(&mut c_void);

    /// Re-export of rust-allocated (stack based) `RefCount` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRefCount {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOn {
        MouseOver,
        MouseDown,
        LeftMouseDown,
        MiddleMouseDown,
        RightMouseDown,
        MouseUp,
        LeftMouseUp,
        MiddleMouseUp,
        RightMouseUp,
        MouseEnter,
        MouseLeave,
        Scroll,
        TextInput,
        VirtualKeyDown,
        VirtualKeyUp,
        HoveredFile,
        DroppedFile,
        HoveredFileCancelled,
        FocusReceived,
        FocusLost,
    }

    /// Re-export of rust-allocated (stack based) `HoverEventFilter` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzHoverEventFilter {
        MouseOver,
        MouseDown,
        LeftMouseDown,
        RightMouseDown,
        MiddleMouseDown,
        MouseUp,
        LeftMouseUp,
        RightMouseUp,
        MiddleMouseUp,
        MouseEnter,
        MouseLeave,
        Scroll,
        ScrollStart,
        ScrollEnd,
        TextInput,
        VirtualKeyDown,
        VirtualKeyUp,
        HoveredFile,
        DroppedFile,
        HoveredFileCancelled,
        TouchStart,
        TouchMove,
        TouchEnd,
        TouchCancel,
    }

    /// Re-export of rust-allocated (stack based) `FocusEventFilter` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzFocusEventFilter {
        MouseOver,
        MouseDown,
        LeftMouseDown,
        RightMouseDown,
        MiddleMouseDown,
        MouseUp,
        LeftMouseUp,
        RightMouseUp,
        MiddleMouseUp,
        MouseEnter,
        MouseLeave,
        Scroll,
        ScrollStart,
        ScrollEnd,
        TextInput,
        VirtualKeyDown,
        VirtualKeyUp,
        FocusReceived,
        FocusLost,
    }

    /// Re-export of rust-allocated (stack based) `WindowEventFilter` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzWindowEventFilter {
        MouseOver,
        MouseDown,
        LeftMouseDown,
        RightMouseDown,
        MiddleMouseDown,
        MouseUp,
        LeftMouseUp,
        RightMouseUp,
        MiddleMouseUp,
        MouseEnter,
        MouseLeave,
        Scroll,
        ScrollStart,
        ScrollEnd,
        TextInput,
        VirtualKeyDown,
        VirtualKeyUp,
        HoveredFile,
        DroppedFile,
        HoveredFileCancelled,
        Resized,
        Moved,
        TouchStart,
        TouchMove,
        TouchEnd,
        TouchCancel,
        FocusReceived,
        FocusLost,
        CloseRequested,
        ThemeChanged,
    }

    /// Re-export of rust-allocated (stack based) `ComponentEventFilter` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzComponentEventFilter {
        AfterMount,
        BeforeUnmount,
        NodeResized,
        DefaultAction,
        Selected,
    }

    /// Re-export of rust-allocated (stack based) `ApplicationEventFilter` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzApplicationEventFilter {
        DeviceConnected,
        DeviceDisconnected,
    }

    /// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzAccessibilityRole {
        TitleBar,
        MenuBar,
        ScrollBar,
        Grip,
        Sound,
        Cursor,
        Caret,
        Alert,
        Window,
        Client,
        MenuPopup,
        MenuItem,
        Tooltip,
        Application,
        Document,
        Pane,
        Chart,
        Dialog,
        Border,
        Grouping,
        Separator,
        Toolbar,
        StatusBar,
        Table,
        ColumnHeader,
        RowHeader,
        Column,
        Row,
        Cell,
        Link,
        HelpBalloon,
        Character,
        List,
        ListItem,
        Outline,
        OutlineItem,
        Pagetab,
        PropertyPage,
        Indicator,
        Graphic,
        StaticText,
        Text,
        PushButton,
        CheckButton,
        RadioButton,
        ComboBox,
        DropList,
        ProgressBar,
        Dial,
        HotkeyField,
        Slider,
        SpinButton,
        Diagram,
        Animation,
        Equation,
        ButtonDropdown,
        ButtonMenu,
        ButtonDropdownGrid,
        Whitespace,
        PageTabList,
        Clock,
        SplitButton,
        IpAddress,
        Nothing,
    }

    /// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzAccessibilityState {
        Unavailable,
        Selected,
        Focused,
        Checked,
        Readonly,
        Default,
        Expanded,
        Collapsed,
        Busy,
        Offscreen,
        Focusable,
        Selectable,
        Linked,
        Traversed,
        Multiselectable,
        Protected,
    }

    /// Re-export of rust-allocated (stack based) `TabIndex` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzTabIndex {
        Auto,
        OverrideInParent(u32),
        NoKeyboardFocus,
    }

    /// Determines whether this context menu should pop up on a left, right or middle click
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzContextMenuMouseButton {
        Right,
        Middle,
        Left,
    }

    /// Position of where the context menu should pop up
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzMenuPopupPosition {
        BottomLeftOfCursor,
        BottomRightOfCursor,
        TopLeftOfCursor,
        TopRightOfCursor,
        BottomOfHitRect,
        LeftOfHitRect,
        TopOfHitRect,
        RightOfHitRect,
        AutoCursor,
        AutoHitRect,
    }

    /// Describes the state of a menu item
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzMenuItemState {
        Normal,
        Greyed,
        Disabled,
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeKey` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzNodeTypeKey {
        Body,
        Div,
        Br,
        P,
        Img,
        IFrame,
    }

    /// Re-export of rust-allocated (stack based) `CssNthChildPattern` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzCssNthChildPattern {
        pub repeat: u32,
        pub offset: u32,
    }

    /// Re-export of rust-allocated (stack based) `CssPropertyType` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzCssPropertyType {
        TextColor,
        FontSize,
        FontFamily,
        TextAlign,
        LetterSpacing,
        LineHeight,
        WordSpacing,
        TabWidth,
        Cursor,
        Display,
        Float,
        BoxSizing,
        Width,
        Height,
        MinWidth,
        MinHeight,
        MaxWidth,
        MaxHeight,
        Position,
        Top,
        Right,
        Left,
        Bottom,
        FlexWrap,
        FlexDirection,
        FlexGrow,
        FlexShrink,
        JustifyContent,
        AlignItems,
        AlignContent,
        BackgroundContent,
        BackgroundPosition,
        BackgroundSize,
        BackgroundRepeat,
        OverflowX,
        OverflowY,
        PaddingTop,
        PaddingLeft,
        PaddingRight,
        PaddingBottom,
        MarginTop,
        MarginLeft,
        MarginRight,
        MarginBottom,
        BorderTopLeftRadius,
        BorderTopRightRadius,
        BorderBottomLeftRadius,
        BorderBottomRightRadius,
        BorderTopColor,
        BorderRightColor,
        BorderLeftColor,
        BorderBottomColor,
        BorderTopStyle,
        BorderRightStyle,
        BorderLeftStyle,
        BorderBottomStyle,
        BorderTopWidth,
        BorderRightWidth,
        BorderLeftWidth,
        BorderBottomWidth,
        BoxShadowLeft,
        BoxShadowRight,
        BoxShadowTop,
        BoxShadowBottom,
        ScrollbarStyle,
        Opacity,
        Transform,
        TransformOrigin,
        PerspectiveOrigin,
        BackfaceVisibility,
        MixBlendMode,
        Filter,
        BackdropFilter,
        TextShadow,
    }

    /// Re-export of rust-allocated (stack based) `ColorU` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzColorU {
        pub r: u8,
        pub g: u8,
        pub b: u8,
        pub a: u8,
    }

    /// Re-export of rust-allocated (stack based) `SizeMetric` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzSizeMetric {
        Px,
        Pt,
        Em,
        Percent,
    }

    /// Re-export of rust-allocated (stack based) `FloatValue` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzFloatValue {
        pub number: isize,
    }

    /// Re-export of rust-allocated (stack based) `BoxShadowClipMode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzBoxShadowClipMode {
        Outset,
        Inset,
    }

    /// Re-export of rust-allocated (stack based) `StyleMixBlendMode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleMixBlendMode {
        Normal,
        Multiply,
        Screen,
        Overlay,
        Darken,
        Lighten,
        ColorDodge,
        ColorBurn,
        HardLight,
        SoftLight,
        Difference,
        Exclusion,
        Hue,
        Saturation,
        Color,
        Luminosity,
    }

    /// Re-export of rust-allocated (stack based) `LayoutAlignContent` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutAlignContent {
        Stretch,
        Center,
        Start,
        End,
        SpaceBetween,
        SpaceAround,
    }

    /// Re-export of rust-allocated (stack based) `LayoutAlignItems` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutAlignItems {
        Stretch,
        Center,
        FlexStart,
        FlexEnd,
    }

    /// Re-export of rust-allocated (stack based) `LayoutBoxSizing` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBoxSizing {
        ContentBox,
        BorderBox,
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexDirection` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexDirection {
        Row,
        RowReverse,
        Column,
        ColumnReverse,
    }

    /// Re-export of rust-allocated (stack based) `LayoutDisplay` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutDisplay {
        None,
        Flex,
        Block,
        InlineBlock,
    }

    /// Re-export of rust-allocated (stack based) `LayoutFloat` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFloat {
        Left,
        Right,
    }

    /// Re-export of rust-allocated (stack based) `LayoutJustifyContent` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutJustifyContent {
        Start,
        End,
        Center,
        SpaceBetween,
        SpaceAround,
        SpaceEvenly,
    }

    /// Re-export of rust-allocated (stack based) `LayoutPosition` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPosition {
        Static,
        Relative,
        Absolute,
        Fixed,
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexWrap` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexWrap {
        Wrap,
        NoWrap,
    }

    /// Re-export of rust-allocated (stack based) `LayoutOverflow` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutOverflow {
        Scroll,
        Auto,
        Hidden,
        Visible,
    }

    /// Re-export of rust-allocated (stack based) `AngleMetric` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAngleMetric {
        Degree,
        Radians,
        Grad,
        Turn,
        Percent,
    }

    /// Re-export of rust-allocated (stack based) `DirectionCorner` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzDirectionCorner {
        Right,
        Left,
        Top,
        Bottom,
        TopRight,
        TopLeft,
        BottomRight,
        BottomLeft,
    }

    /// Re-export of rust-allocated (stack based) `ExtendMode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzExtendMode {
        Clamp,
        Repeat,
    }

    /// Re-export of rust-allocated (stack based) `Shape` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzShape {
        Ellipse,
        Circle,
    }

    /// Re-export of rust-allocated (stack based) `RadialGradientSize` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzRadialGradientSize {
        ClosestSide,
        ClosestCorner,
        FarthestSide,
        FarthestCorner,
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeat` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzStyleBackgroundRepeat {
        NoRepeat,
        Repeat,
        RepeatX,
        RepeatY,
    }

    /// Re-export of rust-allocated (stack based) `BorderStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzBorderStyle {
        None,
        Solid,
        Double,
        Dotted,
        Dashed,
        Hidden,
        Groove,
        Ridge,
        Inset,
        Outset,
    }

    /// Re-export of rust-allocated (stack based) `StyleCursor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleCursor {
        Alias,
        AllScroll,
        Cell,
        ColResize,
        ContextMenu,
        Copy,
        Crosshair,
        Default,
        EResize,
        EwResize,
        Grab,
        Grabbing,
        Help,
        Move,
        NResize,
        NsResize,
        NeswResize,
        NwseResize,
        Pointer,
        Progress,
        RowResize,
        SResize,
        SeResize,
        Text,
        Unset,
        VerticalText,
        WResize,
        Wait,
        ZoomIn,
        ZoomOut,
    }

    /// Re-export of rust-allocated (stack based) `StyleBackfaceVisibility` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBackfaceVisibility {
        Hidden,
        Visible,
    }

    /// Re-export of rust-allocated (stack based) `StyleTextAlign` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTextAlign {
        Left,
        Center,
        Right,
    }

    /// Re-export of rust-allocated (stack based) `FileInputOnPathChangeCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzFileInputOnPathChangeCallback {
        pub cb: AzFileInputOnPathChangeCallbackType,
    }

    /// `AzFileInputOnPathChangeCallbackType` struct
    pub type AzFileInputOnPathChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzFileInputState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `CheckBoxOnToggleCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzCheckBoxOnToggleCallback {
        pub cb: AzCheckBoxOnToggleCallbackType,
    }

    /// `AzCheckBoxOnToggleCallbackType` struct
    pub type AzCheckBoxOnToggleCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzCheckBoxState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `CheckBoxState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCheckBoxState {
        pub checked: bool,
    }

    /// Re-export of rust-allocated (stack based) `ColorInputOnValueChangeCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzColorInputOnValueChangeCallback {
        pub cb: AzColorInputOnValueChangeCallbackType,
    }

    /// `AzColorInputOnValueChangeCallbackType` struct
    pub type AzColorInputOnValueChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzColorInputState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `TextInputSelectionRange` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputSelectionRange {
        pub from: usize,
        pub to: usize,
    }

    /// Re-export of rust-allocated (stack based) `TextInputOnTextInputCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzTextInputOnTextInputCallback {
        pub cb: AzTextInputOnTextInputCallbackType,
    }

    /// `AzTextInputOnTextInputCallbackType` struct
    pub type AzTextInputOnTextInputCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

    /// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDownCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzTextInputOnVirtualKeyDownCallback {
        pub cb: AzTextInputOnVirtualKeyDownCallbackType,
    }

    /// `AzTextInputOnVirtualKeyDownCallbackType` struct
    pub type AzTextInputOnVirtualKeyDownCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzOnTextInputReturn;

    /// Re-export of rust-allocated (stack based) `TextInputOnFocusLostCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzTextInputOnFocusLostCallback {
        pub cb: AzTextInputOnFocusLostCallbackType,
    }

    /// `AzTextInputOnFocusLostCallbackType` struct
    pub type AzTextInputOnFocusLostCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzTextInputState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `TextInputValid` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzTextInputValid {
        Yes,
        No,
    }

    /// Re-export of rust-allocated (stack based) `NumberInputState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNumberInputState {
        pub previous: f32,
        pub number: f32,
        pub min: f32,
        pub max: f32,
    }

    /// Re-export of rust-allocated (stack based) `NumberInputOnValueChangeCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNumberInputOnValueChangeCallback {
        pub cb: AzNumberInputOnValueChangeCallbackType,
    }

    /// `AzNumberInputOnValueChangeCallbackType` struct
    pub type AzNumberInputOnValueChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NumberInputOnFocusLostCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNumberInputOnFocusLostCallback {
        pub cb: AzNumberInputOnFocusLostCallbackType,
    }

    /// `AzNumberInputOnFocusLostCallbackType` struct
    pub type AzNumberInputOnFocusLostCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, &AzNumberInputState) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `ProgressBarState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzProgressBarState {
        pub percent_done: f32,
        pub display_percentage: bool,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzNodeGraphStyle {
        Default,
    }

    /// `AzNodeGraphOnNodeAddedCallbackType` struct
    pub type AzNodeGraphOnNodeAddedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeTypeId, AzNodeGraphNodeId, AzNodePosition) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAddedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeAddedCallback {
        pub cb: AzNodeGraphOnNodeAddedCallbackType,
    }

    /// `AzNodeGraphOnNodeRemovedCallbackType` struct
    pub type AzNodeGraphOnNodeRemovedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemovedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeRemovedCallback {
        pub cb: AzNodeGraphOnNodeRemovedCallbackType,
    }

    /// `AzNodeGraphOnNodeGraphDraggedCallbackType` struct
    pub type AzNodeGraphOnNodeGraphDraggedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzGraphDragAmount) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDraggedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeGraphDraggedCallback {
        pub cb: AzNodeGraphOnNodeGraphDraggedCallbackType,
    }

    /// `AzNodeGraphOnNodeDraggedCallbackType` struct
    pub type AzNodeGraphOnNodeDraggedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, AzNodeDragAmount) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDraggedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeDraggedCallback {
        pub cb: AzNodeGraphOnNodeDraggedCallbackType,
    }

    /// `AzNodeGraphOnNodeConnectedCallbackType` struct
    pub type AzNodeGraphOnNodeConnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize, AzNodeGraphNodeId, usize) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnectedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeConnectedCallback {
        pub cb: AzNodeGraphOnNodeConnectedCallbackType,
    }

    /// `AzNodeGraphOnNodeInputDisconnectedCallbackType` struct
    pub type AzNodeGraphOnNodeInputDisconnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnectedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeInputDisconnectedCallback {
        pub cb: AzNodeGraphOnNodeInputDisconnectedCallbackType,
    }

    /// `AzNodeGraphOnNodeOutputDisconnectedCallbackType` struct
    pub type AzNodeGraphOnNodeOutputDisconnectedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnectedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeOutputDisconnectedCallback {
        pub cb: AzNodeGraphOnNodeOutputDisconnectedCallbackType,
    }

    /// `AzNodeGraphOnNodeFieldEditedCallbackType` struct
    pub type AzNodeGraphOnNodeFieldEditedCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, AzNodeGraphNodeId, usize, AzNodeTypeId, AzNodeTypeFieldValue) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEditedCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzNodeGraphOnNodeFieldEditedCallback {
        pub cb: AzNodeGraphOnNodeFieldEditedCallbackType,
    }

    /// Re-export of rust-allocated (stack based) `InputOutputTypeId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[derive(Eq)]
    #[derive(Ord)]
    #[derive(Hash)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "serde-support", serde(transparent))]
    pub struct AzInputOutputTypeId {
        pub inner: u64,
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[derive(Eq)]
    #[derive(Ord)]
    #[derive(Hash)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "serde-support", serde(transparent))]
    pub struct AzNodeTypeId {
        pub inner: u64,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphNodeId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[derive(Eq)]
    #[derive(Ord)]
    #[derive(Hash)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    #[cfg_attr(feature = "serde-support", serde(transparent))]
    pub struct AzNodeGraphNodeId {
        pub inner: u64,
    }

    /// Re-export of rust-allocated (stack based) `NodePosition` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNodePosition {
        pub x: f32,
        pub y: f32,
    }

    /// Re-export of rust-allocated (stack based) `GraphDragAmount` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzGraphDragAmount {
        pub x: f32,
        pub y: f32,
    }

    /// Re-export of rust-allocated (stack based) `NodeDragAmount` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNodeDragAmount {
        pub x: f32,
        pub y: f32,
    }

    /// `AzDropDownOnChoiceChangeCallbackType` struct
    pub type AzDropDownOnChoiceChangeCallbackType = extern "C" fn(&mut AzRefAny, &mut AzCallbackInfo, usize) -> AzUpdate;

    /// Re-export of rust-allocated (stack based) `DropDownOnChoiceChangeCallback` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzDropDownOnChoiceChangeCallback {
        pub cb: AzDropDownOnChoiceChangeCallbackType,
    }

    /// Re-export of rust-allocated (stack based) `NodeHierarchyItem` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzNodeHierarchyItem {
        pub parent: usize,
        pub previous_sibling: usize,
        pub next_sibling: usize,
        pub last_child: usize,
    }

    /// Re-export of rust-allocated (stack based) `CascadeInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzCascadeInfo {
        pub index_in_parent: u32,
        pub is_last_child: bool,
    }

    /// Re-export of rust-allocated (stack based) `StyledNodeState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyledNodeState {
        pub normal: bool,
        pub hover: bool,
        pub active: bool,
        pub focused: bool,
    }

    /// Re-export of rust-allocated (stack based) `TagId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzTagId {
        pub inner: u64,
    }

    /// Re-export of rust-allocated (stack based) `CssPropertyCache` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCssPropertyCache {
        pub(crate) ptr: *mut c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `GlVoidPtrConst` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGlVoidPtrConst {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `GlVoidPtrMut` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGlVoidPtrMut {
        pub(crate) ptr: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `GlShaderPrecisionFormatReturn` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzGlShaderPrecisionFormatReturn {
        pub _0: i32,
        pub _1: i32,
        pub _2: i32,
    }

    /// Re-export of rust-allocated (stack based) `VertexAttributeType` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzVertexAttributeType {
        Float,
        Double,
        UnsignedByte,
        UnsignedShort,
        UnsignedInt,
    }

    /// Re-export of rust-allocated (stack based) `IndexBufferFormat` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzIndexBufferFormat {
        Points,
        Lines,
        LineStrip,
        Triangles,
        TriangleStrip,
        TriangleFan,
    }

    /// Re-export of rust-allocated (stack based) `GlType` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzGlType {
        Gl,
        Gles,
    }

    /// C-ABI stable reexport of `&[u8]`
    #[repr(C)]
    pub struct AzU8VecRef {
        pub(crate) ptr: *const u8,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&mut [u8]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzU8VecRefMut {
        pub(crate) ptr: *mut u8,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&[f32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzF32VecRef {
        pub(crate) ptr: *const f32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&[i32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzI32VecRef {
        pub(crate) ptr: *const i32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLuintVecRef {
        pub(crate) ptr: *const u32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLenumVecRef {
        pub(crate) ptr: *const u32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLintVecRefMut {
        pub(crate) ptr: *mut i32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLint64VecRefMut {
        pub(crate) ptr: *mut i64,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLbooleanVecRefMut {
        pub(crate) ptr: *mut u8,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLfloatVecRefMut {
        pub(crate) ptr: *mut f32,
        pub len: usize,
    }

    /// C-ABI stable reexport of `&str`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRefstr {
        pub(crate) ptr: *const u8,
        pub len: usize,
    }

    /// C-ABI stable reexport of `*const gleam::gl::GLsync`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGLsyncPtr {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `TextureFlags` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzTextureFlags {
        pub is_opaque: bool,
        pub is_video_texture: bool,
    }

    /// Re-export of rust-allocated (stack based) `ImageRef` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzImageRef {
        pub data: *const c_void,
        pub copies: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `RawImageFormat` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzRawImageFormat {
        R8,
        RG8,
        RGB8,
        RGBA8,
        R16,
        RG16,
        RGB16,
        RGBA16,
        BGR8,
        BGRA8,
    }

    /// Re-export of rust-allocated (stack based) `EncodeImageError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzEncodeImageError {
        EncoderNotAvailable,
        InsufficientMemory,
        DimensionError,
        InvalidData,
        Unknown,
    }

    /// Re-export of rust-allocated (stack based) `DecodeImageError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzDecodeImageError {
        InsufficientMemory,
        DimensionError,
        UnsupportedImageFormat,
        Unknown,
    }

    /// `AzParsedFontDestructorFnType` struct
    pub type AzParsedFontDestructorFnType = extern "C" fn(&mut c_void);

    /// Atomically reference-counted parsed font data
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFontRef {
        pub data: *const c_void,
        pub copies: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `Svg` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvg {
        pub(crate) ptr: *mut c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `SvgXmlNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgXmlNode {
        pub(crate) ptr: *mut c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `SvgCircle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgCircle {
        pub center_x: f32,
        pub center_y: f32,
        pub radius: f32,
    }

    /// Re-export of rust-allocated (stack based) `SvgPoint` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgPoint {
        pub x: f32,
        pub y: f32,
    }

    /// Re-export of rust-allocated (stack based) `SvgVector` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgVector {
        pub x: f64,
        pub y: f64,
    }

    /// Re-export of rust-allocated (stack based) `SvgRect` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgRect {
        pub width: f32,
        pub height: f32,
        pub x: f32,
        pub y: f32,
        pub radius_top_left: f32,
        pub radius_top_right: f32,
        pub radius_bottom_left: f32,
        pub radius_bottom_right: f32,
    }

    /// Re-export of rust-allocated (stack based) `SvgVertex` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgVertex {
        pub x: f32,
        pub y: f32,
    }

    /// Re-export of rust-allocated (stack based) `ShapeRendering` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzShapeRendering {
        OptimizeSpeed,
        CrispEdges,
        GeometricPrecision,
    }

    /// Re-export of rust-allocated (stack based) `TextRendering` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzTextRendering {
        OptimizeSpeed,
        OptimizeLegibility,
        GeometricPrecision,
    }

    /// Re-export of rust-allocated (stack based) `ImageRendering` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzImageRendering {
        OptimizeQuality,
        OptimizeSpeed,
    }

    /// Re-export of rust-allocated (stack based) `FontDatabase` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzFontDatabase {
        Empty,
        System,
    }

    /// Re-export of rust-allocated (stack based) `Indent` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzIndent {
        None,
        Spaces(u8),
        Tabs,
    }

    /// Re-export of rust-allocated (stack based) `SvgFitTo` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzSvgFitTo {
        Original,
        Width(u32),
        Height(u32),
        Zoom(f32),
    }

    /// Re-export of rust-allocated (stack based) `SvgFillRule` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzSvgFillRule {
        Winding,
        EvenOdd,
    }

    /// Re-export of rust-allocated (stack based) `SvgTransform` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgTransform {
        pub sx: f32,
        pub kx: f32,
        pub ky: f32,
        pub sy: f32,
        pub tx: f32,
        pub ty: f32,
    }

    /// Re-export of rust-allocated (stack based) `SvgLineJoin` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzSvgLineJoin {
        Miter,
        MiterClip,
        Round,
        Bevel,
    }

    /// Re-export of rust-allocated (stack based) `SvgLineCap` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzSvgLineCap {
        Butt,
        Square,
        Round,
    }

    /// Re-export of rust-allocated (stack based) `SvgDashPattern` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgDashPattern {
        pub offset: f32,
        pub length_1: f32,
        pub gap_1: f32,
        pub length_2: f32,
        pub gap_2: f32,
        pub length_3: f32,
        pub gap_3: f32,
    }

    /// Re-export of rust-allocated (stack based) `MsgBox` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMsgBox {
        pub _reserved: usize,
    }

    /// Type of message box icon
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzMsgBoxIcon {
        Info,
        Warning,
        Error,
        Question,
    }

    /// Value returned from a yes / no message box
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzMsgBoxYesNo {
        Yes,
        No,
    }

    /// Value returned from an ok / cancel message box
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzMsgBoxOkCancel {
        Ok,
        Cancel,
    }

    /// File picker dialog
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileDialog {
        pub _reserved: usize,
    }

    /// Re-export of rust-allocated (stack based) `ColorPickerDialog` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzColorPickerDialog {
        pub _reserved: usize,
    }

    /// Connection to the system clipboard, on some systems this connection can be cached
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSystemClipboard {
        pub _native: *const c_void,
        pub run_destructor: bool,
    }

    /// `AzInstantPtrCloneFnType` struct
    pub type AzInstantPtrCloneFnType = extern "C" fn(&AzInstantPtr) -> AzInstantPtr;

    /// Re-export of rust-allocated (stack based) `InstantPtrCloneFn` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzInstantPtrCloneFn {
        pub cb: AzInstantPtrCloneFnType,
    }

    /// `AzInstantPtrDestructorFnType` struct
    pub type AzInstantPtrDestructorFnType = extern "C" fn(&mut AzInstantPtr);

    /// Re-export of rust-allocated (stack based) `InstantPtrDestructorFn` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub struct AzInstantPtrDestructorFn {
        pub cb: AzInstantPtrDestructorFnType,
    }

    /// Re-export of rust-allocated (stack based) `SystemTick` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSystemTick {
        pub tick_counter: u64,
    }

    /// Re-export of rust-allocated (stack based) `SystemTimeDiff` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSystemTimeDiff {
        pub secs: u64,
        pub nanos: u32,
    }

    /// Re-export of rust-allocated (stack based) `SystemTickDiff` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSystemTickDiff {
        pub tick_diff: u64,
    }

    /// Re-export of rust-allocated (stack based) `TimerId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzTimerId {
        pub id: usize,
    }

    /// Should a timer terminate or not - used to remove active timers
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzTerminateTimer {
        Terminate,
        Continue,
    }

    /// Re-export of rust-allocated (stack based) `ThreadId` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzThreadId {
        pub id: usize,
    }

    /// Re-export of rust-allocated (stack based) `Thread` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzThread {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `ThreadSender` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzThreadSender {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `ThreadReceiver` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzThreadReceiver {
        pub(crate) ptr: *const c_void,
        pub run_destructor: bool,
    }

    /// `AzCreateThreadFnType` struct
    pub type AzCreateThreadFnType = extern "C" fn(AzRefAny, AzRefAny, AzThreadCallback) -> AzThread;

    /// Re-export of rust-allocated (stack based) `CreateThreadFn` struct
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzCreateThreadFn {
        pub cb: AzCreateThreadFnType,
    }

    /// `AzGetSystemTimeFnType` struct
    pub type AzGetSystemTimeFnType = extern "C" fn() -> AzInstant;

    /// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on systems that work with "ticks" instead of timers
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzGetSystemTimeFn {
        pub cb: AzGetSystemTimeFnType,
    }

    /// `AzCheckThreadFinishedFnType` struct
    pub type AzCheckThreadFinishedFnType = extern "C" fn(&c_void) -> bool;

    /// Function called to check if the thread has finished
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzCheckThreadFinishedFn {
        pub cb: AzCheckThreadFinishedFnType,
    }

    /// `AzLibrarySendThreadMsgFnType` struct
    pub type AzLibrarySendThreadMsgFnType = extern "C" fn(&c_void, AzThreadSendMsg) -> bool;

    /// Function to send a message to the thread
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzLibrarySendThreadMsgFn {
        pub cb: AzLibrarySendThreadMsgFnType,
    }

    /// `AzLibraryReceiveThreadMsgFnType` struct
    pub type AzLibraryReceiveThreadMsgFnType = extern "C" fn(&c_void) -> AzOptionThreadReceiveMsg;

    /// Function to receive a message from the thread
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzLibraryReceiveThreadMsgFn {
        pub cb: AzLibraryReceiveThreadMsgFnType,
    }

    /// `AzThreadRecvFnType` struct
    pub type AzThreadRecvFnType = extern "C" fn(&c_void) -> AzOptionThreadSendMsg;

    /// Function that the running `Thread` can call to receive messages from the main UI thread
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadRecvFn {
        pub cb: AzThreadRecvFnType,
    }

    /// `AzThreadSendFnType` struct
    pub type AzThreadSendFnType = extern "C" fn(&c_void, AzThreadReceiveMsg) -> bool;

    /// Function that the running `Thread` can call to receive messages from the main UI thread
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadSendFn {
        pub cb: AzThreadSendFnType,
    }

    /// `AzThreadDestructorFnType` struct
    pub type AzThreadDestructorFnType = extern "C" fn(&mut AzThread);

    /// Destructor of the `Thread`
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadDestructorFn {
        pub cb: AzThreadDestructorFnType,
    }

    /// `AzThreadReceiverDestructorFnType` struct
    pub type AzThreadReceiverDestructorFnType = extern "C" fn(&mut AzThreadReceiver);

    /// Destructor of the `ThreadReceiver`
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadReceiverDestructorFn {
        pub cb: AzThreadReceiverDestructorFnType,
    }

    /// `AzThreadSenderDestructorFnType` struct
    pub type AzThreadSenderDestructorFnType = extern "C" fn(&mut AzThreadSender);

    /// Destructor of the `ThreadSender`
    #[repr(C)]
    #[derive(Clone)]
    pub struct AzThreadSenderDestructorFn {
        pub cb: AzThreadSenderDestructorFnType,
    }

    /// Re-export of rust-allocated (stack based) `StyleFontFamilyVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleFontFamilyVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleFontFamilyVecDestructorType),
    }

    /// `AzStyleFontFamilyVecDestructorType` struct
    pub type AzStyleFontFamilyVecDestructorType = extern "C" fn(&mut AzStyleFontFamilyVec);

    /// Re-export of rust-allocated (stack based) `StyleFilterVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleFilterVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleFilterVecDestructorType),
    }

    /// `AzStyleFilterVecDestructorType` struct
    pub type AzStyleFilterVecDestructorType = extern "C" fn(&mut AzStyleFilterVec);

    /// Re-export of rust-allocated (stack based) `LogicalRectVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzLogicalRectVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzLogicalRectVecDestructorType),
    }

    /// `AzLogicalRectVecDestructorType` struct
    pub type AzLogicalRectVecDestructorType = extern "C" fn(&mut AzLogicalRectVec);

    /// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMapVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeTypeIdInfoMapVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeTypeIdInfoMapVecDestructorType),
    }

    /// `AzNodeTypeIdInfoMapVecDestructorType` struct
    pub type AzNodeTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzNodeTypeIdInfoMapVec);

    /// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMapVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInputOutputTypeIdInfoMapVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInputOutputTypeIdInfoMapVecDestructorType),
    }

    /// `AzInputOutputTypeIdInfoMapVecDestructorType` struct
    pub type AzInputOutputTypeIdInfoMapVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdInfoMapVec);

    /// Re-export of rust-allocated (stack based) `NodeIdNodeMapVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeIdNodeMapVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeIdNodeMapVecDestructorType),
    }

    /// `AzNodeIdNodeMapVecDestructorType` struct
    pub type AzNodeIdNodeMapVecDestructorType = extern "C" fn(&mut AzNodeIdNodeMapVec);

    /// Re-export of rust-allocated (stack based) `InputOutputTypeIdVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInputOutputTypeIdVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInputOutputTypeIdVecDestructorType),
    }

    /// `AzInputOutputTypeIdVecDestructorType` struct
    pub type AzInputOutputTypeIdVecDestructorType = extern "C" fn(&mut AzInputOutputTypeIdVec);

    /// Re-export of rust-allocated (stack based) `NodeTypeFieldVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeTypeFieldVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeTypeFieldVecDestructorType),
    }

    /// `AzNodeTypeFieldVecDestructorType` struct
    pub type AzNodeTypeFieldVecDestructorType = extern "C" fn(&mut AzNodeTypeFieldVec);

    /// Re-export of rust-allocated (stack based) `InputConnectionVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInputConnectionVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInputConnectionVecDestructorType),
    }

    /// `AzInputConnectionVecDestructorType` struct
    pub type AzInputConnectionVecDestructorType = extern "C" fn(&mut AzInputConnectionVec);

    /// Re-export of rust-allocated (stack based) `OutputNodeAndIndexVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzOutputNodeAndIndexVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzOutputNodeAndIndexVecDestructorType),
    }

    /// `AzOutputNodeAndIndexVecDestructorType` struct
    pub type AzOutputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzOutputNodeAndIndexVec);

    /// Re-export of rust-allocated (stack based) `OutputConnectionVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzOutputConnectionVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzOutputConnectionVecDestructorType),
    }

    /// `AzOutputConnectionVecDestructorType` struct
    pub type AzOutputConnectionVecDestructorType = extern "C" fn(&mut AzOutputConnectionVec);

    /// Re-export of rust-allocated (stack based) `InputNodeAndIndexVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInputNodeAndIndexVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInputNodeAndIndexVecDestructorType),
    }

    /// `AzInputNodeAndIndexVecDestructorType` struct
    pub type AzInputNodeAndIndexVecDestructorType = extern "C" fn(&mut AzInputNodeAndIndexVec);

    /// Re-export of rust-allocated (stack based) `TabVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzTabVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzTabVecDestructorType),
    }

    /// `AzTabVecDestructorType` struct
    pub type AzTabVecDestructorType = extern "C" fn(&mut AzTabVec);

    /// Re-export of rust-allocated (stack based) `AccessibilityStateVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzAccessibilityStateVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzAccessibilityStateVecDestructorType),
    }

    /// `AzAccessibilityStateVecDestructorType` struct
    pub type AzAccessibilityStateVecDestructorType = extern "C" fn(&mut AzAccessibilityStateVec);

    /// Re-export of rust-allocated (stack based) `MenuItemVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzMenuItemVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzMenuItemVecDestructorType),
    }

    /// `AzMenuItemVecDestructorType` struct
    pub type AzMenuItemVecDestructorType = extern "C" fn(&mut AzMenuItemVec);

    /// Re-export of rust-allocated (stack based) `TessellatedSvgNodeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzTessellatedSvgNodeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzTessellatedSvgNodeVecDestructorType),
    }

    /// `AzTessellatedSvgNodeVecDestructorType` struct
    pub type AzTessellatedSvgNodeVecDestructorType = extern "C" fn(&mut AzTessellatedSvgNodeVec);

    /// Re-export of rust-allocated (stack based) `XmlNodeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzXmlNodeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzXmlNodeVecDestructorType),
    }

    /// `AzXmlNodeVecDestructorType` struct
    pub type AzXmlNodeVecDestructorType = extern "C" fn(&mut AzXmlNodeVec);

    /// Re-export of rust-allocated (stack based) `FmtArgVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzFmtArgVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzFmtArgVecDestructorType),
    }

    /// `AzFmtArgVecDestructorType` struct
    pub type AzFmtArgVecDestructorType = extern "C" fn(&mut AzFmtArgVec);

    /// Re-export of rust-allocated (stack based) `InlineLineVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInlineLineVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInlineLineVecDestructorType),
    }

    /// `AzInlineLineVecDestructorType` struct
    pub type AzInlineLineVecDestructorType = extern "C" fn(&mut AzInlineLineVec);

    /// Re-export of rust-allocated (stack based) `InlineWordVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInlineWordVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInlineWordVecDestructorType),
    }

    /// `AzInlineWordVecDestructorType` struct
    pub type AzInlineWordVecDestructorType = extern "C" fn(&mut AzInlineWordVec);

    /// Re-export of rust-allocated (stack based) `InlineGlyphVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInlineGlyphVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInlineGlyphVecDestructorType),
    }

    /// `AzInlineGlyphVecDestructorType` struct
    pub type AzInlineGlyphVecDestructorType = extern "C" fn(&mut AzInlineGlyphVec);

    /// Re-export of rust-allocated (stack based) `InlineTextHitVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzInlineTextHitVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzInlineTextHitVecDestructorType),
    }

    /// `AzInlineTextHitVecDestructorType` struct
    pub type AzInlineTextHitVecDestructorType = extern "C" fn(&mut AzInlineTextHitVec);

    /// Re-export of rust-allocated (stack based) `MonitorVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzMonitorVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzMonitorVecDestructorType),
    }

    /// `AzMonitorVecDestructorType` struct
    pub type AzMonitorVecDestructorType = extern "C" fn(&mut AzMonitorVec);

    /// Re-export of rust-allocated (stack based) `VideoModeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzVideoModeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzVideoModeVecDestructorType),
    }

    /// `AzVideoModeVecDestructorType` struct
    pub type AzVideoModeVecDestructorType = extern "C" fn(&mut AzVideoModeVec);

    /// Re-export of rust-allocated (stack based) `DomVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzDomVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzDomVecDestructorType),
    }

    /// `AzDomVecDestructorType` struct
    pub type AzDomVecDestructorType = extern "C" fn(&mut AzDomVec);

    /// Re-export of rust-allocated (stack based) `IdOrClassVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzIdOrClassVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzIdOrClassVecDestructorType),
    }

    /// `AzIdOrClassVecDestructorType` struct
    pub type AzIdOrClassVecDestructorType = extern "C" fn(&mut AzIdOrClassVec);

    /// Re-export of rust-allocated (stack based) `NodeDataInlineCssPropertyVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeDataInlineCssPropertyVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeDataInlineCssPropertyVecDestructorType),
    }

    /// `AzNodeDataInlineCssPropertyVecDestructorType` struct
    pub type AzNodeDataInlineCssPropertyVecDestructorType = extern "C" fn(&mut AzNodeDataInlineCssPropertyVec);

    /// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleBackgroundContentVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleBackgroundContentVecDestructorType),
    }

    /// `AzStyleBackgroundContentVecDestructorType` struct
    pub type AzStyleBackgroundContentVecDestructorType = extern "C" fn(&mut AzStyleBackgroundContentVec);

    /// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleBackgroundPositionVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleBackgroundPositionVecDestructorType),
    }

    /// `AzStyleBackgroundPositionVecDestructorType` struct
    pub type AzStyleBackgroundPositionVecDestructorType = extern "C" fn(&mut AzStyleBackgroundPositionVec);

    /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleBackgroundRepeatVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleBackgroundRepeatVecDestructorType),
    }

    /// `AzStyleBackgroundRepeatVecDestructorType` struct
    pub type AzStyleBackgroundRepeatVecDestructorType = extern "C" fn(&mut AzStyleBackgroundRepeatVec);

    /// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleBackgroundSizeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleBackgroundSizeVecDestructorType),
    }

    /// `AzStyleBackgroundSizeVecDestructorType` struct
    pub type AzStyleBackgroundSizeVecDestructorType = extern "C" fn(&mut AzStyleBackgroundSizeVec);

    /// Re-export of rust-allocated (stack based) `StyleTransformVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyleTransformVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyleTransformVecDestructorType),
    }

    /// `AzStyleTransformVecDestructorType` struct
    pub type AzStyleTransformVecDestructorType = extern "C" fn(&mut AzStyleTransformVec);

    /// Re-export of rust-allocated (stack based) `CssPropertyVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCssPropertyVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCssPropertyVecDestructorType),
    }

    /// `AzCssPropertyVecDestructorType` struct
    pub type AzCssPropertyVecDestructorType = extern "C" fn(&mut AzCssPropertyVec);

    /// Re-export of rust-allocated (stack based) `SvgMultiPolygonVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzSvgMultiPolygonVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzSvgMultiPolygonVecDestructorType),
    }

    /// `AzSvgMultiPolygonVecDestructorType` struct
    pub type AzSvgMultiPolygonVecDestructorType = extern "C" fn(&mut AzSvgMultiPolygonVec);

    /// Re-export of rust-allocated (stack based) `SvgPathVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzSvgPathVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzSvgPathVecDestructorType),
    }

    /// `AzSvgPathVecDestructorType` struct
    pub type AzSvgPathVecDestructorType = extern "C" fn(&mut AzSvgPathVec);

    /// Re-export of rust-allocated (stack based) `VertexAttributeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzVertexAttributeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzVertexAttributeVecDestructorType),
    }

    /// `AzVertexAttributeVecDestructorType` struct
    pub type AzVertexAttributeVecDestructorType = extern "C" fn(&mut AzVertexAttributeVec);

    /// Re-export of rust-allocated (stack based) `SvgPathElementVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzSvgPathElementVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzSvgPathElementVecDestructorType),
    }

    /// `AzSvgPathElementVecDestructorType` struct
    pub type AzSvgPathElementVecDestructorType = extern "C" fn(&mut AzSvgPathElementVec);

    /// Re-export of rust-allocated (stack based) `SvgVertexVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzSvgVertexVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzSvgVertexVecDestructorType),
    }

    /// `AzSvgVertexVecDestructorType` struct
    pub type AzSvgVertexVecDestructorType = extern "C" fn(&mut AzSvgVertexVec);

    /// Re-export of rust-allocated (stack based) `U32VecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzU32VecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzU32VecDestructorType),
    }

    /// `AzU32VecDestructorType` struct
    pub type AzU32VecDestructorType = extern "C" fn(&mut AzU32Vec);

    /// Re-export of rust-allocated (stack based) `XWindowTypeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzXWindowTypeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzXWindowTypeVecDestructorType),
    }

    /// `AzXWindowTypeVecDestructorType` struct
    pub type AzXWindowTypeVecDestructorType = extern "C" fn(&mut AzXWindowTypeVec);

    /// Re-export of rust-allocated (stack based) `VirtualKeyCodeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzVirtualKeyCodeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzVirtualKeyCodeVecDestructorType),
    }

    /// `AzVirtualKeyCodeVecDestructorType` struct
    pub type AzVirtualKeyCodeVecDestructorType = extern "C" fn(&mut AzVirtualKeyCodeVec);

    /// Re-export of rust-allocated (stack based) `CascadeInfoVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCascadeInfoVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCascadeInfoVecDestructorType),
    }

    /// `AzCascadeInfoVecDestructorType` struct
    pub type AzCascadeInfoVecDestructorType = extern "C" fn(&mut AzCascadeInfoVec);

    /// Re-export of rust-allocated (stack based) `ScanCodeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzScanCodeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzScanCodeVecDestructorType),
    }

    /// `AzScanCodeVecDestructorType` struct
    pub type AzScanCodeVecDestructorType = extern "C" fn(&mut AzScanCodeVec);

    /// Re-export of rust-allocated (stack based) `CssDeclarationVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCssDeclarationVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCssDeclarationVecDestructorType),
    }

    /// `AzCssDeclarationVecDestructorType` struct
    pub type AzCssDeclarationVecDestructorType = extern "C" fn(&mut AzCssDeclarationVec);

    /// Re-export of rust-allocated (stack based) `CssPathSelectorVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCssPathSelectorVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCssPathSelectorVecDestructorType),
    }

    /// `AzCssPathSelectorVecDestructorType` struct
    pub type AzCssPathSelectorVecDestructorType = extern "C" fn(&mut AzCssPathSelectorVec);

    /// Re-export of rust-allocated (stack based) `StylesheetVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStylesheetVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStylesheetVecDestructorType),
    }

    /// `AzStylesheetVecDestructorType` struct
    pub type AzStylesheetVecDestructorType = extern "C" fn(&mut AzStylesheetVec);

    /// Re-export of rust-allocated (stack based) `CssRuleBlockVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCssRuleBlockVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCssRuleBlockVecDestructorType),
    }

    /// `AzCssRuleBlockVecDestructorType` struct
    pub type AzCssRuleBlockVecDestructorType = extern "C" fn(&mut AzCssRuleBlockVec);

    /// Re-export of rust-allocated (stack based) `F32VecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzF32VecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzF32VecDestructorType),
    }

    /// `AzF32VecDestructorType` struct
    pub type AzF32VecDestructorType = extern "C" fn(&mut AzF32Vec);

    /// Re-export of rust-allocated (stack based) `U16VecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzU16VecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzU16VecDestructorType),
    }

    /// `AzU16VecDestructorType` struct
    pub type AzU16VecDestructorType = extern "C" fn(&mut AzU16Vec);

    /// Re-export of rust-allocated (stack based) `U8VecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzU8VecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzU8VecDestructorType),
    }

    /// `AzU8VecDestructorType` struct
    pub type AzU8VecDestructorType = extern "C" fn(&mut AzU8Vec);

    /// Re-export of rust-allocated (stack based) `CallbackDataVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzCallbackDataVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzCallbackDataVecDestructorType),
    }

    /// `AzCallbackDataVecDestructorType` struct
    pub type AzCallbackDataVecDestructorType = extern "C" fn(&mut AzCallbackDataVec);

    /// Re-export of rust-allocated (stack based) `DebugMessageVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzDebugMessageVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzDebugMessageVecDestructorType),
    }

    /// `AzDebugMessageVecDestructorType` struct
    pub type AzDebugMessageVecDestructorType = extern "C" fn(&mut AzDebugMessageVec);

    /// Re-export of rust-allocated (stack based) `GLuintVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzGLuintVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzGLuintVecDestructorType),
    }

    /// `AzGLuintVecDestructorType` struct
    pub type AzGLuintVecDestructorType = extern "C" fn(&mut AzGLuintVec);

    /// Re-export of rust-allocated (stack based) `GLintVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzGLintVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzGLintVecDestructorType),
    }

    /// `AzGLintVecDestructorType` struct
    pub type AzGLintVecDestructorType = extern "C" fn(&mut AzGLintVec);

    /// Re-export of rust-allocated (stack based) `StringVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStringVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStringVecDestructorType),
    }

    /// `AzStringVecDestructorType` struct
    pub type AzStringVecDestructorType = extern "C" fn(&mut AzStringVec);

    /// Re-export of rust-allocated (stack based) `StringPairVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStringPairVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStringPairVecDestructorType),
    }

    /// `AzStringPairVecDestructorType` struct
    pub type AzStringPairVecDestructorType = extern "C" fn(&mut AzStringPairVec);

    /// Re-export of rust-allocated (stack based) `NormalizedLinearColorStopVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNormalizedLinearColorStopVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNormalizedLinearColorStopVecDestructorType),
    }

    /// `AzNormalizedLinearColorStopVecDestructorType` struct
    pub type AzNormalizedLinearColorStopVecDestructorType = extern "C" fn(&mut AzNormalizedLinearColorStopVec);

    /// Re-export of rust-allocated (stack based) `NormalizedRadialColorStopVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNormalizedRadialColorStopVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNormalizedRadialColorStopVecDestructorType),
    }

    /// `AzNormalizedRadialColorStopVecDestructorType` struct
    pub type AzNormalizedRadialColorStopVecDestructorType = extern "C" fn(&mut AzNormalizedRadialColorStopVec);

    /// Re-export of rust-allocated (stack based) `NodeIdVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeIdVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeIdVecDestructorType),
    }

    /// `AzNodeIdVecDestructorType` struct
    pub type AzNodeIdVecDestructorType = extern "C" fn(&mut AzNodeIdVec);

    /// Re-export of rust-allocated (stack based) `NodeHierarchyItemVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeHierarchyItemVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeHierarchyItemVecDestructorType),
    }

    /// `AzNodeHierarchyItemVecDestructorType` struct
    pub type AzNodeHierarchyItemVecDestructorType = extern "C" fn(&mut AzNodeHierarchyItemVec);

    /// Re-export of rust-allocated (stack based) `StyledNodeVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzStyledNodeVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzStyledNodeVecDestructorType),
    }

    /// `AzStyledNodeVecDestructorType` struct
    pub type AzStyledNodeVecDestructorType = extern "C" fn(&mut AzStyledNodeVec);

    /// Re-export of rust-allocated (stack based) `TagIdToNodeIdMappingVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzTagIdToNodeIdMappingVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzTagIdToNodeIdMappingVecDestructorType),
    }

    /// `AzTagIdToNodeIdMappingVecDestructorType` struct
    pub type AzTagIdToNodeIdMappingVecDestructorType = extern "C" fn(&mut AzTagIdToNodeIdMappingVec);

    /// Re-export of rust-allocated (stack based) `ParentWithNodeDepthVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzParentWithNodeDepthVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzParentWithNodeDepthVecDestructorType),
    }

    /// `AzParentWithNodeDepthVecDestructorType` struct
    pub type AzParentWithNodeDepthVecDestructorType = extern "C" fn(&mut AzParentWithNodeDepthVec);

    /// Re-export of rust-allocated (stack based) `NodeDataVecDestructor` struct
    #[repr(C, u8)]
    #[derive(Clone)]
    #[derive(Copy)]
    pub enum AzNodeDataVecDestructor {
        DefaultRust,
        NoDestructor,
        External(AzNodeDataVecDestructorType),
    }

    /// `AzNodeDataVecDestructorType` struct
    pub type AzNodeDataVecDestructorType = extern "C" fn(&mut AzNodeDataVec);

    /// Re-export of rust-allocated (stack based) `OptionI16` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionI16 {
        None,
        Some(i16),
    }

    /// Re-export of rust-allocated (stack based) `OptionU16` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionU16 {
        None,
        Some(u16),
    }

    /// Re-export of rust-allocated (stack based) `OptionU32` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionU32 {
        None,
        Some(u32),
    }

    /// Re-export of rust-allocated (stack based) `OptionHwndHandle` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionHwndHandle {
        None,
        Some(*mut c_void),
    }

    /// Re-export of rust-allocated (stack based) `OptionX11Visual` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionX11Visual {
        None,
        Some(*const c_void),
    }

    /// Re-export of rust-allocated (stack based) `OptionI32` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionI32 {
        None,
        Some(i32),
    }

    /// Re-export of rust-allocated (stack based) `OptionF32` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionF32 {
        None,
        Some(f32),
    }

    /// Option<char> but the char is a u32, for C FFI stability reasons
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionChar {
        None,
        Some(u32),
    }

    /// Re-export of rust-allocated (stack based) `OptionUsize` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionUsize {
        None,
        Some(usize),
    }

    /// Re-export of rust-allocated (stack based) `SvgParseErrorPosition` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgParseErrorPosition {
        pub row: u32,
        pub col: u32,
    }

    /// External system callbacks to get the system time or create / manage threads
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSystemCallbacks {
        pub create_thread_fn: AzCreateThreadFn,
        pub get_system_time_fn: AzGetSystemTimeFn,
    }

    /// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are not satisfied.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzRendererOptions {
        pub vsync: AzVsync,
        pub srgb: AzSrgb,
        pub hw_accel: AzHwAcceleration,
    }

    /// Represents a rectangle in physical pixels (integer units)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLayoutRect {
        pub origin: AzLayoutPoint,
        pub size: AzLayoutSize,
    }

    /// Raw platform handle, for integration in / with other toolkits and custom non-azul window extensions
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzRawWindowHandle {
        IOS(AzIOSHandle),
        MacOS(AzMacOSHandle),
        Xlib(AzXlibHandle),
        Xcb(AzXcbHandle),
        Wayland(AzWaylandHandle),
        Windows(AzWindowsHandle),
        Web(AzWebHandle),
        Android(AzAndroidHandle),
        Unsupported,
    }

    /// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzLogicalRect {
        pub origin: AzLogicalPosition,
        pub size: AzLogicalSize,
    }

    /// Symbolic accelerator key (ctrl, alt, shift)
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAcceleratorKey {
        Ctrl,
        Alt,
        Shift,
        Key(AzVirtualKeyCode),
    }

    /// Boolean flags relating to the current window state
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzWindowFlags {
        pub frame: AzWindowFrame,
        pub is_about_to_close: bool,
        pub has_decorations: bool,
        pub is_visible: bool,
        pub is_always_on_top: bool,
        pub is_resizable: bool,
        pub has_focus: bool,
        pub has_extended_window_frame: bool,
        pub has_blur_behind_window: bool,
        pub smooth_scroll_enabled: bool,
        pub autotab_enabled: bool,
    }

    /// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup (gets initialized on the first frame).
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzCursorPosition {
        OutOfWindow,
        Uninitialized,
        InWindow(AzLogicalPosition),
    }

    /// Position of the top left corner of the window relative to the top left of the monitor
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzWindowPosition {
        Uninitialized,
        Initialized(AzPhysicalPositionI32),
    }

    /// Position of the virtual keyboard necessary to insert CJK characters
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzImePosition {
        Uninitialized,
        Initialized(AzLogicalPosition),
    }

    /// Describes a rendering configuration for a monitor
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzVideoMode {
        pub size: AzLayoutSize,
        pub bit_depth: u16,
        pub refresh_rate: u16,
    }

    /// Combination of node ID + DOM ID, both together can identify a node
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzDomNodeId {
        pub dom: AzDomId,
        pub node: AzNodeId,
    }

    /// Re-export of rust-allocated (stack based) `PositionInfo` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzPositionInfo {
        Static(AzPositionInfoInner),
        Fixed(AzPositionInfoInner),
        Absolute(AzPositionInfoInner),
        Relative(AzPositionInfoInner),
    }

    /// Re-export of rust-allocated (stack based) `HidpiAdjustedBounds` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzHidpiAdjustedBounds {
        pub logical_size: AzLogicalSize,
        pub hidpi_factor: f32,
    }

    /// Re-export of rust-allocated (stack based) `InlineGlyph` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInlineGlyph {
        pub bounds: AzLogicalRect,
        pub unicode_codepoint: AzOptionChar,
        pub glyph_index: u32,
    }

    /// Re-export of rust-allocated (stack based) `InlineTextHit` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInlineTextHit {
        pub unicode_codepoint: AzOptionChar,
        pub hit_relative_to_inline_text: AzLogicalPosition,
        pub hit_relative_to_line: AzLogicalPosition,
        pub hit_relative_to_text_content: AzLogicalPosition,
        pub hit_relative_to_glyph: AzLogicalPosition,
        pub line_index_relative_to_text: usize,
        pub word_index_relative_to_text: usize,
        pub text_content_index_relative_to_text: usize,
        pub glyph_index_relative_to_text: usize,
        pub char_index_relative_to_text: usize,
        pub word_index_relative_to_line: usize,
        pub text_content_index_relative_to_line: usize,
        pub glyph_index_relative_to_line: usize,
        pub char_index_relative_to_line: usize,
        pub glyph_index_relative_to_word: usize,
        pub char_index_relative_to_word: usize,
    }

    /// Re-export of rust-allocated (stack based) `IFrameCallbackInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzIFrameCallbackInfo {
        pub system_fonts: *const c_void,
        pub image_cache: *const c_void,
        pub window_theme: AzWindowTheme,
        pub bounds: AzHidpiAdjustedBounds,
        pub scroll_size: AzLogicalSize,
        pub scroll_offset: AzLogicalPosition,
        pub virtual_scroll_size: AzLogicalSize,
        pub virtual_scroll_offset: AzLogicalPosition,
        pub _reserved_ref: *const c_void,
        pub _reserved_mut: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `TimerCallbackReturn` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTimerCallbackReturn {
        pub should_update: AzUpdate,
        pub should_terminate: AzTerminateTimer,
    }

    /// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny` can be up- and downcasted (this usually done via generics and can't be expressed in the Rust API)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRefAny {
        pub _internal_ptr: *const c_void,
        pub sharing_info: AzRefCount,
        pub instance_id: u64,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `IFrameNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzIFrameNode {
        pub callback: AzIFrameCallback,
        pub data: AzRefAny,
    }

    /// Re-export of rust-allocated (stack based) `NotEventFilter` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzNotEventFilter {
        Hover(AzHoverEventFilter),
        Focus(AzFocusEventFilter),
    }

    /// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMenuCallback {
        pub callback: AzCallback,
        pub data: AzRefAny,
    }

    /// Icon of a menu entry
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzMenuItemIcon {
        Checkbox(bool),
        Image(AzImageRef),
    }

    /// Re-export of rust-allocated (stack based) `CssNthChildSelector` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzCssNthChildSelector {
        Number(u32),
        Even,
        Odd,
        Pattern(AzCssNthChildPattern),
    }

    /// Re-export of rust-allocated (stack based) `PixelValue` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzPixelValue {
        pub metric: AzSizeMetric,
        pub number: AzFloatValue,
    }

    /// Re-export of rust-allocated (stack based) `PixelValueNoPercent` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzPixelValueNoPercent {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBoxShadow` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBoxShadow {
        pub offset: [AzPixelValueNoPercent;2],
        pub color: AzColorU,
        pub blur_radius: AzPixelValueNoPercent,
        pub spread_radius: AzPixelValueNoPercent,
        pub clip_mode: AzBoxShadowClipMode,
    }

    /// Re-export of rust-allocated (stack based) `StyleBlur` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBlur {
        pub width: AzPixelValue,
        pub height: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleColorMatrix` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleColorMatrix {
        pub matrix: [AzFloatValue;20],
    }

    /// Re-export of rust-allocated (stack based) `StyleFilterOffset` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleFilterOffset {
        pub x: AzPixelValue,
        pub y: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleCompositeFilter` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleCompositeFilter {
        Over,
        In,
        Atop,
        Out,
        Xor,
        Lighter,
        Arithmetic([AzFloatValue;4]),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBottom` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutBottom {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexGrow` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutFlexGrow {
        pub inner: AzFloatValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexShrink` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutFlexShrink {
        pub inner: AzFloatValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutHeight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutHeight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutLeft` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutLeft {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginBottom` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMarginBottom {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginLeft` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMarginLeft {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginRight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMarginRight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginTop` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMarginTop {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMaxHeight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMaxHeight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMaxWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMaxWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMinHeight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMinHeight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutMinWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutMinWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingBottom` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutPaddingBottom {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingLeft` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutPaddingLeft {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingRight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutPaddingRight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingTop` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutPaddingTop {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutRight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutRight {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutTop` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutTop {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `LayoutWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `PercentageValue` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzPercentageValue {
        pub number: AzFloatValue,
    }

    /// Re-export of rust-allocated (stack based) `AngleValue` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzAngleValue {
        pub metric: AzAngleMetric,
        pub number: AzFloatValue,
    }

    /// Re-export of rust-allocated (stack based) `NormalizedLinearColorStop` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNormalizedLinearColorStop {
        pub offset: AzPercentageValue,
        pub color: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `NormalizedRadialColorStop` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNormalizedRadialColorStop {
        pub offset: AzAngleValue,
        pub color: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `DirectionCorners` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzDirectionCorners {
        pub from: AzDirectionCorner,
        pub to: AzDirectionCorner,
    }

    /// Re-export of rust-allocated (stack based) `Direction` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzDirection {
        Angle(AzAngleValue),
        FromTo(AzDirectionCorners),
    }

    /// Re-export of rust-allocated (stack based) `BackgroundPositionHorizontal` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzBackgroundPositionHorizontal {
        Left,
        Center,
        Right,
        Exact(AzPixelValue),
    }

    /// Re-export of rust-allocated (stack based) `BackgroundPositionVertical` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzBackgroundPositionVertical {
        Top,
        Center,
        Bottom,
        Exact(AzPixelValue),
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundPosition` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzStyleBackgroundPosition {
        pub horizontal: AzBackgroundPositionHorizontal,
        pub vertical: AzBackgroundPositionVertical,
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundSize` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzStyleBackgroundSize {
        ExactSize([AzPixelValue;2]),
        Contain,
        Cover,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomColor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzStyleBorderBottomColor {
        pub inner: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadius` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzStyleBorderBottomLeftRadius {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadius` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzStyleBorderBottomRightRadius {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderBottomStyle {
        pub inner: AzBorderStyle,
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutBorderBottomWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderLeftColor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderLeftColor {
        pub inner: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderLeftStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderLeftStyle {
        pub inner: AzBorderStyle,
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutBorderLeftWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderRightColor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderRightColor {
        pub inner: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderRightStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderRightStyle {
        pub inner: AzBorderStyle,
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderRightWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutBorderRightWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopColor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderTopColor {
        pub inner: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadius` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderTopLeftRadius {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadius` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderTopRightRadius {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleBorderTopStyle {
        pub inner: AzBorderStyle,
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderTopWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzLayoutBorderTopWidth {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleFontSize` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleFontSize {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleLetterSpacing` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleLetterSpacing {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleLineHeight` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleLineHeight {
        pub inner: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTabWidth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTabWidth {
        pub inner: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleOpacity` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleOpacity {
        pub inner: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformOrigin` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformOrigin {
        pub x: AzPixelValue,
        pub y: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StylePerspectiveOrigin` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStylePerspectiveOrigin {
        pub x: AzPixelValue,
        pub y: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformMatrix2D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformMatrix2D {
        pub a: AzPixelValue,
        pub b: AzPixelValue,
        pub c: AzPixelValue,
        pub d: AzPixelValue,
        pub tx: AzPixelValue,
        pub ty: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformMatrix3D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformMatrix3D {
        pub m11: AzPixelValue,
        pub m12: AzPixelValue,
        pub m13: AzPixelValue,
        pub m14: AzPixelValue,
        pub m21: AzPixelValue,
        pub m22: AzPixelValue,
        pub m23: AzPixelValue,
        pub m24: AzPixelValue,
        pub m31: AzPixelValue,
        pub m32: AzPixelValue,
        pub m33: AzPixelValue,
        pub m34: AzPixelValue,
        pub m41: AzPixelValue,
        pub m42: AzPixelValue,
        pub m43: AzPixelValue,
        pub m44: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformTranslate2D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformTranslate2D {
        pub x: AzPixelValue,
        pub y: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformTranslate3D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformTranslate3D {
        pub x: AzPixelValue,
        pub y: AzPixelValue,
        pub z: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformRotate3D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformRotate3D {
        pub x: AzPercentageValue,
        pub y: AzPercentageValue,
        pub z: AzPercentageValue,
        pub angle: AzAngleValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformScale2D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformScale2D {
        pub x: AzPercentageValue,
        pub y: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformScale3D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformScale3D {
        pub x: AzPercentageValue,
        pub y: AzPercentageValue,
        pub z: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformSkew2D` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTransformSkew2D {
        pub x: AzPercentageValue,
        pub y: AzPercentageValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleTextColor` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleTextColor {
        pub inner: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `StyleWordSpacing` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzStyleWordSpacing {
        pub inner: AzPixelValue,
    }

    /// Re-export of rust-allocated (stack based) `StyleBoxShadowValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBoxShadowValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBoxShadow),
    }

    /// Re-export of rust-allocated (stack based) `LayoutAlignContentValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutAlignContentValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutAlignContent),
    }

    /// Re-export of rust-allocated (stack based) `LayoutAlignItemsValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutAlignItemsValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutAlignItems),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBottomValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBottomValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBottom),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBoxSizingValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBoxSizingValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBoxSizing),
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexDirectionValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexDirectionValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutFlexDirection),
    }

    /// Re-export of rust-allocated (stack based) `LayoutDisplayValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutDisplayValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutDisplay),
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexGrowValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexGrowValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutFlexGrow),
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexShrinkValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexShrinkValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutFlexShrink),
    }

    /// Re-export of rust-allocated (stack based) `LayoutFloatValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFloatValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutFloat),
    }

    /// Re-export of rust-allocated (stack based) `LayoutHeightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutHeightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutHeight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutJustifyContentValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutJustifyContentValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutJustifyContent),
    }

    /// Re-export of rust-allocated (stack based) `LayoutLeftValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutLeftValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutLeft),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginBottomValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMarginBottomValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMarginBottom),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginLeftValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMarginLeftValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMarginLeft),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginRightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMarginRightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMarginRight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMarginTopValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMarginTopValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMarginTop),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMaxHeightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMaxHeightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMaxHeight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMaxWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMaxWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMaxWidth),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMinHeightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMinHeightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMinHeight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutMinWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutMinWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutMinWidth),
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingBottomValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPaddingBottomValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutPaddingBottom),
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingLeftValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPaddingLeftValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutPaddingLeft),
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingRightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPaddingRightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutPaddingRight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutPaddingTopValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPaddingTopValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutPaddingTop),
    }

    /// Re-export of rust-allocated (stack based) `LayoutPositionValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutPositionValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutPosition),
    }

    /// Re-export of rust-allocated (stack based) `LayoutRightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutRightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutRight),
    }

    /// Re-export of rust-allocated (stack based) `LayoutTopValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutTopValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutTop),
    }

    /// Re-export of rust-allocated (stack based) `LayoutWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutWidth),
    }

    /// Re-export of rust-allocated (stack based) `LayoutFlexWrapValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutFlexWrapValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutFlexWrap),
    }

    /// Re-export of rust-allocated (stack based) `LayoutOverflowValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutOverflowValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutOverflow),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomColorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderBottomColorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderBottomColor),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomLeftRadiusValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderBottomLeftRadiusValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderBottomLeftRadius),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomRightRadiusValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderBottomRightRadiusValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderBottomRightRadius),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderBottomStyleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderBottomStyleValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderBottomStyle),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderBottomWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBorderBottomWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBorderBottomWidth),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderLeftColorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderLeftColorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderLeftColor),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderLeftStyleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderLeftStyleValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderLeftStyle),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderLeftWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBorderLeftWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBorderLeftWidth),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderRightColorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderRightColorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderRightColor),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderRightStyleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderRightStyleValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderRightStyle),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderRightWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBorderRightWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBorderRightWidth),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopColorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderTopColorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderTopColor),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopLeftRadiusValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderTopLeftRadiusValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderTopLeftRadius),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopRightRadiusValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderTopRightRadiusValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderTopRightRadius),
    }

    /// Re-export of rust-allocated (stack based) `StyleBorderTopStyleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBorderTopStyleValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBorderTopStyle),
    }

    /// Re-export of rust-allocated (stack based) `LayoutBorderTopWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzLayoutBorderTopWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzLayoutBorderTopWidth),
    }

    /// Re-export of rust-allocated (stack based) `StyleCursorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleCursorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleCursor),
    }

    /// Re-export of rust-allocated (stack based) `StyleFontSizeValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleFontSizeValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleFontSize),
    }

    /// Re-export of rust-allocated (stack based) `StyleLetterSpacingValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleLetterSpacingValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleLetterSpacing),
    }

    /// Re-export of rust-allocated (stack based) `StyleLineHeightValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleLineHeightValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleLineHeight),
    }

    /// Re-export of rust-allocated (stack based) `StyleTabWidthValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTabWidthValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleTabWidth),
    }

    /// Re-export of rust-allocated (stack based) `StyleTextAlignValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTextAlignValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleTextAlign),
    }

    /// Re-export of rust-allocated (stack based) `StyleTextColorValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTextColorValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleTextColor),
    }

    /// Re-export of rust-allocated (stack based) `StyleWordSpacingValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleWordSpacingValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleWordSpacing),
    }

    /// Re-export of rust-allocated (stack based) `StyleOpacityValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleOpacityValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleOpacity),
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformOriginValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTransformOriginValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleTransformOrigin),
    }

    /// Re-export of rust-allocated (stack based) `StylePerspectiveOriginValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStylePerspectiveOriginValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStylePerspectiveOrigin),
    }

    /// Re-export of rust-allocated (stack based) `StyleBackfaceVisibilityValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleBackfaceVisibilityValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBackfaceVisibility),
    }

    /// Re-export of rust-allocated (stack based) `StyleMixBlendModeValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleMixBlendModeValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleMixBlendMode),
    }

    /// Re-export of rust-allocated (stack based) `ButtonOnClick` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzButtonOnClick {
        pub data: AzRefAny,
        pub callback: AzCallback,
    }

    /// Re-export of rust-allocated (stack based) `FileInputOnPathChange` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileInputOnPathChange {
        pub data: AzRefAny,
        pub callback: AzFileInputOnPathChangeCallback,
    }

    /// Re-export of rust-allocated (stack based) `CheckBoxOnToggle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCheckBoxOnToggle {
        pub data: AzRefAny,
        pub callback: AzCheckBoxOnToggleCallback,
    }

    /// Re-export of rust-allocated (stack based) `ColorInputState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzColorInputState {
        pub color: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `ColorInputOnValueChange` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzColorInputOnValueChange {
        pub data: AzRefAny,
        pub callback: AzColorInputOnValueChangeCallback,
    }

    /// Re-export of rust-allocated (stack based) `TextInputSelection` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzTextInputSelection {
        All,
        FromTo(AzTextInputSelectionRange),
    }

    /// Re-export of rust-allocated (stack based) `TextInputOnTextInput` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputOnTextInput {
        pub data: AzRefAny,
        pub callback: AzTextInputOnTextInputCallback,
    }

    /// Re-export of rust-allocated (stack based) `TextInputOnVirtualKeyDown` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputOnVirtualKeyDown {
        pub data: AzRefAny,
        pub callback: AzTextInputOnVirtualKeyDownCallback,
    }

    /// Re-export of rust-allocated (stack based) `TextInputOnFocusLost` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputOnFocusLost {
        pub data: AzRefAny,
        pub callback: AzTextInputOnFocusLostCallback,
    }

    /// Re-export of rust-allocated (stack based) `OnTextInputReturn` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzOnTextInputReturn {
        pub update: AzUpdate,
        pub valid: AzTextInputValid,
    }

    /// Re-export of rust-allocated (stack based) `NumberInputOnValueChange` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNumberInputOnValueChange {
        pub data: AzRefAny,
        pub callback: AzNumberInputOnValueChangeCallback,
    }

    /// Re-export of rust-allocated (stack based) `NumberInputOnFocusLost` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNumberInputOnFocusLost {
        pub data: AzRefAny,
        pub callback: AzNumberInputOnFocusLostCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeAdded` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeAdded {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeAddedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeRemoved` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeRemoved {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeRemovedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeGraphDragged` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeGraphDragged {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeGraphDraggedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeDragged` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeDragged {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeDraggedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeConnected` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeConnected {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeConnectedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeInputDisconnected` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeInputDisconnected {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeInputDisconnectedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeOutputDisconnected` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeOutputDisconnected {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeOutputDisconnectedCallback,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphOnNodeFieldEdited` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphOnNodeFieldEdited {
        pub data: AzRefAny,
        pub callback: AzNodeGraphOnNodeFieldEditedCallback,
    }

    /// Re-export of rust-allocated (stack based) `OutputNodeAndIndex` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzOutputNodeAndIndex {
        pub node_id: AzNodeGraphNodeId,
        pub output_index: usize,
    }

    /// Re-export of rust-allocated (stack based) `InputNodeAndIndex` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInputNodeAndIndex {
        pub node_id: AzNodeGraphNodeId,
        pub input_index: usize,
    }

    /// Re-export of rust-allocated (stack based) `DropDownOnChoiceChange` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDropDownOnChoiceChange {
        pub data: AzRefAny,
        pub callback: AzDropDownOnChoiceChangeCallback,
    }

    /// Re-export of rust-allocated (stack based) `ParentWithNodeDepth` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzParentWithNodeDepth {
        pub depth: usize,
        pub node_id: AzNodeId,
    }

    /// Re-export of rust-allocated (stack based) `Gl` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGl {
        pub(crate) ptr: *const c_void,
        pub renderer_type: AzRendererType,
        pub run_destructor: bool,
    }

    /// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRefstrVecRef {
        pub(crate) ptr: *const AzRefstr,
        pub len: usize,
    }

    /// Re-export of rust-allocated (stack based) `ImageMask` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzImageMask {
        pub image: AzImageRef,
        pub rect: AzLogicalRect,
        pub repeat: bool,
    }

    /// Re-export of rust-allocated (stack based) `FontMetrics` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFontMetrics {
        pub units_per_em: u16,
        pub font_flags: u16,
        pub x_min: i16,
        pub y_min: i16,
        pub x_max: i16,
        pub y_max: i16,
        pub ascender: i16,
        pub descender: i16,
        pub line_gap: i16,
        pub advance_width_max: u16,
        pub min_left_side_bearing: i16,
        pub min_right_side_bearing: i16,
        pub x_max_extent: i16,
        pub caret_slope_rise: i16,
        pub caret_slope_run: i16,
        pub caret_offset: i16,
        pub num_h_metrics: u16,
        pub x_avg_char_width: i16,
        pub us_weight_class: u16,
        pub us_width_class: u16,
        pub fs_type: u16,
        pub y_subscript_x_size: i16,
        pub y_subscript_y_size: i16,
        pub y_subscript_x_offset: i16,
        pub y_subscript_y_offset: i16,
        pub y_superscript_x_size: i16,
        pub y_superscript_y_size: i16,
        pub y_superscript_x_offset: i16,
        pub y_superscript_y_offset: i16,
        pub y_strikeout_size: i16,
        pub y_strikeout_position: i16,
        pub s_family_class: i16,
        pub panose: [u8; 10],
        pub ul_unicode_range1: u32,
        pub ul_unicode_range2: u32,
        pub ul_unicode_range3: u32,
        pub ul_unicode_range4: u32,
        pub ach_vend_id: u32,
        pub fs_selection: u16,
        pub us_first_char_index: u16,
        pub us_last_char_index: u16,
        pub s_typo_ascender: AzOptionI16,
        pub s_typo_descender: AzOptionI16,
        pub s_typo_line_gap: AzOptionI16,
        pub us_win_ascent: AzOptionU16,
        pub us_win_descent: AzOptionU16,
        pub ul_code_page_range1: AzOptionU32,
        pub ul_code_page_range2: AzOptionU32,
        pub sx_height: AzOptionI16,
        pub s_cap_height: AzOptionI16,
        pub us_default_char: AzOptionU16,
        pub us_break_char: AzOptionU16,
        pub us_max_context: AzOptionU16,
        pub us_lower_optical_point_size: AzOptionU16,
        pub us_upper_optical_point_size: AzOptionU16,
    }

    /// Re-export of rust-allocated (stack based) `SvgLine` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgLine {
        pub start: AzSvgPoint,
        pub end: AzSvgPoint,
    }

    /// Re-export of rust-allocated (stack based) `SvgQuadraticCurve` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgQuadraticCurve {
        pub start: AzSvgPoint,
        pub ctrl: AzSvgPoint,
        pub end: AzSvgPoint,
    }

    /// Re-export of rust-allocated (stack based) `SvgCubicCurve` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgCubicCurve {
        pub start: AzSvgPoint,
        pub ctrl_1: AzSvgPoint,
        pub ctrl_2: AzSvgPoint,
        pub end: AzSvgPoint,
    }

    /// Re-export of rust-allocated (stack based) `SvgStringFormatOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgStringFormatOptions {
        pub use_single_quote: bool,
        pub indent: AzIndent,
        pub attributes_indent: AzIndent,
    }

    /// Re-export of rust-allocated (stack based) `SvgFillStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgFillStyle {
        pub line_join: AzSvgLineJoin,
        pub miter_limit: f32,
        pub tolerance: f32,
        pub fill_rule: AzSvgFillRule,
        pub transform: AzSvgTransform,
        pub anti_alias: bool,
        pub high_quality_aa: bool,
    }

    /// Re-export of rust-allocated (stack based) `InstantPtr` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInstantPtr {
        pub(crate) ptr: *const c_void,
        pub clone_fn: AzInstantPtrCloneFn,
        pub destructor: AzInstantPtrDestructorFn,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `Duration` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzDuration {
        System(AzSystemTimeDiff),
        Tick(AzSystemTickDiff),
    }

    /// Re-export of rust-allocated (stack based) `ThreadSendMsg` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzThreadSendMsg {
        TerminateThread,
        Tick,
        Custom(AzRefAny),
    }

    /// Re-export of rust-allocated (stack based) `ThreadWriteBackMsg` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzThreadWriteBackMsg {
        pub data: AzRefAny,
        pub callback: AzWriteBackCallback,
    }

    /// Wrapper over a Rust-allocated `Vec<LogicalRect>`
    #[repr(C)]
    pub struct AzLogicalRectVec {
        pub(crate) ptr: *const AzLogicalRect,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzLogicalRectVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
    #[repr(C)]
    pub struct AzInputOutputTypeIdVec {
        pub(crate) ptr: *const AzInputOutputTypeId,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInputOutputTypeIdVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
    #[repr(C)]
    pub struct AzOutputNodeAndIndexVec {
        pub(crate) ptr: *const AzOutputNodeAndIndex,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzOutputNodeAndIndexVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
    #[repr(C)]
    pub struct AzInputNodeAndIndexVec {
        pub(crate) ptr: *const AzInputNodeAndIndex,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInputNodeAndIndexVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
    #[repr(C)]
    pub struct AzAccessibilityStateVec {
        pub(crate) ptr: *const AzAccessibilityState,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzAccessibilityStateVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<MenuItem>`
    #[repr(C)]
    pub struct AzMenuItemVec {
        pub(crate) ptr: *const AzMenuItem,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzMenuItemVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<XmlNode>`
    #[repr(C)]
    pub struct AzXmlNodeVec {
        pub(crate) ptr: *const AzXmlNode,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzXmlNodeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
    #[repr(C)]
    pub struct AzInlineGlyphVec {
        pub(crate) ptr: *const AzInlineGlyph,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInlineGlyphVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
    #[repr(C)]
    pub struct AzInlineTextHitVec {
        pub(crate) ptr: *const AzInlineTextHit,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInlineTextHitVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<VideoMode>`
    #[repr(C)]
    pub struct AzVideoModeVec {
        pub(crate) ptr: *const AzVideoMode,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzVideoModeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<Dom>`
    #[repr(C)]
    pub struct AzDomVec {
        pub(crate) ptr: *const AzDom,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzDomVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
    #[repr(C)]
    pub struct AzStyleBackgroundPositionVec {
        pub(crate) ptr: *const AzStyleBackgroundPosition,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleBackgroundPositionVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
    #[repr(C)]
    pub struct AzStyleBackgroundRepeatVec {
        pub(crate) ptr: *const AzStyleBackgroundRepeat,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleBackgroundRepeatVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
    #[repr(C)]
    pub struct AzStyleBackgroundSizeVec {
        pub(crate) ptr: *const AzStyleBackgroundSize,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleBackgroundSizeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `SvgVertex`
    #[repr(C)]
    pub struct AzSvgVertexVec {
        pub(crate) ptr: *const AzSvgVertex,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzSvgVertexVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<u32>`
    #[repr(C)]
    pub struct AzU32Vec {
        pub(crate) ptr: *const u32,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzU32VecDestructor,
    }

    /// Wrapper over a Rust-allocated `XWindowType`
    #[repr(C)]
    pub struct AzXWindowTypeVec {
        pub(crate) ptr: *const AzXWindowType,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzXWindowTypeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `VirtualKeyCode`
    #[repr(C)]
    pub struct AzVirtualKeyCodeVec {
        pub(crate) ptr: *const AzVirtualKeyCode,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzVirtualKeyCodeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `CascadeInfo`
    #[repr(C)]
    pub struct AzCascadeInfoVec {
        pub(crate) ptr: *const AzCascadeInfo,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCascadeInfoVecDestructor,
    }

    /// Wrapper over a Rust-allocated `ScanCode`
    #[repr(C)]
    pub struct AzScanCodeVec {
        pub(crate) ptr: *const u32,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzScanCodeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<u16>`
    #[repr(C)]
    pub struct AzU16Vec {
        pub(crate) ptr: *const u16,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzU16VecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<f32>`
    #[repr(C)]
    pub struct AzF32Vec {
        pub(crate) ptr: *const f32,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzF32VecDestructor,
    }

    /// Wrapper over a Rust-allocated `U8Vec`
    #[repr(C)]
    pub struct AzU8Vec {
        pub(crate) ptr: *const u8,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzU8VecDestructor,
    }

    /// Wrapper over a Rust-allocated `U32Vec`
    #[repr(C)]
    pub struct AzGLuintVec {
        pub(crate) ptr: *const u32,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzGLuintVecDestructor,
    }

    /// Wrapper over a Rust-allocated `GLintVec`
    #[repr(C)]
    pub struct AzGLintVec {
        pub(crate) ptr: *const i32,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzGLintVecDestructor,
    }

    /// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
    #[repr(C)]
    pub struct AzNormalizedLinearColorStopVec {
        pub(crate) ptr: *const AzNormalizedLinearColorStop,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNormalizedLinearColorStopVecDestructor,
    }

    /// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
    #[repr(C)]
    pub struct AzNormalizedRadialColorStopVec {
        pub(crate) ptr: *const AzNormalizedRadialColorStop,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNormalizedRadialColorStopVecDestructor,
    }

    /// Wrapper over a Rust-allocated `NodeIdVec`
    #[repr(C)]
    pub struct AzNodeIdVec {
        pub(crate) ptr: *const AzNodeId,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeIdVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
    #[repr(C)]
    pub struct AzNodeHierarchyItemVec {
        pub(crate) ptr: *const AzNodeHierarchyItem,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeHierarchyItemVecDestructor,
    }

    /// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
    #[repr(C)]
    pub struct AzParentWithNodeDepthVec {
        pub(crate) ptr: *const AzParentWithNodeDepth,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzParentWithNodeDepthVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionDropDownOnChoiceChange` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionDropDownOnChoiceChange {
        None,
        Some(AzDropDownOnChoiceChange),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeAdded` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeAdded {
        None,
        Some(AzNodeGraphOnNodeAdded),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeRemoved` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeRemoved {
        None,
        Some(AzNodeGraphOnNodeRemoved),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeGraphDragged` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeGraphDragged {
        None,
        Some(AzNodeGraphOnNodeGraphDragged),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeDragged` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeDragged {
        None,
        Some(AzNodeGraphOnNodeDragged),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeConnected` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeConnected {
        None,
        Some(AzNodeGraphOnNodeConnected),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeInputDisconnected` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeInputDisconnected {
        None,
        Some(AzNodeGraphOnNodeInputDisconnected),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeOutputDisconnected` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeOutputDisconnected {
        None,
        Some(AzNodeGraphOnNodeOutputDisconnected),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeGraphOnNodeFieldEdited` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNodeGraphOnNodeFieldEdited {
        None,
        Some(AzNodeGraphOnNodeFieldEdited),
    }

    /// Re-export of rust-allocated (stack based) `OptionColorInputOnValueChange` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionColorInputOnValueChange {
        None,
        Some(AzColorInputOnValueChange),
    }

    /// Re-export of rust-allocated (stack based) `OptionButtonOnClick` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionButtonOnClick {
        None,
        Some(AzButtonOnClick),
    }

    /// Re-export of rust-allocated (stack based) `OptionFileInputOnPathChange` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionFileInputOnPathChange {
        None,
        Some(AzFileInputOnPathChange),
    }

    /// Re-export of rust-allocated (stack based) `OptionCheckBoxOnToggle` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionCheckBoxOnToggle {
        None,
        Some(AzCheckBoxOnToggle),
    }

    /// Re-export of rust-allocated (stack based) `OptionTextInputOnTextInput` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTextInputOnTextInput {
        None,
        Some(AzTextInputOnTextInput),
    }

    /// Re-export of rust-allocated (stack based) `OptionTextInputOnVirtualKeyDown` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTextInputOnVirtualKeyDown {
        None,
        Some(AzTextInputOnVirtualKeyDown),
    }

    /// Re-export of rust-allocated (stack based) `OptionTextInputOnFocusLost` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTextInputOnFocusLost {
        None,
        Some(AzTextInputOnFocusLost),
    }

    /// Re-export of rust-allocated (stack based) `OptionTextInputSelection` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTextInputSelection {
        None,
        Some(AzTextInputSelection),
    }

    /// Re-export of rust-allocated (stack based) `OptionNumberInputOnFocusLost` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNumberInputOnFocusLost {
        None,
        Some(AzNumberInputOnFocusLost),
    }

    /// Re-export of rust-allocated (stack based) `OptionNumberInputOnValueChange` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionNumberInputOnValueChange {
        None,
        Some(AzNumberInputOnValueChange),
    }

    /// Re-export of rust-allocated (stack based) `OptionMenuItemIcon` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionMenuItemIcon {
        None,
        Some(AzMenuItemIcon),
    }

    /// Re-export of rust-allocated (stack based) `OptionMenuCallback` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionMenuCallback {
        None,
        Some(AzMenuCallback),
    }

    /// Re-export of rust-allocated (stack based) `OptionPositionInfo` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionPositionInfo {
        None,
        Some(AzPositionInfo),
    }

    /// Re-export of rust-allocated (stack based) `OptionTimerId` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTimerId {
        None,
        Some(AzTimerId),
    }

    /// Re-export of rust-allocated (stack based) `OptionThreadId` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionThreadId {
        None,
        Some(AzThreadId),
    }

    /// Re-export of rust-allocated (stack based) `OptionImageRef` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionImageRef {
        None,
        Some(AzImageRef),
    }

    /// Re-export of rust-allocated (stack based) `OptionFontRef` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionFontRef {
        None,
        Some(AzFontRef),
    }

    /// Re-export of rust-allocated (stack based) `OptionSystemClipboard` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionSystemClipboard {
        None,
        Some(AzSystemClipboard),
    }

    /// Re-export of rust-allocated (stack based) `OptionGl` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionGl {
        None,
        Some(AzGl),
    }

    /// Re-export of rust-allocated (stack based) `OptionPercentageValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionPercentageValue {
        None,
        Some(AzPercentageValue),
    }

    /// Re-export of rust-allocated (stack based) `OptionAngleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionAngleValue {
        None,
        Some(AzAngleValue),
    }

    /// Re-export of rust-allocated (stack based) `OptionRendererOptions` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionRendererOptions {
        None,
        Some(AzRendererOptions),
    }

    /// Re-export of rust-allocated (stack based) `OptionCallback` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionCallback {
        None,
        Some(AzCallback),
    }

    /// Re-export of rust-allocated (stack based) `OptionThreadSendMsg` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionThreadSendMsg {
        None,
        Some(AzThreadSendMsg),
    }

    /// Re-export of rust-allocated (stack based) `OptionLayoutRect` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionLayoutRect {
        None,
        Some(AzLayoutRect),
    }

    /// Re-export of rust-allocated (stack based) `OptionRefAny` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionRefAny {
        None,
        Some(AzRefAny),
    }

    /// Re-export of rust-allocated (stack based) `OptionLayoutPoint` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionLayoutPoint {
        None,
        Some(AzLayoutPoint),
    }

    /// Re-export of rust-allocated (stack based) `OptionLayoutSize` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionLayoutSize {
        None,
        Some(AzLayoutSize),
    }

    /// Re-export of rust-allocated (stack based) `OptionWindowTheme` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionWindowTheme {
        None,
        Some(AzWindowTheme),
    }

    /// Re-export of rust-allocated (stack based) `OptionNodeId` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionNodeId {
        None,
        Some(AzNodeId),
    }

    /// Re-export of rust-allocated (stack based) `OptionDomNodeId` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionDomNodeId {
        None,
        Some(AzDomNodeId),
    }

    /// Re-export of rust-allocated (stack based) `OptionColorU` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionColorU {
        None,
        Some(AzColorU),
    }

    /// Re-export of rust-allocated (stack based) `OptionSvgDashPattern` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionSvgDashPattern {
        None,
        Some(AzSvgDashPattern),
    }

    /// Re-export of rust-allocated (stack based) `OptionLogicalPosition` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionLogicalPosition {
        None,
        Some(AzLogicalPosition),
    }

    /// Re-export of rust-allocated (stack based) `OptionPhysicalPositionI32` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionPhysicalPositionI32 {
        None,
        Some(AzPhysicalPositionI32),
    }

    /// Re-export of rust-allocated (stack based) `OptionMouseCursorType` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzOptionMouseCursorType {
        None,
        Some(AzMouseCursorType),
    }

    /// Re-export of rust-allocated (stack based) `OptionLogicalSize` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzOptionLogicalSize {
        None,
        Some(AzLogicalSize),
    }

    /// Re-export of rust-allocated (stack based) `OptionVirtualKeyCode` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionVirtualKeyCode {
        None,
        Some(AzVirtualKeyCode),
    }

    /// Re-export of rust-allocated (stack based) `OptionImageMask` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionImageMask {
        None,
        Some(AzImageMask),
    }

    /// Re-export of rust-allocated (stack based) `OptionTabIndex` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionTabIndex {
        None,
        Some(AzTabIndex),
    }

    /// Re-export of rust-allocated (stack based) `OptionTagId` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionTagId {
        None,
        Some(AzTagId),
    }

    /// Re-export of rust-allocated (stack based) `OptionDuration` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzOptionDuration {
        None,
        Some(AzDuration),
    }

    /// Re-export of rust-allocated (stack based) `OptionU8Vec` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionU8Vec {
        None,
        Some(AzU8Vec),
    }

    /// Re-export of rust-allocated (stack based) `OptionU8VecRef` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionU8VecRef {
        None,
        Some(AzU8VecRef),
    }

    /// Re-export of rust-allocated (stack based) `ResultU8VecEncodeImageError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzResultU8VecEncodeImageError {
        Ok(AzU8Vec),
        Err(AzEncodeImageError),
    }

    /// Re-export of rust-allocated (stack based) `NonXmlCharError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzNonXmlCharError {
        pub ch: u32,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `InvalidCharError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzInvalidCharError {
        pub expected: u8,
        pub got: u8,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `InvalidCharMultipleError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInvalidCharMultipleError {
        pub expected: u8,
        pub got: AzU8Vec,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `InvalidQuoteError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzInvalidQuoteError {
        pub got: u8,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `InvalidSpaceError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzInvalidSpaceError {
        pub got: u8,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Configuration for optional features, such as whether to enable logging or panic hooks
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzAppConfig {
        pub layout_solver: AzLayoutSolver,
        pub log_level: AzAppLogLevel,
        pub enable_visual_panic_hook: bool,
        pub enable_logging_on_panic: bool,
        pub enable_tab_navigation: bool,
        pub system_callbacks: AzSystemCallbacks,
    }

    /// Small (16x16x4) window icon, usually shown in the window titlebar
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSmallWindowIconBytes {
        pub key: AzIconKey,
        pub rgba_bytes: AzU8Vec,
    }

    /// Large (32x32x4) window icon, usually used on high-resolution displays (instead of `SmallWindowIcon`)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzLargeWindowIconBytes {
        pub key: AzIconKey,
        pub rgba_bytes: AzU8Vec,
    }

    /// Window "favicon", usually shown in the top left of the window on Windows
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzWindowIcon {
        Small(AzSmallWindowIconBytes),
        Large(AzLargeWindowIconBytes),
    }

    /// Application taskbar icon, 256x256x4 bytes in size
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTaskBarIcon {
        pub key: AzIconKey,
        pub rgba_bytes: AzU8Vec,
    }

    /// Minimum / maximum / current size of the window in logical dimensions
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzWindowSize {
        pub dimensions: AzLogicalSize,
        pub hidpi_factor: f32,
        pub system_hidpi_factor: f32,
        pub dpi: u32,
        pub min_dimensions: AzOptionLogicalSize,
        pub max_dimensions: AzOptionLogicalSize,
    }

    /// Current keyboard state, stores what keys / characters have been pressed
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzKeyboardState {
        pub current_char: AzOptionChar,
        pub current_virtual_keycode: AzOptionVirtualKeyCode,
        pub pressed_virtual_keycodes: AzVirtualKeyCodeVec,
        pub pressed_scancodes: AzScanCodeVec,
    }

    /// Current mouse / cursor state
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMouseState {
        pub mouse_cursor_type: AzOptionMouseCursorType,
        pub cursor_position: AzCursorPosition,
        pub is_cursor_locked: bool,
        pub left_down: bool,
        pub right_down: bool,
        pub middle_down: bool,
        pub scroll_x: AzOptionF32,
        pub scroll_y: AzOptionF32,
    }

    /// C-ABI stable wrapper over a `MarshaledLayoutCallback`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMarshaledLayoutCallback {
        pub marshal_data: AzRefAny,
        pub cb: AzMarshaledLayoutCallbackInner,
    }

    /// Re-export of rust-allocated (stack based) `InlineTextContents` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInlineTextContents {
        pub glyphs: AzInlineGlyphVec,
        pub bounds: AzLogicalRect,
    }

    /// Re-export of rust-allocated (stack based) `ResolvedTextLayoutOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzResolvedTextLayoutOptions {
        pub font_size_px: f32,
        pub line_height: AzOptionF32,
        pub letter_spacing: AzOptionF32,
        pub word_spacing: AzOptionF32,
        pub tab_width: AzOptionF32,
        pub max_horizontal_width: AzOptionF32,
        pub leading: AzOptionF32,
        pub holes: AzLogicalRectVec,
    }

    /// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzAnimationEasing {
        Ease,
        Linear,
        EaseIn,
        EaseOut,
        EaseInOut,
        CubicBezier(AzSvgCubicCurve),
    }

    /// Re-export of rust-allocated (stack based) `RenderImageCallbackInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRenderImageCallbackInfo {
        pub callback_node_id: AzDomNodeId,
        pub bounds: AzHidpiAdjustedBounds,
        pub gl_context: *const AzOptionGl,
        pub image_cache: *const c_void,
        pub system_fonts: *const c_void,
        pub node_hierarchy: *const AzNodeHierarchyItemVec,
        pub words_cache: *const c_void,
        pub shaped_words_cache: *const c_void,
        pub positioned_words_cache: *const c_void,
        pub positioned_rects: *const c_void,
        pub _reserved_ref: *const c_void,
        pub _reserved_mut: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `LayoutCallbackInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzLayoutCallbackInfo {
        pub window_size: AzWindowSize,
        pub theme: AzWindowTheme,
        pub image_cache: *const c_void,
        pub gl_context: *const AzOptionGl,
        pub system_fonts: *const c_void,
        pub _reserved_ref: *const c_void,
        pub _reserved_mut: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `EventFilter` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzEventFilter {
        Hover(AzHoverEventFilter),
        Not(AzNotEventFilter),
        Focus(AzFocusEventFilter),
        Window(AzWindowEventFilter),
        Component(AzComponentEventFilter),
        Application(AzApplicationEventFilter),
    }

    /// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the Windows API
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMenu {
        pub items: AzMenuItemVec,
        pub position: AzMenuPopupPosition,
        pub context_mouse_btn: AzContextMenuMouseButton,
    }

    /// Combination of virtual key codes that have to be pressed together
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzVirtualKeyCodeCombo {
        pub keys: AzVirtualKeyCodeVec,
    }

    /// Re-export of rust-allocated (stack based) `CssPathPseudoSelector` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzCssPathPseudoSelector {
        First,
        Last,
        NthChild(AzCssNthChildSelector),
        Hover,
        Active,
        Focus,
    }

    /// Re-export of rust-allocated (stack based) `AnimationInterpolationFunction` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzAnimationInterpolationFunction {
        Ease,
        Linear,
        EaseIn,
        EaseOut,
        EaseInOut,
        CubicBezier(AzSvgCubicCurve),
    }

    /// Re-export of rust-allocated (stack based) `InterpolateContext` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzInterpolateContext {
        pub animation_func: AzAnimationInterpolationFunction,
        pub parent_rect_width: f32,
        pub parent_rect_height: f32,
        pub current_rect_width: f32,
        pub current_rect_height: f32,
    }

    /// Re-export of rust-allocated (stack based) `StyleFilter` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleFilter {
        Blend(AzStyleMixBlendMode),
        Flood(AzColorU),
        Blur(AzStyleBlur),
        Opacity(AzPercentageValue),
        ColorMatrix(AzStyleColorMatrix),
        DropShadow(AzStyleBoxShadow),
        ComponentTransfer,
        Offset(AzStyleFilterOffset),
        Composite(AzStyleCompositeFilter),
    }

    /// Re-export of rust-allocated (stack based) `LinearGradient` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzLinearGradient {
        pub direction: AzDirection,
        pub extend_mode: AzExtendMode,
        pub stops: AzNormalizedLinearColorStopVec,
    }

    /// Re-export of rust-allocated (stack based) `RadialGradient` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRadialGradient {
        pub shape: AzShape,
        pub size: AzRadialGradientSize,
        pub position: AzStyleBackgroundPosition,
        pub extend_mode: AzExtendMode,
        pub stops: AzNormalizedLinearColorStopVec,
    }

    /// Re-export of rust-allocated (stack based) `ConicGradient` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzConicGradient {
        pub extend_mode: AzExtendMode,
        pub center: AzStyleBackgroundPosition,
        pub angle: AzAngleValue,
        pub stops: AzNormalizedRadialColorStopVec,
    }

    /// Re-export of rust-allocated (stack based) `StyleTransform` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzStyleTransform {
        Matrix(AzStyleTransformMatrix2D),
        Matrix3D(AzStyleTransformMatrix3D),
        Translate(AzStyleTransformTranslate2D),
        Translate3D(AzStyleTransformTranslate3D),
        TranslateX(AzPixelValue),
        TranslateY(AzPixelValue),
        TranslateZ(AzPixelValue),
        Rotate(AzAngleValue),
        Rotate3D(AzStyleTransformRotate3D),
        RotateX(AzAngleValue),
        RotateY(AzAngleValue),
        RotateZ(AzAngleValue),
        Scale(AzStyleTransformScale2D),
        Scale3D(AzStyleTransformScale3D),
        ScaleX(AzPercentageValue),
        ScaleY(AzPercentageValue),
        ScaleZ(AzPercentageValue),
        Skew(AzStyleTransformSkew2D),
        SkewX(AzPercentageValue),
        SkewY(AzPercentageValue),
        Perspective(AzPixelValue),
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundPositionVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleBackgroundPositionVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBackgroundPositionVec),
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundRepeatVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleBackgroundRepeatVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBackgroundRepeatVec),
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundSizeVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleBackgroundSizeVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBackgroundSizeVec),
    }

    /// Re-export of rust-allocated (stack based) `CheckBoxStateWrapper` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCheckBoxStateWrapper {
        pub inner: AzCheckBoxState,
        pub on_toggle: AzOptionCheckBoxOnToggle,
    }

    /// Re-export of rust-allocated (stack based) `NumberInputStateWrapper` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNumberInputStateWrapper {
        pub inner: AzNumberInputState,
        pub on_value_change: AzOptionNumberInputOnValueChange,
        pub on_focus_lost: AzOptionNumberInputOnFocusLost,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraphCallbacks` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraphCallbacks {
        pub on_node_added: AzOptionNodeGraphOnNodeAdded,
        pub on_node_removed: AzOptionNodeGraphOnNodeRemoved,
        pub on_node_dragged: AzOptionNodeGraphOnNodeDragged,
        pub on_node_graph_dragged: AzOptionNodeGraphOnNodeGraphDragged,
        pub on_node_connected: AzOptionNodeGraphOnNodeConnected,
        pub on_node_input_disconnected: AzOptionNodeGraphOnNodeInputDisconnected,
        pub on_node_output_disconnected: AzOptionNodeGraphOnNodeOutputDisconnected,
        pub on_node_field_edited: AzOptionNodeGraphOnNodeFieldEdited,
    }

    /// Re-export of rust-allocated (stack based) `InputConnection` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInputConnection {
        pub input_index: usize,
        pub connects_to: AzOutputNodeAndIndexVec,
    }

    /// Re-export of rust-allocated (stack based) `OutputConnection` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzOutputConnection {
        pub output_index: usize,
        pub connects_to: AzInputNodeAndIndexVec,
    }

    /// Re-export of rust-allocated (stack based) `StyledNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzStyledNode {
        pub state: AzStyledNodeState,
        pub tag_id: AzOptionTagId,
    }

    /// Re-export of rust-allocated (stack based) `TagIdToNodeIdMapping` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTagIdToNodeIdMapping {
        pub tag_id: AzTagId,
        pub node_id: AzNodeId,
        pub tab_index: AzOptionTabIndex,
        pub parents: AzNodeIdVec,
    }

    /// Re-export of rust-allocated (stack based) `Texture` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTexture {
        pub texture_id: u32,
        pub flags: AzTextureFlags,
        pub size: AzPhysicalSizeU32,
        pub background_color: AzColorU,
        pub gl_context: AzGl,
        pub format: AzRawImageFormat,
        pub refcount: *const c_void,
        pub run_destructor: bool,
    }

    /// C-ABI stable reexport of `(U8Vec, u32)`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGetProgramBinaryReturn {
        pub _0: AzU8Vec,
        pub _1: u32,
    }

    /// Re-export of rust-allocated (stack based) `RawImageData` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzRawImageData {
        U8(AzU8Vec),
        U16(AzU16Vec),
        F32(AzF32Vec),
    }

    /// Source data of a font file (bytes)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFontSource {
        pub data: AzU8Vec,
        pub font_index: u32,
        pub parse_glyph_outlines: bool,
    }

    /// Re-export of rust-allocated (stack based) `SvgPathElement` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzSvgPathElement {
        Line(AzSvgLine),
        QuadraticCurve(AzSvgQuadraticCurve),
        CubicCurve(AzSvgCubicCurve),
    }

    /// Re-export of rust-allocated (stack based) `TessellatedSvgNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTessellatedSvgNode {
        pub vertices: AzSvgVertexVec,
        pub indices: AzU32Vec,
    }

    /// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTessellatedSvgNodeVecRef {
        pub(crate) ptr: *const AzTessellatedSvgNode,
        pub len: usize,
    }

    /// Re-export of rust-allocated (stack based) `SvgRenderOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgRenderOptions {
        pub target_size: AzOptionLayoutSize,
        pub background_color: AzOptionColorU,
        pub fit: AzSvgFitTo,
    }

    /// Re-export of rust-allocated (stack based) `SvgStrokeStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub struct AzSvgStrokeStyle {
        pub start_cap: AzSvgLineCap,
        pub end_cap: AzSvgLineCap,
        pub line_join: AzSvgLineJoin,
        pub dash_pattern: AzOptionSvgDashPattern,
        pub line_width: f32,
        pub miter_limit: f32,
        pub tolerance: f32,
        pub apply_line_width: bool,
        pub transform: AzSvgTransform,
        pub anti_alias: bool,
        pub high_quality_aa: bool,
    }

    /// Re-export of rust-allocated (stack based) `Xml` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzXml {
        pub root: AzXmlNodeVec,
    }

    /// Re-export of rust-allocated (stack based) `Instant` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzInstant {
        System(AzInstantPtr),
        Tick(AzSystemTick),
    }

    /// Re-export of rust-allocated (stack based) `ThreadReceiveMsg` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzThreadReceiveMsg {
        WriteBack(AzThreadWriteBackMsg),
        Update(AzUpdate),
    }

    /// Re-export of rust-allocated (stack based) `String` struct
    #[repr(C)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzString {
        pub vec: AzU8Vec,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleFilter>`
    #[repr(C)]
    pub struct AzStyleFilterVec {
        pub(crate) ptr: *const AzStyleFilter,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleFilterVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InputConnection>`
    #[repr(C)]
    pub struct AzInputConnectionVec {
        pub(crate) ptr: *const AzInputConnection,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInputConnectionVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<OutputConnection>`
    #[repr(C)]
    pub struct AzOutputConnectionVec {
        pub(crate) ptr: *const AzOutputConnection,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzOutputConnectionVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
    #[repr(C)]
    pub struct AzTessellatedSvgNodeVec {
        pub(crate) ptr: *const AzTessellatedSvgNode,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzTessellatedSvgNodeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleTransform>`
    #[repr(C)]
    pub struct AzStyleTransformVec {
        pub(crate) ptr: *const AzStyleTransform,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleTransformVecDestructor,
    }

    /// Wrapper over a Rust-allocated `VertexAttribute`
    #[repr(C)]
    pub struct AzSvgPathElementVec {
        pub(crate) ptr: *const AzSvgPathElement,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzSvgPathElementVecDestructor,
    }

    /// Wrapper over a Rust-allocated `StringVec`
    #[repr(C)]
    pub struct AzStringVec {
        pub(crate) ptr: *const AzString,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStringVecDestructor,
    }

    /// Wrapper over a Rust-allocated `StyledNodeVec`
    #[repr(C)]
    pub struct AzStyledNodeVec {
        pub(crate) ptr: *const AzStyledNode,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyledNodeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
    #[repr(C)]
    pub struct AzTagIdToNodeIdMappingVec {
        pub(crate) ptr: *const AzTagIdToNodeIdMapping,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzTagIdToNodeIdMappingVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionResolvedTextLayoutOptions` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionResolvedTextLayoutOptions {
        None,
        Some(AzResolvedTextLayoutOptions),
    }

    /// Re-export of rust-allocated (stack based) `OptionVirtualKeyCodeCombo` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionVirtualKeyCodeCombo {
        None,
        Some(AzVirtualKeyCodeCombo),
    }

    /// Re-export of rust-allocated (stack based) `OptionMouseState` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionMouseState {
        None,
        Some(AzMouseState),
    }

    /// Re-export of rust-allocated (stack based) `OptionKeyboardState` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionKeyboardState {
        None,
        Some(AzKeyboardState),
    }

    /// Re-export of rust-allocated (stack based) `OptionStringVec` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionStringVec {
        None,
        Some(AzStringVec),
    }

    /// Re-export of rust-allocated (stack based) `OptionThreadReceiveMsg` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionThreadReceiveMsg {
        None,
        Some(AzThreadReceiveMsg),
    }

    /// Re-export of rust-allocated (stack based) `OptionTaskBarIcon` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTaskBarIcon {
        None,
        Some(AzTaskBarIcon),
    }

    /// Re-export of rust-allocated (stack based) `OptionWindowIcon` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionWindowIcon {
        None,
        Some(AzWindowIcon),
    }

    /// Re-export of rust-allocated (stack based) `OptionString` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzOptionString {
        None,
        Some(AzString),
    }

    /// Re-export of rust-allocated (stack based) `OptionTexture` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionTexture {
        None,
        Some(AzTexture),
    }

    /// Re-export of rust-allocated (stack based) `OptionInstant` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionInstant {
        None,
        Some(AzInstant),
    }

    /// Re-export of rust-allocated (stack based) `DuplicatedNamespaceError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDuplicatedNamespaceError {
        pub ns: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `UnknownNamespaceError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzUnknownNamespaceError {
        pub ns: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `UnexpectedCloseTagError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzUnexpectedCloseTagError {
        pub expected: AzString,
        pub actual: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `UnknownEntityReferenceError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzUnknownEntityReferenceError {
        pub entity: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `DuplicatedAttributeError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDuplicatedAttributeError {
        pub attribute: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Re-export of rust-allocated (stack based) `InvalidStringError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInvalidStringError {
        pub got: AzString,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Window configuration specific to Win32
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzWindowsWindowOptions {
        pub allow_drag_drop: bool,
        pub no_redirection_bitmap: bool,
        pub window_icon: AzOptionWindowIcon,
        pub taskbar_icon: AzOptionTaskBarIcon,
        pub parent_window: AzOptionHwndHandle,
    }

    /// CSD theme of the window title / button controls
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzWaylandTheme {
        pub title_bar_active_background_color: [u8;4],
        pub title_bar_active_separator_color: [u8;4],
        pub title_bar_active_text_color: [u8;4],
        pub title_bar_inactive_background_color: [u8;4],
        pub title_bar_inactive_separator_color: [u8;4],
        pub title_bar_inactive_text_color: [u8;4],
        pub maximize_idle_foreground_inactive_color: [u8;4],
        pub minimize_idle_foreground_inactive_color: [u8;4],
        pub close_idle_foreground_inactive_color: [u8;4],
        pub maximize_hovered_foreground_inactive_color: [u8;4],
        pub minimize_hovered_foreground_inactive_color: [u8;4],
        pub close_hovered_foreground_inactive_color: [u8;4],
        pub maximize_disabled_foreground_inactive_color: [u8;4],
        pub minimize_disabled_foreground_inactive_color: [u8;4],
        pub close_disabled_foreground_inactive_color: [u8;4],
        pub maximize_idle_background_inactive_color: [u8;4],
        pub minimize_idle_background_inactive_color: [u8;4],
        pub close_idle_background_inactive_color: [u8;4],
        pub maximize_hovered_background_inactive_color: [u8;4],
        pub minimize_hovered_background_inactive_color: [u8;4],
        pub close_hovered_background_inactive_color: [u8;4],
        pub maximize_disabled_background_inactive_color: [u8;4],
        pub minimize_disabled_background_inactive_color: [u8;4],
        pub close_disabled_background_inactive_color: [u8;4],
        pub maximize_idle_foreground_active_color: [u8;4],
        pub minimize_idle_foreground_active_color: [u8;4],
        pub close_idle_foreground_active_color: [u8;4],
        pub maximize_hovered_foreground_active_color: [u8;4],
        pub minimize_hovered_foreground_active_color: [u8;4],
        pub close_hovered_foreground_active_color: [u8;4],
        pub maximize_disabled_foreground_active_color: [u8;4],
        pub minimize_disabled_foreground_active_color: [u8;4],
        pub close_disabled_foreground_active_color: [u8;4],
        pub maximize_idle_background_active_color: [u8;4],
        pub minimize_idle_background_active_color: [u8;4],
        pub close_idle_background_active_color: [u8;4],
        pub maximize_hovered_background_active_color: [u8;4],
        pub minimize_hovered_background_active_color: [u8;4],
        pub close_hovered_background_active_color: [u8;4],
        pub maximize_disabled_background_active_color: [u8;4],
        pub minimize_disabled_background_active_color: [u8;4],
        pub close_disabled_background_active_color: [u8;4],
        pub title_bar_font: AzString,
        pub title_bar_font_size: f32,
    }

    /// Key-value pair, used for setting WM hints values specific to GNOME
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzStringPair {
        pub key: AzString,
        pub value: AzString,
    }

    /// Information about a single (or many) monitors, useful for dock widgets
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzMonitor {
        pub id: usize,
        pub name: AzOptionString,
        pub size: AzLayoutSize,
        pub position: AzLayoutPoint,
        pub scale_factor: f64,
        pub video_modes: AzVideoModeVec,
        pub is_primary_monitor: bool,
    }

    /// Re-export of rust-allocated (stack based) `LayoutCallback` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzLayoutCallback {
        Raw(AzLayoutCallbackInner),
        Marshaled(AzMarshaledLayoutCallback),
    }

    /// Re-export of rust-allocated (stack based) `InlineWord` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzInlineWord {
        Tab,
        Return,
        Space,
        Word(AzInlineTextContents),
    }

    /// Re-export of rust-allocated (stack based) `CallbackData` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCallbackData {
        pub event: AzEventFilter,
        pub callback: AzCallback,
        pub data: AzRefAny,
    }

    /// List of core DOM node types built-into by `azul`
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzNodeType {
        Body,
        Div,
        Br,
        Text(AzString),
        Image(AzImageRef),
        IFrame(AzIFrameNode),
    }

    /// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzAccessibilityInfo {
        pub name: AzOptionString,
        pub value: AzOptionString,
        pub role: AzAccessibilityRole,
        pub states: AzAccessibilityStateVec,
        pub accelerator: AzOptionVirtualKeyCodeCombo,
        pub default_action: AzOptionString,
    }

    /// Re-export of rust-allocated (stack based) `IdOrClass` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzIdOrClass {
        Id(AzString),
        Class(AzString),
    }

    /// Regular labeled menu item
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzStringMenuItem {
        pub label: AzString,
        pub accelerator: AzOptionVirtualKeyCodeCombo,
        pub callback: AzOptionMenuCallback,
        pub state: AzMenuItemState,
        pub icon: AzOptionMenuItemIcon,
        pub children: AzMenuItemVec,
    }

    /// Re-export of rust-allocated (stack based) `CssPathSelector` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzCssPathSelector {
        Global,
        Type(AzNodeTypeKey),
        Class(AzString),
        Id(AzString),
        PseudoSelector(AzCssPathPseudoSelector),
        DirectChildren,
        Children,
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundContent` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleBackgroundContent {
        LinearGradient(AzLinearGradient),
        RadialGradient(AzRadialGradient),
        ConicGradient(AzConicGradient),
        Image(AzString),
        Color(AzColorU),
    }

    /// Re-export of rust-allocated (stack based) `ScrollbarInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzScrollbarInfo {
        pub width: AzLayoutWidth,
        pub padding_left: AzLayoutPaddingLeft,
        pub padding_right: AzLayoutPaddingRight,
        pub track: AzStyleBackgroundContent,
        pub thumb: AzStyleBackgroundContent,
        pub button: AzStyleBackgroundContent,
        pub corner: AzStyleBackgroundContent,
        pub resizer: AzStyleBackgroundContent,
    }

    /// Re-export of rust-allocated (stack based) `ScrollbarStyle` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzScrollbarStyle {
        pub horizontal: AzScrollbarInfo,
        pub vertical: AzScrollbarInfo,
    }

    /// Re-export of rust-allocated (stack based) `StyleFontFamily` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleFontFamily {
        System(AzString),
        File(AzString),
        Ref(AzFontRef),
    }

    /// Re-export of rust-allocated (stack based) `ScrollbarStyleValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzScrollbarStyleValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzScrollbarStyle),
    }

    /// Re-export of rust-allocated (stack based) `StyleTransformVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleTransformVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleTransformVec),
    }

    /// Re-export of rust-allocated (stack based) `StyleFilterVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleFilterVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleFilterVec),
    }

    /// Re-export of rust-allocated (stack based) `FileInputState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileInputState {
        pub path: AzOptionString,
    }

    /// Re-export of rust-allocated (stack based) `ColorInputStateWrapper` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzColorInputStateWrapper {
        pub inner: AzColorInputState,
        pub title: AzString,
        pub on_value_change: AzOptionColorInputOnValueChange,
    }

    /// Re-export of rust-allocated (stack based) `TextInputState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputState {
        pub text: AzU32Vec,
        pub placeholder: AzOptionString,
        pub max_len: usize,
        pub selection: AzOptionTextInputSelection,
        pub cursor_pos: usize,
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeFieldValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub enum AzNodeTypeFieldValue {
        TextInput(AzString),
        NumberInput(f32),
        CheckBox(bool),
        ColorInput(AzColorU),
        FileInput(AzOptionString),
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNodeTypeInfo {
        pub is_root: bool,
        pub name: AzString,
        pub inputs: AzInputOutputTypeIdVec,
        pub outputs: AzInputOutputTypeIdVec,
    }

    /// Re-export of rust-allocated (stack based) `InputOutputInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzInputOutputInfo {
        pub data_type: AzString,
        pub color: AzColorU,
    }

    /// Re-export of rust-allocated (stack based) `ListView` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzListView {
        pub columns: AzStringVec,
    }

    /// Re-export of rust-allocated (stack based) `TreeView` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTreeView {
        pub root: AzString,
    }

    /// Re-export of rust-allocated (stack based) `DropDown` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDropDown {
        pub choices: AzStringVec,
        pub selected: usize,
        pub on_choice_change: AzOptionDropDownOnChoiceChange,
    }

    /// Re-export of rust-allocated (stack based) `VertexAttribute` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzVertexAttribute {
        pub name: AzString,
        pub layout_location: AzOptionUsize,
        pub attribute_type: AzVertexAttributeType,
        pub item_count: usize,
    }

    /// Re-export of rust-allocated (stack based) `DebugMessage` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDebugMessage {
        pub message: AzString,
        pub source: u32,
        pub ty: u32,
        pub id: u32,
        pub severity: u32,
    }

    /// C-ABI stable reexport of `(i32, u32, AzString)`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGetActiveAttribReturn {
        pub _0: i32,
        pub _1: u32,
        pub _2: AzString,
    }

    /// C-ABI stable reexport of `(i32, u32, AzString)`
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzGetActiveUniformReturn {
        pub _0: i32,
        pub _1: u32,
        pub _2: AzString,
    }

    /// Re-export of rust-allocated (stack based) `RawImage` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzRawImage {
        pub pixels: AzRawImageData,
        pub width: usize,
        pub height: usize,
        pub alpha_premultiplied: bool,
        pub data_format: AzRawImageFormat,
    }

    /// Re-export of rust-allocated (stack based) `SvgPath` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzSvgPath {
        pub items: AzSvgPathElementVec,
    }

    /// Re-export of rust-allocated (stack based) `SvgParseOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgParseOptions {
        pub relative_image_path: AzOptionString,
        pub dpi: f32,
        pub default_font_family: AzString,
        pub font_size: f32,
        pub languages: AzStringVec,
        pub shape_rendering: AzShapeRendering,
        pub text_rendering: AzTextRendering,
        pub image_rendering: AzImageRendering,
        pub keep_named_groups: bool,
        pub fontdb: AzFontDatabase,
    }

    /// Re-export of rust-allocated (stack based) `SvgStyle` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[derive(Copy)]
    pub enum AzSvgStyle {
        Fill(AzSvgFillStyle),
        Stroke(AzSvgStrokeStyle),
    }

    /// **Reference-counted** file handle
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFile {
        pub(crate) ptr: *const c_void,
        pub path: AzString,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `FileTypeList` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileTypeList {
        pub document_types: AzStringVec,
        pub document_descriptor: AzString,
    }

    /// Re-export of rust-allocated (stack based) `Timer` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTimer {
        pub data: AzRefAny,
        pub node_id: AzOptionDomNodeId,
        pub created: AzInstant,
        pub last_run: AzOptionInstant,
        pub run_count: usize,
        pub delay: AzOptionDuration,
        pub interval: AzOptionDuration,
        pub timeout: AzOptionDuration,
        pub callback: AzTimerCallback,
    }

    /// Re-export of rust-allocated (stack based) `FmtValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzFmtValue {
        Bool(bool),
        Uchar(u8),
        Schar(i8),
        Ushort(u16),
        Sshort(i16),
        Uint(u32),
        Sint(i32),
        Ulong(u64),
        Slong(i64),
        Isize(isize),
        Usize(usize),
        Float(f32),
        Double(f64),
        Str(AzString),
        StrVec(AzStringVec),
    }

    /// Re-export of rust-allocated (stack based) `FmtArg` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFmtArg {
        pub key: AzString,
        pub value: AzFmtValue,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
    #[repr(C)]
    pub struct AzStyleFontFamilyVec {
        pub(crate) ptr: *const AzStyleFontFamily,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleFontFamilyVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<FmtArg>`
    #[repr(C)]
    pub struct AzFmtArgVec {
        pub(crate) ptr: *const AzFmtArg,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzFmtArgVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InlineWord>`
    #[repr(C)]
    pub struct AzInlineWordVec {
        pub(crate) ptr: *const AzInlineWord,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInlineWordVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<Monitor>`
    #[repr(C)]
    pub struct AzMonitorVec {
        pub(crate) ptr: *const AzMonitor,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzMonitorVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<IdOrClass>`
    #[repr(C)]
    pub struct AzIdOrClassVec {
        pub(crate) ptr: *const AzIdOrClass,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzIdOrClassVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
    #[repr(C)]
    pub struct AzStyleBackgroundContentVec {
        pub(crate) ptr: *const AzStyleBackgroundContent,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStyleBackgroundContentVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<SvgPath>`
    #[repr(C)]
    pub struct AzSvgPathVec {
        pub(crate) ptr: *const AzSvgPath,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzSvgPathVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
    #[repr(C)]
    pub struct AzVertexAttributeVec {
        pub(crate) ptr: *const AzVertexAttribute,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzVertexAttributeVecDestructor,
    }

    /// Wrapper over a Rust-allocated `CssPathSelector`
    #[repr(C)]
    pub struct AzCssPathSelectorVec {
        pub(crate) ptr: *const AzCssPathSelector,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCssPathSelectorVecDestructor,
    }

    /// Wrapper over a Rust-allocated `CallbackData`
    #[repr(C)]
    pub struct AzCallbackDataVec {
        pub(crate) ptr: *const AzCallbackData,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCallbackDataVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<DebugMessage>`
    #[repr(C)]
    pub struct AzDebugMessageVec {
        pub(crate) ptr: *const AzDebugMessage,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzDebugMessageVecDestructor,
    }

    /// Wrapper over a Rust-allocated `StringPairVec`
    #[repr(C)]
    pub struct AzStringPairVec {
        pub(crate) ptr: *const AzStringPair,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStringPairVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionFileTypeList` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionFileTypeList {
        None,
        Some(AzFileTypeList),
    }

    /// Re-export of rust-allocated (stack based) `OptionFile` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionFile {
        None,
        Some(AzFile),
    }

    /// Re-export of rust-allocated (stack based) `OptionRawImage` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionRawImage {
        None,
        Some(AzRawImage),
    }

    /// Re-export of rust-allocated (stack based) `OptionWaylandTheme` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionWaylandTheme {
        None,
        Some(AzWaylandTheme),
    }

    /// Re-export of rust-allocated (stack based) `ResultRawImageDecodeImageError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzResultRawImageDecodeImageError {
        Ok(AzRawImage),
        Err(AzDecodeImageError),
    }

    /// Re-export of rust-allocated (stack based) `XmlStreamError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzXmlStreamError {
        UnexpectedEndOfStream,
        InvalidName,
        NonXmlChar(AzNonXmlCharError),
        InvalidChar(AzInvalidCharError),
        InvalidCharMultiple(AzInvalidCharMultipleError),
        InvalidQuote(AzInvalidQuoteError),
        InvalidSpace(AzInvalidSpaceError),
        InvalidString(AzInvalidStringError),
        InvalidReference,
        InvalidExternalID,
        InvalidCommentData,
        InvalidCommentEnd,
        InvalidCharacterData,
    }

    /// Re-export of rust-allocated (stack based) `LinuxWindowOptions` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzLinuxWindowOptions {
        pub x11_visual: AzOptionX11Visual,
        pub x11_screen: AzOptionI32,
        pub x11_wm_classes: AzStringPairVec,
        pub x11_override_redirect: bool,
        pub x11_window_types: AzXWindowTypeVec,
        pub x11_gtk_theme_variant: AzOptionString,
        pub x11_resize_increments: AzOptionLogicalSize,
        pub x11_base_size: AzOptionLogicalSize,
        pub wayland_app_id: AzOptionString,
        pub wayland_theme: AzOptionWaylandTheme,
        pub request_user_attention: bool,
        pub window_icon: AzOptionWindowIcon,
    }

    /// Re-export of rust-allocated (stack based) `InlineLine` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInlineLine {
        pub words: AzInlineWordVec,
        pub bounds: AzLogicalRect,
    }

    /// Item entry in a menu or menu bar
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzMenuItem {
        String(AzStringMenuItem),
        Separator,
        BreakLine,
    }

    /// Re-export of rust-allocated (stack based) `CssPath` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCssPath {
        pub selectors: AzCssPathSelectorVec,
    }

    /// Re-export of rust-allocated (stack based) `StyleBackgroundContentVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleBackgroundContentVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleBackgroundContentVec),
    }

    /// Re-export of rust-allocated (stack based) `StyleFontFamilyVecValue` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzStyleFontFamilyVecValue {
        Auto,
        None,
        Inherit,
        Initial,
        Exact(AzStyleFontFamilyVec),
    }

    /// Parsed CSS key-value pair
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzCssProperty {
        TextColor(AzStyleTextColorValue),
        FontSize(AzStyleFontSizeValue),
        FontFamily(AzStyleFontFamilyVecValue),
        TextAlign(AzStyleTextAlignValue),
        LetterSpacing(AzStyleLetterSpacingValue),
        LineHeight(AzStyleLineHeightValue),
        WordSpacing(AzStyleWordSpacingValue),
        TabWidth(AzStyleTabWidthValue),
        Cursor(AzStyleCursorValue),
        Display(AzLayoutDisplayValue),
        Float(AzLayoutFloatValue),
        BoxSizing(AzLayoutBoxSizingValue),
        Width(AzLayoutWidthValue),
        Height(AzLayoutHeightValue),
        MinWidth(AzLayoutMinWidthValue),
        MinHeight(AzLayoutMinHeightValue),
        MaxWidth(AzLayoutMaxWidthValue),
        MaxHeight(AzLayoutMaxHeightValue),
        Position(AzLayoutPositionValue),
        Top(AzLayoutTopValue),
        Right(AzLayoutRightValue),
        Left(AzLayoutLeftValue),
        Bottom(AzLayoutBottomValue),
        FlexWrap(AzLayoutFlexWrapValue),
        FlexDirection(AzLayoutFlexDirectionValue),
        FlexGrow(AzLayoutFlexGrowValue),
        FlexShrink(AzLayoutFlexShrinkValue),
        JustifyContent(AzLayoutJustifyContentValue),
        AlignItems(AzLayoutAlignItemsValue),
        AlignContent(AzLayoutAlignContentValue),
        BackgroundContent(AzStyleBackgroundContentVecValue),
        BackgroundPosition(AzStyleBackgroundPositionVecValue),
        BackgroundSize(AzStyleBackgroundSizeVecValue),
        BackgroundRepeat(AzStyleBackgroundRepeatVecValue),
        OverflowX(AzLayoutOverflowValue),
        OverflowY(AzLayoutOverflowValue),
        PaddingTop(AzLayoutPaddingTopValue),
        PaddingLeft(AzLayoutPaddingLeftValue),
        PaddingRight(AzLayoutPaddingRightValue),
        PaddingBottom(AzLayoutPaddingBottomValue),
        MarginTop(AzLayoutMarginTopValue),
        MarginLeft(AzLayoutMarginLeftValue),
        MarginRight(AzLayoutMarginRightValue),
        MarginBottom(AzLayoutMarginBottomValue),
        BorderTopLeftRadius(AzStyleBorderTopLeftRadiusValue),
        BorderTopRightRadius(AzStyleBorderTopRightRadiusValue),
        BorderBottomLeftRadius(AzStyleBorderBottomLeftRadiusValue),
        BorderBottomRightRadius(AzStyleBorderBottomRightRadiusValue),
        BorderTopColor(AzStyleBorderTopColorValue),
        BorderRightColor(AzStyleBorderRightColorValue),
        BorderLeftColor(AzStyleBorderLeftColorValue),
        BorderBottomColor(AzStyleBorderBottomColorValue),
        BorderTopStyle(AzStyleBorderTopStyleValue),
        BorderRightStyle(AzStyleBorderRightStyleValue),
        BorderLeftStyle(AzStyleBorderLeftStyleValue),
        BorderBottomStyle(AzStyleBorderBottomStyleValue),
        BorderTopWidth(AzLayoutBorderTopWidthValue),
        BorderRightWidth(AzLayoutBorderRightWidthValue),
        BorderLeftWidth(AzLayoutBorderLeftWidthValue),
        BorderBottomWidth(AzLayoutBorderBottomWidthValue),
        BoxShadowLeft(AzStyleBoxShadowValue),
        BoxShadowRight(AzStyleBoxShadowValue),
        BoxShadowTop(AzStyleBoxShadowValue),
        BoxShadowBottom(AzStyleBoxShadowValue),
        ScrollbarStyle(AzScrollbarStyleValue),
        Opacity(AzStyleOpacityValue),
        Transform(AzStyleTransformVecValue),
        TransformOrigin(AzStyleTransformOriginValue),
        PerspectiveOrigin(AzStylePerspectiveOriginValue),
        BackfaceVisibility(AzStyleBackfaceVisibilityValue),
        MixBlendMode(AzStyleMixBlendModeValue),
        Filter(AzStyleFilterVecValue),
        BackdropFilter(AzStyleFilterVecValue),
        TextShadow(AzStyleBoxShadowValue),
    }

    /// Re-export of rust-allocated (stack based) `FileInputStateWrapper` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileInputStateWrapper {
        pub inner: AzFileInputState,
        pub on_file_path_change: AzOptionFileInputOnPathChange,
        pub file_dialog_title: AzString,
        pub default_dir: AzOptionString,
        pub file_types: AzOptionFileTypeList,
    }

    /// Re-export of rust-allocated (stack based) `TextInputStateWrapper` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInputStateWrapper {
        pub inner: AzTextInputState,
        pub on_text_input: AzOptionTextInputOnTextInput,
        pub on_virtual_key_down: AzOptionTextInputOnVirtualKeyDown,
        pub on_focus_lost: AzOptionTextInputOnFocusLost,
        pub update_text_input_before_calling_focus_lost_fn: bool,
        pub update_text_input_before_calling_vk_down_fn: bool,
        pub cursor_animation: AzOptionTimerId,
    }

    /// Re-export of rust-allocated (stack based) `ProgressBar` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzProgressBar {
        pub state: AzProgressBarState,
        pub height: AzPixelValue,
        pub bar_background: AzStyleBackgroundContentVec,
        pub container_background: AzStyleBackgroundContentVec,
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeIdInfoMap` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNodeTypeIdInfoMap {
        pub node_type_id: AzNodeTypeId,
        pub node_type_info: AzNodeTypeInfo,
    }

    /// Re-export of rust-allocated (stack based) `InputOutputTypeIdInfoMap` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzInputOutputTypeIdInfoMap {
        pub io_type_id: AzInputOutputTypeId,
        pub io_info: AzInputOutputInfo,
    }

    /// Re-export of rust-allocated (stack based) `NodeTypeField` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    #[cfg_attr(feature = "serde-support", derive(Serialize, Deserialize))]
    pub struct AzNodeTypeField {
        pub key: AzString,
        pub value: AzNodeTypeFieldValue,
    }

    /// Re-export of rust-allocated (stack based) `CssPropertySource` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzCssPropertySource {
        Css(AzCssPath),
        Inline,
    }

    /// Re-export of rust-allocated (stack based) `VertexLayout` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzVertexLayout {
        pub fields: AzVertexAttributeVec,
    }

    /// Re-export of rust-allocated (stack based) `VertexArrayObject` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzVertexArrayObject {
        pub vertex_layout: AzVertexLayout,
        pub vao_id: u32,
        pub gl_context: AzGl,
        pub refcount: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `VertexBuffer` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzVertexBuffer {
        pub vertex_buffer_id: u32,
        pub vertex_buffer_len: usize,
        pub vao: AzVertexArrayObject,
        pub index_buffer_id: u32,
        pub index_buffer_len: usize,
        pub index_buffer_format: AzIndexBufferFormat,
        pub refcount: *const c_void,
        pub run_destructor: bool,
    }

    /// Re-export of rust-allocated (stack based) `SvgMultiPolygon` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgMultiPolygon {
        pub rings: AzSvgPathVec,
    }

    /// Re-export of rust-allocated (stack based) `TessellatedGPUSvgNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTessellatedGPUSvgNode {
        pub vertex_index_buffer: AzVertexBuffer,
    }

    /// Re-export of rust-allocated (stack based) `XmlNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzXmlNode {
        pub tag: AzString,
        pub attributes: AzStringPairVec,
        pub children: AzXmlNodeVec,
        pub text: AzOptionString,
    }

    /// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
    #[repr(C)]
    pub struct AzNodeTypeIdInfoMapVec {
        pub(crate) ptr: *const AzNodeTypeIdInfoMap,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeTypeIdInfoMapVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
    #[repr(C)]
    pub struct AzInputOutputTypeIdInfoMapVec {
        pub(crate) ptr: *const AzInputOutputTypeIdInfoMap,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInputOutputTypeIdInfoMapVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
    #[repr(C)]
    pub struct AzNodeTypeFieldVec {
        pub(crate) ptr: *const AzNodeTypeField,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeTypeFieldVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<InlineLine>`
    #[repr(C)]
    pub struct AzInlineLineVec {
        pub(crate) ptr: *const AzInlineLine,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzInlineLineVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<CssProperty>`
    #[repr(C)]
    pub struct AzCssPropertyVec {
        pub(crate) ptr: *const AzCssProperty,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCssPropertyVecDestructor,
    }

    /// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
    #[repr(C)]
    pub struct AzSvgMultiPolygonVec {
        pub(crate) ptr: *const AzSvgMultiPolygon,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzSvgMultiPolygonVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionCssProperty` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionCssProperty {
        None,
        Some(AzCssProperty),
    }

    /// Re-export of rust-allocated (stack based) `XmlTextError` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzXmlTextError {
        pub stream_error: AzXmlStreamError,
        pub pos: AzSvgParseErrorPosition,
    }

    /// Platform-specific window configuration, i.e. WM options that are not cross-platform
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzPlatformSpecificOptions {
        pub windows_options: AzWindowsWindowOptions,
        pub linux_options: AzLinuxWindowOptions,
        pub mac_options: AzMacWindowOptions,
        pub wasm_options: AzWasmWindowOptions,
    }

    /// Re-export of rust-allocated (stack based) `WindowState` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzWindowState {
        pub title: AzString,
        pub theme: AzWindowTheme,
        pub size: AzWindowSize,
        pub position: AzWindowPosition,
        pub flags: AzWindowFlags,
        pub debug_state: AzDebugState,
        pub keyboard_state: AzKeyboardState,
        pub mouse_state: AzMouseState,
        pub touch_state: AzTouchState,
        pub ime_position: AzImePosition,
        pub monitor: AzMonitor,
        pub platform_specific_options: AzPlatformSpecificOptions,
        pub renderer_options: AzRendererOptions,
        pub background_color: AzColorU,
        pub layout_callback: AzLayoutCallback,
        pub close_callback: AzOptionCallback,
    }

    /// Re-export of rust-allocated (stack based) `CallbackInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCallbackInfo {
        pub layout_results: *const c_void,
        pub layout_results_count: usize,
        pub renderer_resources: *const c_void,
        pub previous_window_state: *const c_void,
        pub current_window_state: *const c_void,
        pub modifiable_window_state: *mut AzWindowState,
        pub gl_context: *const AzOptionGl,
        pub image_cache: *mut c_void,
        pub system_fonts: *mut c_void,
        pub timers: *mut c_void,
        pub threads: *mut c_void,
        pub timers_removed: *mut c_void,
        pub threads_removed: *mut c_void,
        pub current_window_handle: *const AzRawWindowHandle,
        pub new_windows: *mut c_void,
        pub system_callbacks: *const AzSystemCallbacks,
        pub stop_propagation: *mut bool,
        pub focus_target: *mut c_void,
        pub words_changed_in_callbacks: *mut c_void,
        pub images_changed_in_callbacks: *mut c_void,
        pub image_masks_changed_in_callbacks: *mut c_void,
        pub css_properties_changed_in_callbacks: *mut c_void,
        pub current_scroll_states: *const c_void,
        pub nodes_scrolled_in_callback: *mut c_void,
        pub hit_dom_node: AzDomNodeId,
        pub cursor_relative_to_item: AzOptionLogicalPosition,
        pub cursor_in_viewport: AzOptionLogicalPosition,
        pub _reserved_ref: *const c_void,
        pub _reserved_mut: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `InlineText` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzInlineText {
        pub lines: AzInlineLineVec,
        pub content_size: AzLogicalSize,
        pub font_size_px: f32,
        pub last_word_index: usize,
        pub baseline_descender_px: f32,
    }

    /// CSS path to set the keyboard input focus
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFocusTargetPath {
        pub dom: AzDomId,
        pub css_path: AzCssPath,
    }

    /// Animation struct to start a new animation
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzAnimation {
        pub from: AzCssProperty,
        pub to: AzCssProperty,
        pub duration: AzDuration,
        pub repeat: AzAnimationRepeat,
        pub repeat_count: AzAnimationRepeatCount,
        pub easing: AzAnimationEasing,
        pub relayout_on_finish: bool,
    }

    /// Re-export of rust-allocated (stack based) `TimerCallbackInfo` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTimerCallbackInfo {
        pub callback_info: AzCallbackInfo,
        pub node_id: AzOptionDomNodeId,
        pub frame_start: AzInstant,
        pub call_count: usize,
        pub is_about_to_finish: bool,
        pub _reserved_ref: *const c_void,
        pub _reserved_mut: *mut c_void,
    }

    /// Re-export of rust-allocated (stack based) `NodeDataInlineCssProperty` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzNodeDataInlineCssProperty {
        Normal(AzCssProperty),
        Active(AzCssProperty),
        Focus(AzCssProperty),
        Hover(AzCssProperty),
    }

    /// Re-export of rust-allocated (stack based) `DynamicCssProperty` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDynamicCssProperty {
        pub dynamic_id: AzString,
        pub default_value: AzCssProperty,
    }

    /// Re-export of rust-allocated (stack based) `Node` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNode {
        pub node_type: AzNodeTypeId,
        pub position: AzNodePosition,
        pub fields: AzNodeTypeFieldVec,
        pub connect_in: AzInputConnectionVec,
        pub connect_out: AzOutputConnectionVec,
    }

    /// Re-export of rust-allocated (stack based) `SvgNode` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzSvgNode {
        MultiPolygonCollection(AzSvgMultiPolygonVec),
        MultiPolygon(AzSvgMultiPolygon),
        Path(AzSvgPath),
        Circle(AzSvgCircle),
        Rect(AzSvgRect),
    }

    /// Re-export of rust-allocated (stack based) `SvgStyledNode` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzSvgStyledNode {
        pub geometry: AzSvgNode,
        pub style: AzSvgStyle,
    }

    /// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
    #[repr(C)]
    pub struct AzNodeDataInlineCssPropertyVec {
        pub(crate) ptr: *const AzNodeDataInlineCssProperty,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeDataInlineCssPropertyVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionWindowState` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionWindowState {
        None,
        Some(AzWindowState),
    }

    /// Re-export of rust-allocated (stack based) `OptionInlineText` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionInlineText {
        None,
        Some(AzInlineText),
    }

    /// Re-export of rust-allocated (stack based) `XmlParseError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzXmlParseError {
        InvalidDeclaration(AzXmlTextError),
        InvalidComment(AzXmlTextError),
        InvalidPI(AzXmlTextError),
        InvalidDoctype(AzXmlTextError),
        InvalidEntity(AzXmlTextError),
        InvalidElement(AzXmlTextError),
        InvalidAttribute(AzXmlTextError),
        InvalidCdata(AzXmlTextError),
        InvalidCharData(AzXmlTextError),
        UnknownToken(AzSvgParseErrorPosition),
    }

    /// Options on how to initially create the window
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzWindowCreateOptions {
        pub state: AzWindowState,
        pub size_to_content: bool,
        pub renderer_type: AzOptionRendererOptions,
        pub theme: AzOptionWindowTheme,
        pub create_callback: AzOptionCallback,
        pub hot_reload: bool,
    }

    /// Defines the keyboard input focus target
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzFocusTarget {
        Id(AzDomNodeId),
        Path(AzFocusTargetPath),
        Previous,
        Next,
        First,
        Last,
        NoFocus,
    }

    /// Represents one single DOM node (node type, classes, ids and callbacks are stored here)
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeData {
        pub node_type: AzNodeType,
        pub dataset: AzOptionRefAny,
        pub ids_and_classes: AzIdOrClassVec,
        pub callbacks: AzCallbackDataVec,
        pub inline_css_props: AzNodeDataInlineCssPropertyVec,
        pub tab_index: AzOptionTabIndex,
        pub extra: *const c_void,
    }

    /// Re-export of rust-allocated (stack based) `CssDeclaration` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzCssDeclaration {
        Static(AzCssProperty),
        Dynamic(AzDynamicCssProperty),
    }

    /// Re-export of rust-allocated (stack based) `Button` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzButton {
        pub label: AzString,
        pub image: AzOptionImageRef,
        pub container_style: AzNodeDataInlineCssPropertyVec,
        pub label_style: AzNodeDataInlineCssPropertyVec,
        pub image_style: AzNodeDataInlineCssPropertyVec,
        pub on_click: AzOptionButtonOnClick,
    }

    /// Re-export of rust-allocated (stack based) `FileInput` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFileInput {
        pub state: AzFileInputStateWrapper,
        pub default_text: AzString,
        pub image: AzOptionImageRef,
        pub container_style: AzNodeDataInlineCssPropertyVec,
        pub label_style: AzNodeDataInlineCssPropertyVec,
        pub image_style: AzNodeDataInlineCssPropertyVec,
    }

    /// Re-export of rust-allocated (stack based) `CheckBox` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCheckBox {
        pub state: AzCheckBoxStateWrapper,
        pub container_style: AzNodeDataInlineCssPropertyVec,
        pub content_style: AzNodeDataInlineCssPropertyVec,
    }

    /// Re-export of rust-allocated (stack based) `Label` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzLabel {
        pub text: AzString,
        pub style: AzNodeDataInlineCssPropertyVec,
    }

    /// Re-export of rust-allocated (stack based) `ColorInput` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzColorInput {
        pub state: AzColorInputStateWrapper,
        pub style: AzNodeDataInlineCssPropertyVec,
    }

    /// Re-export of rust-allocated (stack based) `TextInput` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTextInput {
        pub state: AzTextInputStateWrapper,
        pub placeholder_style: AzNodeDataInlineCssPropertyVec,
        pub container_style: AzNodeDataInlineCssPropertyVec,
        pub label_style: AzNodeDataInlineCssPropertyVec,
    }

    /// Re-export of rust-allocated (stack based) `NumberInput` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNumberInput {
        pub text_input: AzTextInput,
        pub state: AzNumberInputStateWrapper,
    }

    /// Re-export of rust-allocated (stack based) `NodeIdNodeMap` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeIdNodeMap {
        pub node_id: AzNodeGraphNodeId,
        pub node: AzNode,
    }

    /// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
    #[repr(C)]
    pub struct AzNodeIdNodeMapVec {
        pub(crate) ptr: *const AzNodeIdNodeMap,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeIdNodeMapVecDestructor,
    }

    /// Wrapper over a Rust-allocated `CssDeclaration`
    #[repr(C)]
    pub struct AzCssDeclarationVec {
        pub(crate) ptr: *const AzCssDeclaration,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCssDeclarationVecDestructor,
    }

    /// Wrapper over a Rust-allocated `NodeDataVec`
    #[repr(C)]
    pub struct AzNodeDataVec {
        pub(crate) ptr: *const AzNodeData,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzNodeDataVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `XmlError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzXmlError {
        NoParserAvailable,
        InvalidXmlPrefixUri(AzSvgParseErrorPosition),
        UnexpectedXmlUri(AzSvgParseErrorPosition),
        UnexpectedXmlnsUri(AzSvgParseErrorPosition),
        InvalidElementNamePrefix(AzSvgParseErrorPosition),
        DuplicatedNamespace(AzDuplicatedNamespaceError),
        UnknownNamespace(AzUnknownNamespaceError),
        UnexpectedCloseTag(AzUnexpectedCloseTagError),
        UnexpectedEntityCloseTag(AzSvgParseErrorPosition),
        UnknownEntityReference(AzUnknownEntityReferenceError),
        MalformedEntityReference(AzSvgParseErrorPosition),
        EntityReferenceLoop(AzSvgParseErrorPosition),
        InvalidAttributeValue(AzSvgParseErrorPosition),
        DuplicatedAttribute(AzDuplicatedAttributeError),
        NoRootNode,
        SizeLimit,
        ParserError(AzXmlParseError),
    }

    /// Re-export of rust-allocated (stack based) `Dom` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzDom {
        pub root: AzNodeData,
        pub children: AzDomVec,
        pub total_children: usize,
    }

    /// Re-export of rust-allocated (stack based) `CssRuleBlock` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCssRuleBlock {
        pub path: AzCssPath,
        pub declarations: AzCssDeclarationVec,
    }

    /// Re-export of rust-allocated (stack based) `Tab` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTab {
        pub title: AzString,
        pub content: AzDom,
    }

    /// Re-export of rust-allocated (stack based) `Frame` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzFrame {
        pub title: AzString,
        pub flex_grow: f32,
        pub content: AzDom,
    }

    /// Re-export of rust-allocated (stack based) `NodeGraph` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzNodeGraph {
        pub node_types: AzNodeTypeIdInfoMapVec,
        pub input_output_types: AzInputOutputTypeIdInfoMapVec,
        pub nodes: AzNodeIdNodeMapVec,
        pub allow_multiple_root_nodes: bool,
        pub offset: AzLogicalPosition,
        pub style: AzNodeGraphStyle,
        pub callbacks: AzNodeGraphCallbacks,
        pub add_node_str: AzString,
    }

    /// Re-export of rust-allocated (stack based) `StyledDom` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzStyledDom {
        pub root: AzNodeId,
        pub node_hierarchy: AzNodeHierarchyItemVec,
        pub node_data: AzNodeDataVec,
        pub styled_nodes: AzStyledNodeVec,
        pub cascade_info: AzCascadeInfoVec,
        pub nodes_with_window_callbacks: AzNodeIdVec,
        pub nodes_with_not_callbacks: AzNodeIdVec,
        pub nodes_with_datasets_and_callbacks: AzNodeIdVec,
        pub tag_ids_to_node_ids: AzTagIdToNodeIdMappingVec,
        pub non_leaf_nodes: AzParentWithNodeDepthVec,
        pub css_property_cache: AzCssPropertyCache,
    }

    /// Wrapper over a Rust-allocated `Vec<Tab>`
    #[repr(C)]
    pub struct AzTabVec {
        pub(crate) ptr: *const AzTab,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzTabVecDestructor,
    }

    /// Wrapper over a Rust-allocated `CssRuleBlock`
    #[repr(C)]
    pub struct AzCssRuleBlockVec {
        pub(crate) ptr: *const AzCssRuleBlock,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzCssRuleBlockVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `OptionDom` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzOptionDom {
        None,
        Some(AzDom),
    }

    /// Re-export of rust-allocated (stack based) `ResultXmlXmlError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzResultXmlXmlError {
        Ok(AzXml),
        Err(AzXmlError),
    }

    /// Re-export of rust-allocated (stack based) `SvgParseError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzSvgParseError {
        NoParserAvailable,
        InvalidFileSuffix,
        FileOpenFailed,
        NotAnUtf8Str,
        MalformedGZip,
        InvalidSize,
        ParsingFailed(AzXmlError),
    }

    /// <img src="../images/scrollbounds.png"/>
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzIFrameCallbackReturn {
        pub dom: AzStyledDom,
        pub scroll_size: AzLogicalSize,
        pub scroll_offset: AzLogicalPosition,
        pub virtual_scroll_size: AzLogicalSize,
        pub virtual_scroll_offset: AzLogicalPosition,
    }

    /// Re-export of rust-allocated (stack based) `Stylesheet` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzStylesheet {
        pub rules: AzCssRuleBlockVec,
    }

    /// Re-export of rust-allocated (stack based) `TabContainer` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzTabContainer {
        pub tabs: AzTabVec,
        pub active_tab: usize,
        pub has_padding: bool,
    }

    /// Wrapper over a Rust-allocated `Stylesheet`
    #[repr(C)]
    pub struct AzStylesheetVec {
        pub(crate) ptr: *const AzStylesheet,
        pub len: usize,
        pub cap: usize,
        pub destructor: AzStylesheetVecDestructor,
    }

    /// Re-export of rust-allocated (stack based) `ResultSvgXmlNodeSvgParseError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzResultSvgXmlNodeSvgParseError {
        Ok(AzSvgXmlNode),
        Err(AzSvgParseError),
    }

    /// Re-export of rust-allocated (stack based) `ResultSvgSvgParseError` struct
    #[repr(C, u8)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub enum AzResultSvgSvgParseError {
        Ok(AzSvg),
        Err(AzSvgParseError),
    }

    /// Re-export of rust-allocated (stack based) `Css` struct
    #[repr(C)]
    #[derive(Debug)]
    #[derive(Clone)]
    #[derive(PartialEq, PartialOrd)]
    pub struct AzCss {
        pub stylesheets: AzStylesheetVec,
    }

    #[cfg_attr(target_os = "windows", link(name="azul.dll"))] // https://github.com/rust-lang/cargo/issues/9082
    #[cfg_attr(not(target_os = "windows"), link(name="azul"))] // https://github.com/rust-lang/cargo/issues/9082
    extern "C" {
        pub(crate) fn AzApp_new(_:  AzRefAny, _:  AzAppConfig) -> AzApp;
        pub(crate) fn AzApp_addWindow(_:  &mut AzApp, _:  AzWindowCreateOptions);
        pub(crate) fn AzApp_addImage(_:  &mut AzApp, _:  AzString, _:  AzImageRef);
        pub(crate) fn AzApp_getMonitors(_:  &AzApp) -> AzMonitorVec;
        pub(crate) fn AzApp_run(_:  &AzApp, _:  AzWindowCreateOptions);
        pub(crate) fn AzApp_delete(_:  &mut AzApp);
        pub(crate) fn AzApp_deepCopy(_:  &AzApp) -> AzApp;
        pub(crate) fn AzAppConfig_new(_:  AzLayoutSolver) -> AzAppConfig;
        pub(crate) fn AzSystemCallbacks_libraryInternal() -> AzSystemCallbacks;
        pub(crate) fn AzWindowCreateOptions_new(_:  AzLayoutCallbackType) -> AzWindowCreateOptions;
        pub(crate) fn AzLogicalSize_toPhysical(_:  &AzLogicalSize, _:  f32) -> AzPhysicalSizeU32;
        pub(crate) fn AzKeyboardState_shiftDown(_:  &AzKeyboardState) -> bool;
        pub(crate) fn AzKeyboardState_ctrlDown(_:  &AzKeyboardState) -> bool;
        pub(crate) fn AzKeyboardState_altDown(_:  &AzKeyboardState) -> bool;
        pub(crate) fn AzKeyboardState_superDown(_:  &AzKeyboardState) -> bool;
        pub(crate) fn AzKeyboardState_isKeyDown(_:  &AzKeyboardState, _:  AzVirtualKeyCode) -> bool;
        pub(crate) fn AzCursorPosition_getPosition(_:  &AzCursorPosition) -> AzOptionLogicalPosition;
        pub(crate) fn AzWindowState_new(_:  AzLayoutCallbackType) -> AzWindowState;
        pub(crate) fn AzWindowState_default() -> AzWindowState;
        pub(crate) fn AzCallbackInfo_getHitNode(_:  &AzCallbackInfo) -> AzDomNodeId;
        pub(crate) fn AzCallbackInfo_getSystemTimeFn(_:  &AzCallbackInfo) -> AzGetSystemTimeFn;
        pub(crate) fn AzCallbackInfo_getCursorRelativeToViewport(_:  &AzCallbackInfo) -> AzOptionLogicalPosition;
        pub(crate) fn AzCallbackInfo_getCursorRelativeToNode(_:  &AzCallbackInfo) -> AzOptionLogicalPosition;
        pub(crate) fn AzCallbackInfo_getCurrentWindowState(_:  &AzCallbackInfo) -> AzWindowState;
        pub(crate) fn AzCallbackInfo_getCurrentKeyboardState(_:  &AzCallbackInfo) -> AzKeyboardState;
        pub(crate) fn AzCallbackInfo_getCurrentMouseState(_:  &AzCallbackInfo) -> AzMouseState;
        pub(crate) fn AzCallbackInfo_getPreviousWindowState(_:  &AzCallbackInfo) -> AzOptionWindowState;
        pub(crate) fn AzCallbackInfo_getPreviousKeyboardState(_:  &AzCallbackInfo) -> AzOptionKeyboardState;
        pub(crate) fn AzCallbackInfo_getPreviousMouseState(_:  &AzCallbackInfo) -> AzOptionMouseState;
        pub(crate) fn AzCallbackInfo_getCurrentWindowHandle(_:  &AzCallbackInfo) -> AzRawWindowHandle;
        pub(crate) fn AzCallbackInfo_getGlContext(_:  &AzCallbackInfo) -> AzOptionGl;
        pub(crate) fn AzCallbackInfo_getScrollPosition(_:  &AzCallbackInfo, _:  AzDomNodeId) -> AzOptionLogicalPosition;
        pub(crate) fn AzCallbackInfo_getDataset(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionRefAny;
        pub(crate) fn AzCallbackInfo_getNodeIdOfRootDataset(_:  &mut AzCallbackInfo, _:  AzRefAny) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getStringContents(_:  &AzCallbackInfo, _:  AzDomNodeId) -> AzOptionString;
        pub(crate) fn AzCallbackInfo_getInlineText(_:  &AzCallbackInfo, _:  AzDomNodeId) -> AzOptionInlineText;
        pub(crate) fn AzCallbackInfo_getFontRef(_:  &AzCallbackInfo, _:  AzDomNodeId) -> AzOptionFontRef;
        pub(crate) fn AzCallbackInfo_getTextLayoutOptions(_:  &AzCallbackInfo, _:  AzDomNodeId) -> AzOptionResolvedTextLayoutOptions;
        pub(crate) fn AzCallbackInfo_shapeText(_:  &AzCallbackInfo, _:  AzDomNodeId, _:  AzString) -> AzOptionInlineText;
        pub(crate) fn AzCallbackInfo_getIndexInParent(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> usize;
        pub(crate) fn AzCallbackInfo_getParent(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getPreviousSibling(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getNextSibling(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getFirstChild(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getLastChild(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzCallbackInfo_getNodePosition(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionPositionInfo;
        pub(crate) fn AzCallbackInfo_getNodeSize(_:  &mut AzCallbackInfo, _:  AzDomNodeId) -> AzOptionLogicalSize;
        pub(crate) fn AzCallbackInfo_getComputedCssProperty(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzCssPropertyType) -> AzOptionCssProperty;
        pub(crate) fn AzCallbackInfo_setWindowState(_:  &mut AzCallbackInfo, _:  AzWindowState);
        pub(crate) fn AzCallbackInfo_setFocus(_:  &mut AzCallbackInfo, _:  AzFocusTarget);
        pub(crate) fn AzCallbackInfo_setCssProperty(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzCssProperty);
        pub(crate) fn AzCallbackInfo_setScrollPosition(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzLogicalPosition);
        pub(crate) fn AzCallbackInfo_setStringContents(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzString);
        pub(crate) fn AzCallbackInfo_addImage(_:  &mut AzCallbackInfo, _:  AzString, _:  AzImageRef);
        pub(crate) fn AzCallbackInfo_hasImage(_:  &AzCallbackInfo, _:  AzString) -> bool;
        pub(crate) fn AzCallbackInfo_getImage(_:  &AzCallbackInfo, _:  AzString) -> AzOptionImageRef;
        pub(crate) fn AzCallbackInfo_updateImage(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzImageRef, _:  AzUpdateImageType);
        pub(crate) fn AzCallbackInfo_deleteImage(_:  &mut AzCallbackInfo, _:  AzString);
        pub(crate) fn AzCallbackInfo_updateImageMask(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzImageMask);
        pub(crate) fn AzCallbackInfo_stopPropagation(_:  &mut AzCallbackInfo);
        pub(crate) fn AzCallbackInfo_createWindow(_:  &mut AzCallbackInfo, _:  AzWindowCreateOptions);
        pub(crate) fn AzCallbackInfo_startTimer(_:  &mut AzCallbackInfo, _:  AzTimer) -> AzTimerId;
        pub(crate) fn AzCallbackInfo_startAnimation(_:  &mut AzCallbackInfo, _:  AzDomNodeId, _:  AzAnimation) -> AzOptionTimerId;
        pub(crate) fn AzCallbackInfo_stopTimer(_:  &mut AzCallbackInfo, _:  AzTimerId) -> bool;
        pub(crate) fn AzCallbackInfo_startThread(_:  &mut AzCallbackInfo, _:  AzRefAny, _:  AzRefAny, _:  AzThreadCallbackType) -> AzOptionThreadId;
        pub(crate) fn AzCallbackInfo_sendThreadMsg(_:  &mut AzCallbackInfo, _:  AzThreadId, _:  AzThreadSendMsg) -> bool;
        pub(crate) fn AzCallbackInfo_stopThread(_:  &mut AzCallbackInfo, _:  AzThreadId) -> bool;
        pub(crate) fn AzPositionInfo_isPositioned(_:  &AzPositionInfo) -> bool;
        pub(crate) fn AzPositionInfo_getStaticOffset(_:  &AzPositionInfo) -> AzLogicalPosition;
        pub(crate) fn AzPositionInfo_getRelativeOffset(_:  &AzPositionInfo) -> AzLogicalPosition;
        pub(crate) fn AzHidpiAdjustedBounds_getLogicalSize(_:  &AzHidpiAdjustedBounds) -> AzLogicalSize;
        pub(crate) fn AzHidpiAdjustedBounds_getPhysicalSize(_:  &AzHidpiAdjustedBounds) -> AzPhysicalSizeU32;
        pub(crate) fn AzHidpiAdjustedBounds_getHidpiFactor(_:  &AzHidpiAdjustedBounds) -> f32;
        pub(crate) fn AzInlineText_hitTest(_:  &AzInlineText, _:  AzLogicalPosition) -> AzInlineTextHitVec;
        pub(crate) fn AzResolvedTextLayoutOptions_default() -> AzResolvedTextLayoutOptions;
        pub(crate) fn AzRenderImageCallbackInfo_getGlContext(_:  &AzRenderImageCallbackInfo) -> AzOptionGl;
        pub(crate) fn AzRenderImageCallbackInfo_getBounds(_:  &AzRenderImageCallbackInfo) -> AzHidpiAdjustedBounds;
        pub(crate) fn AzRenderImageCallbackInfo_getCallbackNodeId(_:  &AzRenderImageCallbackInfo) -> AzDomNodeId;
        pub(crate) fn AzRenderImageCallbackInfo_getInlineText(_:  &AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionInlineText;
        pub(crate) fn AzRenderImageCallbackInfo_getIndexInParent(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> usize;
        pub(crate) fn AzRenderImageCallbackInfo_getParent(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzRenderImageCallbackInfo_getPreviousSibling(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzRenderImageCallbackInfo_getNextSibling(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzRenderImageCallbackInfo_getFirstChild(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzRenderImageCallbackInfo_getLastChild(_:  &mut AzRenderImageCallbackInfo, _:  AzDomNodeId) -> AzOptionDomNodeId;
        pub(crate) fn AzRefCount_canBeShared(_:  &AzRefCount) -> bool;
        pub(crate) fn AzRefCount_canBeSharedMut(_:  &AzRefCount) -> bool;
        pub(crate) fn AzRefCount_increaseRef(_:  &mut AzRefCount);
        pub(crate) fn AzRefCount_decreaseRef(_:  &mut AzRefCount);
        pub(crate) fn AzRefCount_increaseRefmut(_:  &mut AzRefCount);
        pub(crate) fn AzRefCount_decreaseRefmut(_:  &mut AzRefCount);
        pub(crate) fn AzRefCount_delete(_:  &mut AzRefCount);
        pub(crate) fn AzRefCount_deepCopy(_:  &AzRefCount) -> AzRefCount;
        pub(crate) fn AzRefAny_newC(_:  *const c_void, _:  usize, _:  u64, _:  AzString, _:  AzRefAnyDestructorType) -> AzRefAny;
        pub(crate) fn AzRefAny_getTypeId(_:  &AzRefAny) -> u64;
        pub(crate) fn AzRefAny_getTypeName(_:  &AzRefAny) -> AzString;
        pub(crate) fn AzRefAny_delete(_:  &mut AzRefAny);
        pub(crate) fn AzRefAny_deepCopy(_:  &AzRefAny) -> AzRefAny;
        pub(crate) fn AzLayoutCallbackInfo_getGlContext(_:  &AzLayoutCallbackInfo) -> AzOptionGl;
        pub(crate) fn AzLayoutCallbackInfo_getSystemFonts(_:  &AzLayoutCallbackInfo) -> AzStringPairVec;
        pub(crate) fn AzLayoutCallbackInfo_getImage(_:  &AzLayoutCallbackInfo, _:  AzString) -> AzOptionImageRef;
        pub(crate) fn AzDom_new(_:  AzNodeType) -> AzDom;
        pub(crate) fn AzDom_body() -> AzDom;
        pub(crate) fn AzDom_div() -> AzDom;
        pub(crate) fn AzDom_br() -> AzDom;
        pub(crate) fn AzDom_text(_:  AzString) -> AzDom;
        pub(crate) fn AzDom_image(_:  AzImageRef) -> AzDom;
        pub(crate) fn AzDom_iframe(_:  AzRefAny, _:  AzIFrameCallbackType) -> AzDom;
        pub(crate) fn AzDom_setNodeType(_:  &mut AzDom, _:  AzNodeType);
        pub(crate) fn AzDom_withNodeType(_:  &mut AzDom, _:  AzNodeType) -> AzDom;
        pub(crate) fn AzDom_setDataset(_:  &mut AzDom, _:  AzRefAny);
        pub(crate) fn AzDom_withDataset(_:  &mut AzDom, _:  AzRefAny) -> AzDom;
        pub(crate) fn AzDom_setIdsAndClasses(_:  &mut AzDom, _:  AzIdOrClassVec);
        pub(crate) fn AzDom_withIdsAndClasses(_:  &mut AzDom, _:  AzIdOrClassVec) -> AzDom;
        pub(crate) fn AzDom_setCallbacks(_:  &mut AzDom, _:  AzCallbackDataVec);
        pub(crate) fn AzDom_withCallbacks(_:  &mut AzDom, _:  AzCallbackDataVec) -> AzDom;
        pub(crate) fn AzDom_setInlineCssProps(_:  &mut AzDom, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzDom_withInlineCssProps(_:  &mut AzDom, _:  AzNodeDataInlineCssPropertyVec) -> AzDom;
        pub(crate) fn AzDom_addCallback(_:  &mut AzDom, _:  AzEventFilter, _:  AzRefAny, _:  AzCallbackType);
        pub(crate) fn AzDom_withCallback(_:  &mut AzDom, _:  AzEventFilter, _:  AzRefAny, _:  AzCallbackType) -> AzDom;
        pub(crate) fn AzDom_addChild(_:  &mut AzDom, _:  AzDom);
        pub(crate) fn AzDom_withChild(_:  &mut AzDom, _:  AzDom) -> AzDom;
        pub(crate) fn AzDom_setChildren(_:  &mut AzDom, _:  AzDomVec);
        pub(crate) fn AzDom_withChildren(_:  &mut AzDom, _:  AzDomVec) -> AzDom;
        pub(crate) fn AzDom_addId(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withId(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_addClass(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withClass(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_addCssProperty(_:  &mut AzDom, _:  AzCssProperty);
        pub(crate) fn AzDom_withCssProperty(_:  &mut AzDom, _:  AzCssProperty) -> AzDom;
        pub(crate) fn AzDom_addHoverCssProperty(_:  &mut AzDom, _:  AzCssProperty);
        pub(crate) fn AzDom_withHoverCssProperty(_:  &mut AzDom, _:  AzCssProperty) -> AzDom;
        pub(crate) fn AzDom_addActiveCssProperty(_:  &mut AzDom, _:  AzCssProperty);
        pub(crate) fn AzDom_withActiveCssProperty(_:  &mut AzDom, _:  AzCssProperty) -> AzDom;
        pub(crate) fn AzDom_addFocusCssProperty(_:  &mut AzDom, _:  AzCssProperty);
        pub(crate) fn AzDom_withFocusCssProperty(_:  &mut AzDom, _:  AzCssProperty) -> AzDom;
        pub(crate) fn AzDom_setInlineStyle(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withInlineStyle(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_setInlineHoverStyle(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withInlineHoverStyle(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_setInlineActiveStyle(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withInlineActiveStyle(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_setInlineFocusStyle(_:  &mut AzDom, _:  AzString);
        pub(crate) fn AzDom_withInlineFocusStyle(_:  &mut AzDom, _:  AzString) -> AzDom;
        pub(crate) fn AzDom_setClipMask(_:  &mut AzDom, _:  AzImageMask);
        pub(crate) fn AzDom_withClipMask(_:  &mut AzDom, _:  AzImageMask) -> AzDom;
        pub(crate) fn AzDom_setTabIndex(_:  &mut AzDom, _:  AzTabIndex);
        pub(crate) fn AzDom_withTabIndex(_:  &mut AzDom, _:  AzTabIndex) -> AzDom;
        pub(crate) fn AzDom_setAccessibilityInfo(_:  &mut AzDom, _:  AzAccessibilityInfo);
        pub(crate) fn AzDom_withAccessibilityInfo(_:  &mut AzDom, _:  AzAccessibilityInfo) -> AzDom;
        pub(crate) fn AzDom_setMenuBar(_:  &mut AzDom, _:  AzMenu);
        pub(crate) fn AzDom_withMenuBar(_:  &mut AzDom, _:  AzMenu) -> AzDom;
        pub(crate) fn AzDom_setContextMenu(_:  &mut AzDom, _:  AzMenu);
        pub(crate) fn AzDom_withContextMenu(_:  &mut AzDom, _:  AzMenu) -> AzDom;
        pub(crate) fn AzDom_hash(_:  &AzDom) -> u64;
        pub(crate) fn AzDom_nodeCount(_:  &AzDom) -> usize;
        pub(crate) fn AzDom_getHtmlString(_:  &mut AzDom) -> AzString;
        pub(crate) fn AzDom_getHtmlStringTest(_:  &mut AzDom) -> AzString;
        pub(crate) fn AzDom_style(_:  &mut AzDom, _:  AzCss) -> AzStyledDom;
        pub(crate) fn AzNodeData_new(_:  AzNodeType) -> AzNodeData;
        pub(crate) fn AzNodeData_body() -> AzNodeData;
        pub(crate) fn AzNodeData_div() -> AzNodeData;
        pub(crate) fn AzNodeData_br() -> AzNodeData;
        pub(crate) fn AzNodeData_text(_:  AzString) -> AzNodeData;
        pub(crate) fn AzNodeData_image(_:  AzImageRef) -> AzNodeData;
        pub(crate) fn AzNodeData_iframe(_:  AzRefAny, _:  AzIFrameCallbackType) -> AzNodeData;
        pub(crate) fn AzNodeData_setNodeType(_:  &mut AzNodeData, _:  AzNodeType);
        pub(crate) fn AzNodeData_withNodeType(_:  &mut AzNodeData, _:  AzNodeType) -> AzNodeData;
        pub(crate) fn AzNodeData_setDataset(_:  &mut AzNodeData, _:  AzRefAny);
        pub(crate) fn AzNodeData_withDataset(_:  &mut AzNodeData, _:  AzRefAny) -> AzNodeData;
        pub(crate) fn AzNodeData_setIdsAndClasses(_:  &mut AzNodeData, _:  AzIdOrClassVec);
        pub(crate) fn AzNodeData_withIdsAndClasses(_:  &mut AzNodeData, _:  AzIdOrClassVec) -> AzNodeData;
        pub(crate) fn AzNodeData_addCallback(_:  &mut AzNodeData, _:  AzEventFilter, _:  AzRefAny, _:  AzCallbackType);
        pub(crate) fn AzNodeData_withCallback(_:  &mut AzNodeData, _:  AzEventFilter, _:  AzRefAny, _:  AzCallbackType) -> AzNodeData;
        pub(crate) fn AzNodeData_setCallbacks(_:  &mut AzNodeData, _:  AzCallbackDataVec);
        pub(crate) fn AzNodeData_withCallbacks(_:  &mut AzNodeData, _:  AzCallbackDataVec) -> AzNodeData;
        pub(crate) fn AzNodeData_setInlineCssProps(_:  &mut AzNodeData, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzNodeData_withInlineCssProps(_:  &mut AzNodeData, _:  AzNodeDataInlineCssPropertyVec) -> AzNodeData;
        pub(crate) fn AzNodeData_setInlineStyle(_:  &mut AzNodeData, _:  AzString);
        pub(crate) fn AzNodeData_withInlineStyle(_:  &mut AzNodeData, _:  AzString) -> AzNodeData;
        pub(crate) fn AzNodeData_setInlineHoverStyle(_:  &mut AzNodeData, _:  AzString);
        pub(crate) fn AzNodeData_withInlineHoverStyle(_:  &mut AzNodeData, _:  AzString) -> AzNodeData;
        pub(crate) fn AzNodeData_setInlineActiveStyle(_:  &mut AzNodeData, _:  AzString);
        pub(crate) fn AzNodeData_withInlineActiveStyle(_:  &mut AzNodeData, _:  AzString) -> AzNodeData;
        pub(crate) fn AzNodeData_setInlineFocusStyle(_:  &mut AzNodeData, _:  AzString);
        pub(crate) fn AzNodeData_withInlineFocusStyle(_:  &mut AzNodeData, _:  AzString) -> AzNodeData;
        pub(crate) fn AzNodeData_setClipMask(_:  &mut AzNodeData, _:  AzImageMask);
        pub(crate) fn AzNodeData_setTabIndex(_:  &mut AzNodeData, _:  AzTabIndex);
        pub(crate) fn AzNodeData_setAccessibilityInfo(_:  &mut AzNodeData, _:  AzAccessibilityInfo);
        pub(crate) fn AzNodeData_setMenuBar(_:  &mut AzNodeData, _:  AzMenu);
        pub(crate) fn AzNodeData_setContextMenu(_:  &mut AzNodeData, _:  AzMenu);
        pub(crate) fn AzNodeData_hash(_:  &AzNodeData) -> u64;
        pub(crate) fn AzOn_intoEventFilter(_:  AzOn) -> AzEventFilter;
        pub(crate) fn AzMenu_new(_:  AzMenuItemVec) -> AzMenu;
        pub(crate) fn AzMenu_setPopupPosition(_:  &mut AzMenu, _:  AzMenuPopupPosition);
        pub(crate) fn AzMenu_withPopupPosition(_:  &mut AzMenu, _:  AzMenuPopupPosition) -> AzMenu;
        pub(crate) fn AzStringMenuItem_new(_:  AzString) -> AzStringMenuItem;
        pub(crate) fn AzStringMenuItem_setCallback(_:  &mut AzStringMenuItem, _:  AzRefAny, _:  AzCallbackType);
        pub(crate) fn AzStringMenuItem_withCallback(_:  &mut AzStringMenuItem, _:  AzRefAny, _:  AzCallbackType) -> AzStringMenuItem;
        pub(crate) fn AzStringMenuItem_addChild(_:  &mut AzStringMenuItem, _:  AzMenuItem);
        pub(crate) fn AzStringMenuItem_withChild(_:  &mut AzStringMenuItem, _:  AzMenuItem) -> AzStringMenuItem;
        pub(crate) fn AzStringMenuItem_setChildren(_:  &mut AzStringMenuItem, _:  AzMenuItemVec);
        pub(crate) fn AzStringMenuItem_withChildren(_:  &mut AzStringMenuItem, _:  AzMenuItemVec) -> AzStringMenuItem;
        pub(crate) fn AzMenuCallback_new(_:  AzRefAny, _:  AzCallbackType) -> AzMenuCallback;
        pub(crate) fn AzCss_empty() -> AzCss;
        pub(crate) fn AzCss_fromString(_:  AzString) -> AzCss;
        pub(crate) fn AzColorU_fromStr(_:  AzString) -> AzColorU;
        pub(crate) fn AzColorU_transparent() -> AzColorU;
        pub(crate) fn AzColorU_white() -> AzColorU;
        pub(crate) fn AzColorU_black() -> AzColorU;
        pub(crate) fn AzColorU_toHash(_:  &AzColorU) -> AzString;
        pub(crate) fn AzAngleValue_getDegrees(_:  &AzAngleValue) -> f32;
        pub(crate) fn AzCssProperty_getKeyString(_:  &AzCssProperty) -> AzString;
        pub(crate) fn AzCssProperty_getValueString(_:  &AzCssProperty) -> AzString;
        pub(crate) fn AzCssProperty_getKeyValueString(_:  &AzCssProperty) -> AzString;
        pub(crate) fn AzCssProperty_interpolate(_:  &AzCssProperty, _:  AzCssProperty, _:  f32, _:  AzInterpolateContext) -> AzCssProperty;
        pub(crate) fn AzButton_new(_:  AzString) -> AzButton;
        pub(crate) fn AzButton_setOnClick(_:  &mut AzButton, _:  AzRefAny, _:  AzCallbackType);
        pub(crate) fn AzButton_withOnClick(_:  &mut AzButton, _:  AzRefAny, _:  AzCallbackType) -> AzButton;
        pub(crate) fn AzButton_dom(_:  &mut AzButton) -> AzDom;
        pub(crate) fn AzFileInput_new(_:  AzOptionString) -> AzFileInput;
        pub(crate) fn AzFileInput_setOnPathChange(_:  &mut AzFileInput, _:  AzRefAny, _:  AzFileInputOnPathChangeCallbackType);
        pub(crate) fn AzFileInput_withOnPathChange(_:  &mut AzFileInput, _:  AzRefAny, _:  AzFileInputOnPathChangeCallbackType) -> AzFileInput;
        pub(crate) fn AzFileInput_dom(_:  &mut AzFileInput) -> AzDom;
        pub(crate) fn AzCheckBox_new(_:  bool) -> AzCheckBox;
        pub(crate) fn AzCheckBox_setOnToggle(_:  &mut AzCheckBox, _:  AzRefAny, _:  AzCheckBoxOnToggleCallbackType);
        pub(crate) fn AzCheckBox_withOnToggle(_:  &mut AzCheckBox, _:  AzRefAny, _:  AzCheckBoxOnToggleCallbackType) -> AzCheckBox;
        pub(crate) fn AzCheckBox_dom(_:  &mut AzCheckBox) -> AzDom;
        pub(crate) fn AzLabel_new(_:  AzString) -> AzLabel;
        pub(crate) fn AzLabel_dom(_:  &mut AzLabel) -> AzDom;
        pub(crate) fn AzColorInput_new(_:  AzColorU) -> AzColorInput;
        pub(crate) fn AzColorInput_setOnValueChange(_:  &mut AzColorInput, _:  AzRefAny, _:  AzColorInputOnValueChangeCallbackType);
        pub(crate) fn AzColorInput_withOnValueChange(_:  &mut AzColorInput, _:  AzRefAny, _:  AzColorInputOnValueChangeCallbackType) -> AzColorInput;
        pub(crate) fn AzColorInput_dom(_:  &mut AzColorInput) -> AzDom;
        pub(crate) fn AzTextInput_new(_:  AzString) -> AzTextInput;
        pub(crate) fn AzTextInput_setOnTextInput(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnTextInputCallbackType);
        pub(crate) fn AzTextInput_withOnTextInput(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnTextInputCallbackType) -> AzTextInput;
        pub(crate) fn AzTextInput_setOnVirtualKeyDown(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnVirtualKeyDownCallbackType);
        pub(crate) fn AzTextInput_withOnVirtualKeyDown(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnVirtualKeyDownCallbackType) -> AzTextInput;
        pub(crate) fn AzTextInput_setOnFocusLost(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnFocusLostCallbackType);
        pub(crate) fn AzTextInput_withOnFocusLost(_:  &mut AzTextInput, _:  AzRefAny, _:  AzTextInputOnFocusLostCallbackType) -> AzTextInput;
        pub(crate) fn AzTextInput_setPlaceholderStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzTextInput_withPlaceholderStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec) -> AzTextInput;
        pub(crate) fn AzTextInput_setContainerStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzTextInput_withContainerStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec) -> AzTextInput;
        pub(crate) fn AzTextInput_setLabelStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzTextInput_withLabelStyle(_:  &mut AzTextInput, _:  AzNodeDataInlineCssPropertyVec) -> AzTextInput;
        pub(crate) fn AzTextInput_dom(_:  &mut AzTextInput) -> AzDom;
        pub(crate) fn AzTextInputState_getText(_:  &AzTextInputState) -> AzString;
        pub(crate) fn AzNumberInput_new(_:  f32) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setOnTextInput(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzTextInputOnTextInputCallbackType);
        pub(crate) fn AzNumberInput_withOnTextInput(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzTextInputOnTextInputCallbackType) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setOnVirtualKeyDown(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzTextInputOnVirtualKeyDownCallbackType);
        pub(crate) fn AzNumberInput_withOnVirtualKeyDown(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzTextInputOnVirtualKeyDownCallbackType) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setOnFocusLost(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzNumberInputOnFocusLostCallbackType);
        pub(crate) fn AzNumberInput_withOnFocusLost(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzNumberInputOnFocusLostCallbackType) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setPlaceholderStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzNumberInput_withPlaceholderStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setContainerStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzNumberInput_withContainerStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setLabelStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzNumberInput_withLabelStyle(_:  &mut AzNumberInput, _:  AzNodeDataInlineCssPropertyVec) -> AzNumberInput;
        pub(crate) fn AzNumberInput_setOnValueChange(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzNumberInputOnValueChangeCallbackType);
        pub(crate) fn AzNumberInput_withOnValueChange(_:  &mut AzNumberInput, _:  AzRefAny, _:  AzNumberInputOnValueChangeCallbackType) -> AzNumberInput;
        pub(crate) fn AzNumberInput_dom(_:  &mut AzNumberInput) -> AzDom;
        pub(crate) fn AzProgressBar_new(_:  f32) -> AzProgressBar;
        pub(crate) fn AzProgressBar_setHeight(_:  &mut AzProgressBar, _:  AzPixelValue);
        pub(crate) fn AzProgressBar_withHeight(_:  &mut AzProgressBar, _:  AzPixelValue) -> AzProgressBar;
        pub(crate) fn AzProgressBar_setContainerBackground(_:  &mut AzProgressBar, _:  AzStyleBackgroundContentVec);
        pub(crate) fn AzProgressBar_withContainerStyle(_:  &mut AzProgressBar, _:  AzStyleBackgroundContentVec) -> AzProgressBar;
        pub(crate) fn AzProgressBar_setBarBackground(_:  &mut AzProgressBar, _:  AzStyleBackgroundContentVec);
        pub(crate) fn AzProgressBar_withBarBackground(_:  &mut AzProgressBar, _:  AzStyleBackgroundContentVec) -> AzProgressBar;
        pub(crate) fn AzProgressBar_dom(_:  &mut AzProgressBar) -> AzDom;
        pub(crate) fn AzTabContainer_new(_:  AzTabVec) -> AzTabContainer;
        pub(crate) fn AzTabContainer_setActiveTab(_:  &mut AzTabContainer, _:  usize);
        pub(crate) fn AzTabContainer_withActiveTab(_:  &mut AzTabContainer, _:  usize) -> AzTabContainer;
        pub(crate) fn AzTabContainer_setPadding(_:  &mut AzTabContainer, _:  bool);
        pub(crate) fn AzTabContainer_withPadding(_:  &mut AzTabContainer, _:  bool) -> AzTabContainer;
        pub(crate) fn AzTabContainer_dom(_:  &mut AzTabContainer) -> AzDom;
        pub(crate) fn AzFrame_new(_:  AzString, _:  AzDom) -> AzFrame;
        pub(crate) fn AzFrame_setFlexGrow(_:  &mut AzFrame, _:  f32);
        pub(crate) fn AzFrame_withFlexGrow(_:  &mut AzFrame, _:  f32) -> AzFrame;
        pub(crate) fn AzFrame_dom(_:  &mut AzFrame) -> AzDom;
        pub(crate) fn AzNodeGraph_dom(_:  &mut AzNodeGraph) -> AzDom;
        pub(crate) fn AzListView_new(_:  AzStringVec) -> AzListView;
        pub(crate) fn AzListView_dom(_:  &mut AzListView) -> AzDom;
        pub(crate) fn AzTreeView_new(_:  AzString) -> AzTreeView;
        pub(crate) fn AzTreeView_dom(_:  &mut AzTreeView) -> AzDom;
        pub(crate) fn AzDropDown_new(_:  AzStringVec) -> AzDropDown;
        pub(crate) fn AzDropDown_dom(_:  &mut AzDropDown) -> AzDom;
        pub(crate) fn AzCssPropertyCache_delete(_:  &mut AzCssPropertyCache);
        pub(crate) fn AzCssPropertyCache_deepCopy(_:  &AzCssPropertyCache) -> AzCssPropertyCache;
        pub(crate) fn AzStyledDom_new(_:  AzDom, _:  AzCss) -> AzStyledDom;
        pub(crate) fn AzStyledDom_default() -> AzStyledDom;
        pub(crate) fn AzStyledDom_fromXml(_:  AzString) -> AzStyledDom;
        pub(crate) fn AzStyledDom_fromFile(_:  AzString) -> AzStyledDom;
        pub(crate) fn AzStyledDom_appendChild(_:  &mut AzStyledDom, _:  AzStyledDom);
        pub(crate) fn AzStyledDom_restyle(_:  &mut AzStyledDom, _:  AzCss);
        pub(crate) fn AzStyledDom_nodeCount(_:  &AzStyledDom) -> usize;
        pub(crate) fn AzStyledDom_getHtmlString(_:  &AzStyledDom) -> AzString;
        pub(crate) fn AzStyledDom_getHtmlStringTest(_:  &AzStyledDom) -> AzString;
        pub(crate) fn AzStyledDom_setMenuBar(_:  &mut AzStyledDom, _:  AzMenu);
        pub(crate) fn AzStyledDom_withMenuBar(_:  &mut AzStyledDom, _:  AzMenu) -> AzStyledDom;
        pub(crate) fn AzStyledDom_setContextMenu(_:  &mut AzStyledDom, _:  AzMenu);
        pub(crate) fn AzStyledDom_withContextMenu(_:  &mut AzStyledDom, _:  AzMenu) -> AzStyledDom;
        pub(crate) fn AzTexture_new(_:  u32, _:  AzTextureFlags, _:  AzPhysicalSizeU32, _:  AzColorU, _:  AzGl, _:  AzRawImageFormat) -> AzTexture;
        pub(crate) fn AzTexture_allocateRgba8(_:  AzGl, _:  AzPhysicalSizeU32, _:  AzColorU) -> AzTexture;
        pub(crate) fn AzTexture_allocateClipMask(_:  AzGl, _:  AzPhysicalSizeU32, _:  AzColorU) -> AzTexture;
        pub(crate) fn AzTexture_clear(_:  &mut AzTexture);
        pub(crate) fn AzTexture_drawClipMask(_:  &mut AzTexture, _:  AzTessellatedSvgNode) -> bool;
        pub(crate) fn AzTexture_drawTesselatedSvgGpuNode(_:  &mut AzTexture, _:  *const AzTessellatedGPUSvgNode, _:  AzPhysicalSizeU32, _:  AzColorU, _:  AzStyleTransformVec) -> bool;
        pub(crate) fn AzTexture_applyFxaa(_:  &mut AzTexture) -> bool;
        pub(crate) fn AzTexture_delete(_:  &mut AzTexture);
        pub(crate) fn AzTexture_deepCopy(_:  &AzTexture) -> AzTexture;
        pub(crate) fn AzGlVoidPtrConst_delete(_:  &mut AzGlVoidPtrConst);
        pub(crate) fn AzGlVoidPtrConst_deepCopy(_:  &AzGlVoidPtrConst) -> AzGlVoidPtrConst;
        pub(crate) fn AzGl_getType(_:  &AzGl) -> AzGlType;
        pub(crate) fn AzGl_bufferDataUntyped(_:  &AzGl, _:  u32, _:  isize, _:  AzGlVoidPtrConst, _:  u32);
        pub(crate) fn AzGl_bufferSubDataUntyped(_:  &AzGl, _:  u32, _:  isize, _:  isize, _:  AzGlVoidPtrConst);
        pub(crate) fn AzGl_mapBuffer(_:  &AzGl, _:  u32, _:  u32) -> AzGlVoidPtrMut;
        pub(crate) fn AzGl_mapBufferRange(_:  &AzGl, _:  u32, _:  isize, _:  isize, _:  u32) -> AzGlVoidPtrMut;
        pub(crate) fn AzGl_unmapBuffer(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_texBuffer(_:  &AzGl, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_shaderSource(_:  &AzGl, _:  u32, _:  AzStringVec);
        pub(crate) fn AzGl_readBuffer(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_readPixelsIntoBuffer(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  AzU8VecRefMut);
        pub(crate) fn AzGl_readPixels(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32) -> AzU8Vec;
        pub(crate) fn AzGl_readPixelsIntoPbo(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32);
        pub(crate) fn AzGl_sampleCoverage(_:  &AzGl, _:  f32, _:  bool);
        pub(crate) fn AzGl_polygonOffset(_:  &AzGl, _:  f32, _:  f32);
        pub(crate) fn AzGl_pixelStoreI(_:  &AzGl, _:  u32, _:  i32);
        pub(crate) fn AzGl_genBuffers(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_genRenderbuffers(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_genFramebuffers(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_genTextures(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_genVertexArrays(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_genQueries(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_beginQuery(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_endQuery(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_queryCounter(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_getQueryObjectIv(_:  &AzGl, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getQueryObjectUiv(_:  &AzGl, _:  u32, _:  u32) -> u32;
        pub(crate) fn AzGl_getQueryObjectI64V(_:  &AzGl, _:  u32, _:  u32) -> i64;
        pub(crate) fn AzGl_getQueryObjectUi64V(_:  &AzGl, _:  u32, _:  u32) -> u64;
        pub(crate) fn AzGl_deleteQueries(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_deleteVertexArrays(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_deleteBuffers(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_deleteRenderbuffers(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_deleteFramebuffers(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_deleteTextures(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_framebufferRenderbuffer(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_renderbufferStorage(_:  &AzGl, _:  u32, _:  u32, _:  i32, _:  i32);
        pub(crate) fn AzGl_depthFunc(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_activeTexture(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_attachShader(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindAttribLocation(_:  &AzGl, _:  u32, _:  u32, _:  AzRefstr);
        pub(crate) fn AzGl_getUniformIv(_:  &AzGl, _:  u32, _:  i32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getUniformFv(_:  &AzGl, _:  u32, _:  i32, _:  AzGLfloatVecRefMut);
        pub(crate) fn AzGl_getUniformBlockIndex(_:  &AzGl, _:  u32, _:  AzRefstr) -> u32;
        pub(crate) fn AzGl_getUniformIndices(_:  &AzGl, _:  u32, _:  AzRefstrVecRef) -> AzGLuintVec;
        pub(crate) fn AzGl_bindBufferBase(_:  &AzGl, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindBufferRange(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  isize, _:  isize);
        pub(crate) fn AzGl_uniformBlockBinding(_:  &AzGl, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindBuffer(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindVertexArray(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_bindRenderbuffer(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindFramebuffer(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_bindTexture(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_drawBuffers(_:  &AzGl, _:  AzGLenumVecRef);
        pub(crate) fn AzGl_texImage2D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  AzOptionU8VecRef);
        pub(crate) fn AzGl_compressedTexImage2D(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  i32, _:  i32, _:  i32, _:  AzU8VecRef);
        pub(crate) fn AzGl_compressedTexSubImage2D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  AzU8VecRef);
        pub(crate) fn AzGl_texImage3D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  AzOptionU8VecRef);
        pub(crate) fn AzGl_copyTexImage2D(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_copyTexSubImage2D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_copyTexSubImage3D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_texSubImage2D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  AzU8VecRef);
        pub(crate) fn AzGl_texSubImage2DPbo(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  usize);
        pub(crate) fn AzGl_texSubImage3D(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  AzU8VecRef);
        pub(crate) fn AzGl_texSubImage3DPbo(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  usize);
        pub(crate) fn AzGl_texStorage2D(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  i32, _:  i32);
        pub(crate) fn AzGl_texStorage3D(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_getTexImageIntoBuffer(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  AzU8VecRefMut);
        pub(crate) fn AzGl_copyImageSubData(_:  &AzGl, _:  u32, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_invalidateFramebuffer(_:  &AzGl, _:  u32, _:  AzGLenumVecRef);
        pub(crate) fn AzGl_invalidateSubFramebuffer(_:  &AzGl, _:  u32, _:  AzGLenumVecRef, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_getIntegerV(_:  &AzGl, _:  u32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getInteger64V(_:  &AzGl, _:  u32, _:  AzGLint64VecRefMut);
        pub(crate) fn AzGl_getIntegerIv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getInteger64Iv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLint64VecRefMut);
        pub(crate) fn AzGl_getBooleanV(_:  &AzGl, _:  u32, _:  AzGLbooleanVecRefMut);
        pub(crate) fn AzGl_getFloatV(_:  &AzGl, _:  u32, _:  AzGLfloatVecRefMut);
        pub(crate) fn AzGl_getFramebufferAttachmentParameterIv(_:  &AzGl, _:  u32, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getRenderbufferParameterIv(_:  &AzGl, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getTexParameterIv(_:  &AzGl, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getTexParameterFv(_:  &AzGl, _:  u32, _:  u32) -> f32;
        pub(crate) fn AzGl_texParameterI(_:  &AzGl, _:  u32, _:  u32, _:  i32);
        pub(crate) fn AzGl_texParameterF(_:  &AzGl, _:  u32, _:  u32, _:  f32);
        pub(crate) fn AzGl_framebufferTexture2D(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  u32, _:  i32);
        pub(crate) fn AzGl_framebufferTextureLayer(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  i32, _:  i32);
        pub(crate) fn AzGl_blitFramebuffer(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u32, _:  u32);
        pub(crate) fn AzGl_vertexAttrib4F(_:  &AzGl, _:  u32, _:  f32, _:  f32, _:  f32, _:  f32);
        pub(crate) fn AzGl_vertexAttribPointerF32(_:  &AzGl, _:  u32, _:  i32, _:  bool, _:  i32, _:  u32);
        pub(crate) fn AzGl_vertexAttribPointer(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  bool, _:  i32, _:  u32);
        pub(crate) fn AzGl_vertexAttribIPointer(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  i32, _:  u32);
        pub(crate) fn AzGl_vertexAttribDivisor(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_viewport(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_scissor(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_lineWidth(_:  &AzGl, _:  f32);
        pub(crate) fn AzGl_useProgram(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_validateProgram(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_drawArrays(_:  &AzGl, _:  u32, _:  i32, _:  i32);
        pub(crate) fn AzGl_drawArraysInstanced(_:  &AzGl, _:  u32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_drawElements(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32);
        pub(crate) fn AzGl_drawElementsInstanced(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  i32);
        pub(crate) fn AzGl_blendColor(_:  &AzGl, _:  f32, _:  f32, _:  f32, _:  f32);
        pub(crate) fn AzGl_blendFunc(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_blendFuncSeparate(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_blendEquation(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_blendEquationSeparate(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_colorMask(_:  &AzGl, _:  bool, _:  bool, _:  bool, _:  bool);
        pub(crate) fn AzGl_cullFace(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_frontFace(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_enable(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_disable(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_hint(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_isEnabled(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_isShader(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_isTexture(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_isFramebuffer(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_isRenderbuffer(_:  &AzGl, _:  u32) -> u8;
        pub(crate) fn AzGl_checkFrameBufferStatus(_:  &AzGl, _:  u32) -> u32;
        pub(crate) fn AzGl_enableVertexAttribArray(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_disableVertexAttribArray(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_uniform1F(_:  &AzGl, _:  i32, _:  f32);
        pub(crate) fn AzGl_uniform1Fv(_:  &AzGl, _:  i32, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniform1I(_:  &AzGl, _:  i32, _:  i32);
        pub(crate) fn AzGl_uniform1Iv(_:  &AzGl, _:  i32, _:  AzI32VecRef);
        pub(crate) fn AzGl_uniform1Ui(_:  &AzGl, _:  i32, _:  u32);
        pub(crate) fn AzGl_uniform2F(_:  &AzGl, _:  i32, _:  f32, _:  f32);
        pub(crate) fn AzGl_uniform2Fv(_:  &AzGl, _:  i32, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniform2I(_:  &AzGl, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_uniform2Iv(_:  &AzGl, _:  i32, _:  AzI32VecRef);
        pub(crate) fn AzGl_uniform2Ui(_:  &AzGl, _:  i32, _:  u32, _:  u32);
        pub(crate) fn AzGl_uniform3F(_:  &AzGl, _:  i32, _:  f32, _:  f32, _:  f32);
        pub(crate) fn AzGl_uniform3Fv(_:  &AzGl, _:  i32, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniform3I(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_uniform3Iv(_:  &AzGl, _:  i32, _:  AzI32VecRef);
        pub(crate) fn AzGl_uniform3Ui(_:  &AzGl, _:  i32, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_uniform4F(_:  &AzGl, _:  i32, _:  f32, _:  f32, _:  f32, _:  f32);
        pub(crate) fn AzGl_uniform4I(_:  &AzGl, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32);
        pub(crate) fn AzGl_uniform4Iv(_:  &AzGl, _:  i32, _:  AzI32VecRef);
        pub(crate) fn AzGl_uniform4Ui(_:  &AzGl, _:  i32, _:  u32, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_uniform4Fv(_:  &AzGl, _:  i32, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniformMatrix2Fv(_:  &AzGl, _:  i32, _:  bool, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniformMatrix3Fv(_:  &AzGl, _:  i32, _:  bool, _:  AzF32VecRef);
        pub(crate) fn AzGl_uniformMatrix4Fv(_:  &AzGl, _:  i32, _:  bool, _:  AzF32VecRef);
        pub(crate) fn AzGl_depthMask(_:  &AzGl, _:  bool);
        pub(crate) fn AzGl_depthRange(_:  &AzGl, _:  f64, _:  f64);
        pub(crate) fn AzGl_getActiveAttrib(_:  &AzGl, _:  u32, _:  u32) -> AzGetActiveAttribReturn;
        pub(crate) fn AzGl_getActiveUniform(_:  &AzGl, _:  u32, _:  u32) -> AzGetActiveUniformReturn;
        pub(crate) fn AzGl_getActiveUniformsIv(_:  &AzGl, _:  u32, _:  AzGLuintVec, _:  u32) -> AzGLintVec;
        pub(crate) fn AzGl_getActiveUniformBlockI(_:  &AzGl, _:  u32, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getActiveUniformBlockIv(_:  &AzGl, _:  u32, _:  u32, _:  u32) -> AzGLintVec;
        pub(crate) fn AzGl_getActiveUniformBlockName(_:  &AzGl, _:  u32, _:  u32) -> AzString;
        pub(crate) fn AzGl_getAttribLocation(_:  &AzGl, _:  u32, _:  AzRefstr) -> i32;
        pub(crate) fn AzGl_getFragDataLocation(_:  &AzGl, _:  u32, _:  AzRefstr) -> i32;
        pub(crate) fn AzGl_getUniformLocation(_:  &AzGl, _:  u32, _:  AzRefstr) -> i32;
        pub(crate) fn AzGl_getProgramInfoLog(_:  &AzGl, _:  u32) -> AzString;
        pub(crate) fn AzGl_getProgramIv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getProgramBinary(_:  &AzGl, _:  u32) -> AzGetProgramBinaryReturn;
        pub(crate) fn AzGl_programBinary(_:  &AzGl, _:  u32, _:  u32, _:  AzU8VecRef);
        pub(crate) fn AzGl_programParameterI(_:  &AzGl, _:  u32, _:  u32, _:  i32);
        pub(crate) fn AzGl_getVertexAttribIv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getVertexAttribFv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLfloatVecRefMut);
        pub(crate) fn AzGl_getVertexAttribPointerV(_:  &AzGl, _:  u32, _:  u32) -> isize;
        pub(crate) fn AzGl_getBufferParameterIv(_:  &AzGl, _:  u32, _:  u32) -> i32;
        pub(crate) fn AzGl_getShaderInfoLog(_:  &AzGl, _:  u32) -> AzString;
        pub(crate) fn AzGl_getString(_:  &AzGl, _:  u32) -> AzString;
        pub(crate) fn AzGl_getStringI(_:  &AzGl, _:  u32, _:  u32) -> AzString;
        pub(crate) fn AzGl_getShaderIv(_:  &AzGl, _:  u32, _:  u32, _:  AzGLintVecRefMut);
        pub(crate) fn AzGl_getShaderPrecisionFormat(_:  &AzGl, _:  u32, _:  u32) -> AzGlShaderPrecisionFormatReturn;
        pub(crate) fn AzGl_compileShader(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_createProgram(_:  &AzGl) -> u32;
        pub(crate) fn AzGl_deleteProgram(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_createShader(_:  &AzGl, _:  u32) -> u32;
        pub(crate) fn AzGl_deleteShader(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_detachShader(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_linkProgram(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_clearColor(_:  &AzGl, _:  f32, _:  f32, _:  f32, _:  f32);
        pub(crate) fn AzGl_clear(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_clearDepth(_:  &AzGl, _:  f64);
        pub(crate) fn AzGl_clearStencil(_:  &AzGl, _:  i32);
        pub(crate) fn AzGl_flush(_:  &AzGl);
        pub(crate) fn AzGl_finish(_:  &AzGl);
        pub(crate) fn AzGl_getError(_:  &AzGl) -> u32;
        pub(crate) fn AzGl_stencilMask(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_stencilMaskSeparate(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_stencilFunc(_:  &AzGl, _:  u32, _:  i32, _:  u32);
        pub(crate) fn AzGl_stencilFuncSeparate(_:  &AzGl, _:  u32, _:  u32, _:  i32, _:  u32);
        pub(crate) fn AzGl_stencilOp(_:  &AzGl, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_stencilOpSeparate(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  u32);
        pub(crate) fn AzGl_eglImageTargetTexture2DOes(_:  &AzGl, _:  u32, _:  AzGlVoidPtrConst);
        pub(crate) fn AzGl_generateMipmap(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_insertEventMarkerExt(_:  &AzGl, _:  AzRefstr);
        pub(crate) fn AzGl_pushGroupMarkerExt(_:  &AzGl, _:  AzRefstr);
        pub(crate) fn AzGl_popGroupMarkerExt(_:  &AzGl);
        pub(crate) fn AzGl_debugMessageInsertKhr(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  u32, _:  AzRefstr);
        pub(crate) fn AzGl_pushDebugGroupKhr(_:  &AzGl, _:  u32, _:  u32, _:  AzRefstr);
        pub(crate) fn AzGl_popDebugGroupKhr(_:  &AzGl);
        pub(crate) fn AzGl_fenceSync(_:  &AzGl, _:  u32, _:  u32) -> AzGLsyncPtr;
        pub(crate) fn AzGl_clientWaitSync(_:  &AzGl, _:  AzGLsyncPtr, _:  u32, _:  u64) -> u32;
        pub(crate) fn AzGl_waitSync(_:  &AzGl, _:  AzGLsyncPtr, _:  u32, _:  u64);
        pub(crate) fn AzGl_deleteSync(_:  &AzGl, _:  AzGLsyncPtr);
        pub(crate) fn AzGl_textureRangeApple(_:  &AzGl, _:  u32, _:  AzU8VecRef);
        pub(crate) fn AzGl_genFencesApple(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_deleteFencesApple(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_setFenceApple(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_finishFenceApple(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_testFenceApple(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_testObjectApple(_:  &AzGl, _:  u32, _:  u32) -> u8;
        pub(crate) fn AzGl_finishObjectApple(_:  &AzGl, _:  u32, _:  u32);
        pub(crate) fn AzGl_getFragDataIndex(_:  &AzGl, _:  u32, _:  AzRefstr) -> i32;
        pub(crate) fn AzGl_blendBarrierKhr(_:  &AzGl);
        pub(crate) fn AzGl_bindFragDataLocationIndexed(_:  &AzGl, _:  u32, _:  u32, _:  u32, _:  AzRefstr);
        pub(crate) fn AzGl_getDebugMessages(_:  &AzGl) -> AzDebugMessageVec;
        pub(crate) fn AzGl_provokingVertexAngle(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_genVertexArraysApple(_:  &AzGl, _:  i32) -> AzGLuintVec;
        pub(crate) fn AzGl_bindVertexArrayApple(_:  &AzGl, _:  u32);
        pub(crate) fn AzGl_deleteVertexArraysApple(_:  &AzGl, _:  AzGLuintVecRef);
        pub(crate) fn AzGl_copyTextureChromium(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  i32, _:  i32, _:  u32, _:  u8, _:  u8, _:  u8);
        pub(crate) fn AzGl_copySubTextureChromium(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u8, _:  u8, _:  u8);
        pub(crate) fn AzGl_eglImageTargetRenderbufferStorageOes(_:  &AzGl, _:  u32, _:  AzGlVoidPtrConst);
        pub(crate) fn AzGl_copyTexture3DAngle(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  i32, _:  i32, _:  u32, _:  u8, _:  u8, _:  u8);
        pub(crate) fn AzGl_copySubTexture3DAngle(_:  &AzGl, _:  u32, _:  i32, _:  u32, _:  u32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  i32, _:  u8, _:  u8, _:  u8);
        pub(crate) fn AzGl_bufferStorage(_:  &AzGl, _:  u32, _:  isize, _:  AzGlVoidPtrConst, _:  u32);
        pub(crate) fn AzGl_flushMappedBufferRange(_:  &AzGl, _:  u32, _:  isize, _:  isize);
        pub(crate) fn AzGl_delete(_:  &mut AzGl);
        pub(crate) fn AzGl_deepCopy(_:  &AzGl) -> AzGl;
        pub(crate) fn AzVertexArrayObject_new(_:  AzVertexLayout, _:  u32, _:  AzGl) -> AzVertexArrayObject;
        pub(crate) fn AzVertexArrayObject_delete(_:  &mut AzVertexArrayObject);
        pub(crate) fn AzVertexArrayObject_deepCopy(_:  &AzVertexArrayObject) -> AzVertexArrayObject;
        pub(crate) fn AzVertexBuffer_new(_:  u32, _:  usize, _:  AzVertexArrayObject, _:  u32, _:  usize, _:  AzIndexBufferFormat) -> AzVertexBuffer;
        pub(crate) fn AzVertexBuffer_delete(_:  &mut AzVertexBuffer);
        pub(crate) fn AzVertexBuffer_deepCopy(_:  &AzVertexBuffer) -> AzVertexBuffer;
        pub(crate) fn AzGLsyncPtr_delete(_:  &mut AzGLsyncPtr);
        pub(crate) fn AzGLsyncPtr_deepCopy(_:  &AzGLsyncPtr) -> AzGLsyncPtr;
        pub(crate) fn AzTextureFlags_default() -> AzTextureFlags;
        pub(crate) fn AzImageRef_invalid(_:  usize, _:  usize, _:  AzRawImageFormat) -> AzImageRef;
        pub(crate) fn AzImageRef_rawImage(_:  AzRawImage) -> AzOptionImageRef;
        pub(crate) fn AzImageRef_glTexture(_:  AzTexture) -> AzImageRef;
        pub(crate) fn AzImageRef_callback(_:  AzRefAny, _:  AzRenderImageCallbackType) -> AzImageRef;
        pub(crate) fn AzImageRef_cloneBytes(_:  &AzImageRef) -> AzImageRef;
        pub(crate) fn AzImageRef_isInvalid(_:  &AzImageRef) -> bool;
        pub(crate) fn AzImageRef_isGlTexture(_:  &AzImageRef) -> bool;
        pub(crate) fn AzImageRef_isRawImage(_:  &AzImageRef) -> bool;
        pub(crate) fn AzImageRef_isCallback(_:  &AzImageRef) -> bool;
        pub(crate) fn AzImageRef_getRawImage(_:  &AzImageRef) -> AzOptionRawImage;
        pub(crate) fn AzImageRef_getHash(_:  &AzImageRef) -> u64;
        pub(crate) fn AzImageRef_delete(_:  &mut AzImageRef);
        pub(crate) fn AzImageRef_deepCopy(_:  &AzImageRef) -> AzImageRef;
        pub(crate) fn AzRawImage_empty() -> AzRawImage;
        pub(crate) fn AzRawImage_allocateClipMask(_:  AzLayoutSize) -> AzRawImage;
        pub(crate) fn AzRawImage_decodeImageBytesAny(_:  AzU8VecRef) -> AzResultRawImageDecodeImageError;
        pub(crate) fn AzRawImage_drawClipMask(_:  &mut AzRawImage, _:  AzSvgNode, _:  AzSvgStyle) -> bool;
        pub(crate) fn AzRawImage_encodeBmp(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodePng(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodeJpeg(_:  &AzRawImage, _:  u8) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodeTga(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodePnm(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodeGif(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzRawImage_encodeTiff(_:  &AzRawImage) -> AzResultU8VecEncodeImageError;
        pub(crate) fn AzFontMetrics_zero() -> AzFontMetrics;
        pub(crate) fn AzFontMetrics_useTypoMetrics(_:  &AzFontMetrics) -> bool;
        pub(crate) fn AzFontMetrics_getAscender(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getDescender(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getLineGap(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getXMin(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYMin(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getXMax(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYMax(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getAdvanceWidthMax(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getMinLeftSideBearing(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getMinRightSideBearing(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getXMaxExtent(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getXAvgCharWidth(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSubscriptXSize(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSubscriptYSize(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSubscriptXOffset(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSubscriptYOffset(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSuperscriptXSize(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSuperscriptYSize(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSuperscriptXOffset(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYSuperscriptYOffset(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYStrikeoutSize(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontMetrics_getYStrikeoutPosition(_:  &AzFontMetrics, _:  f32) -> f32;
        pub(crate) fn AzFontRef_parse(_:  AzFontSource) -> AzOptionFontRef;
        pub(crate) fn AzFontRef_getBytes(_:  &AzFontRef) -> AzU8Vec;
        pub(crate) fn AzFontRef_getFontMetrics(_:  &AzFontRef) -> AzFontMetrics;
        pub(crate) fn AzFontRef_shapeText(_:  &AzFontRef, _:  AzRefstr, _:  AzResolvedTextLayoutOptions) -> AzInlineText;
        pub(crate) fn AzFontRef_getHash(_:  &AzFontRef) -> u64;
        pub(crate) fn AzFontRef_delete(_:  &mut AzFontRef);
        pub(crate) fn AzFontRef_deepCopy(_:  &AzFontRef) -> AzFontRef;
        pub(crate) fn AzSvg_fromString(_:  AzString, _:  AzSvgParseOptions) -> AzResultSvgSvgParseError;
        pub(crate) fn AzSvg_fromBytes(_:  AzU8VecRef, _:  AzSvgParseOptions) -> AzResultSvgSvgParseError;
        pub(crate) fn AzSvg_getRoot(_:  &AzSvg) -> AzSvgXmlNode;
        pub(crate) fn AzSvg_render(_:  &AzSvg, _:  AzSvgRenderOptions) -> AzOptionRawImage;
        pub(crate) fn AzSvg_toString(_:  &AzSvg, _:  AzSvgStringFormatOptions) -> AzString;
        pub(crate) fn AzSvg_delete(_:  &mut AzSvg);
        pub(crate) fn AzSvg_deepCopy(_:  &AzSvg) -> AzSvg;
        pub(crate) fn AzSvgXmlNode_parseFrom(_:  AzU8VecRef, _:  AzSvgParseOptions) -> AzResultSvgXmlNodeSvgParseError;
        pub(crate) fn AzSvgXmlNode_render(_:  &AzSvgXmlNode, _:  AzSvgRenderOptions) -> AzOptionRawImage;
        pub(crate) fn AzSvgXmlNode_toString(_:  &AzSvgXmlNode, _:  AzSvgStringFormatOptions) -> AzString;
        pub(crate) fn AzSvgXmlNode_delete(_:  &mut AzSvgXmlNode);
        pub(crate) fn AzSvgXmlNode_deepCopy(_:  &AzSvgXmlNode) -> AzSvgXmlNode;
        pub(crate) fn AzSvgMultiPolygon_getBounds(_:  &AzSvgMultiPolygon) -> AzSvgRect;
        pub(crate) fn AzSvgMultiPolygon_containsPoint(_:  &AzSvgMultiPolygon, _:  AzSvgPoint, _:  AzSvgFillRule, _:  f32) -> bool;
        pub(crate) fn AzSvgMultiPolygon_tessellateFill(_:  &AzSvgMultiPolygon, _:  AzSvgFillStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgMultiPolygon_tessellateStroke(_:  &AzSvgMultiPolygon, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgNode_tessellateFill(_:  &AzSvgNode, _:  AzSvgFillStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgNode_tessellateStroke(_:  &AzSvgNode, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgStyledNode_tessellate(_:  &AzSvgStyledNode) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgCircle_tessellateFill(_:  &AzSvgCircle, _:  AzSvgFillStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgCircle_tessellateStroke(_:  &AzSvgCircle, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgPath_isClosed(_:  &AzSvgPath) -> bool;
        pub(crate) fn AzSvgPath_reverse(_:  &mut AzSvgPath);
        pub(crate) fn AzSvgPath_joinWith(_:  &mut AzSvgPath, _:  AzSvgPath);
        pub(crate) fn AzSvgPath_tessellateFill(_:  &AzSvgPath, _:  AzSvgFillStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgPath_tessellateStroke(_:  &AzSvgPath, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgPathElement_reverse(_:  &mut AzSvgPathElement);
        pub(crate) fn AzSvgPathElement_getStart(_:  &AzSvgPathElement) -> AzSvgPoint;
        pub(crate) fn AzSvgPathElement_getEnd(_:  &AzSvgPathElement) -> AzSvgPoint;
        pub(crate) fn AzSvgPathElement_getBounds(_:  &AzSvgPathElement) -> AzSvgRect;
        pub(crate) fn AzSvgPathElement_getLength(_:  &AzSvgPathElement) -> f64;
        pub(crate) fn AzSvgPathElement_getTAtOffset(_:  &AzSvgPathElement, _:  f64) -> f64;
        pub(crate) fn AzSvgPathElement_getXAtT(_:  &AzSvgPathElement, _:  f64) -> f64;
        pub(crate) fn AzSvgPathElement_getYAtT(_:  &AzSvgPathElement, _:  f64) -> f64;
        pub(crate) fn AzSvgPathElement_getTangentVectorAtT(_:  &AzSvgPathElement, _:  f64) -> AzSvgVector;
        pub(crate) fn AzSvgPathElement_tessellateStroke(_:  &AzSvgPathElement, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgVector_angleDegrees(_:  &AzSvgVector) -> f64;
        pub(crate) fn AzSvgVector_normalize(_:  &AzSvgVector) -> AzSvgVector;
        pub(crate) fn AzSvgVector_rotate90DegCcw(_:  &AzSvgVector) -> AzSvgVector;
        pub(crate) fn AzSvgLine_reverse(_:  &mut AzSvgLine);
        pub(crate) fn AzSvgLine_getStart(_:  &AzSvgLine) -> AzSvgPoint;
        pub(crate) fn AzSvgLine_getEnd(_:  &AzSvgLine) -> AzSvgPoint;
        pub(crate) fn AzSvgLine_getBounds(_:  &AzSvgLine) -> AzSvgRect;
        pub(crate) fn AzSvgLine_getLength(_:  &AzSvgLine) -> f64;
        pub(crate) fn AzSvgLine_getTAtOffset(_:  &AzSvgLine, _:  f64) -> f64;
        pub(crate) fn AzSvgLine_getXAtT(_:  &AzSvgLine, _:  f64) -> f64;
        pub(crate) fn AzSvgLine_getYAtT(_:  &AzSvgLine, _:  f64) -> f64;
        pub(crate) fn AzSvgLine_getTangentVectorAtT(_:  &AzSvgLine, _:  f64) -> AzSvgVector;
        pub(crate) fn AzSvgLine_tessellateStroke(_:  &AzSvgLine, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgQuadraticCurve_reverse(_:  &mut AzSvgQuadraticCurve);
        pub(crate) fn AzSvgQuadraticCurve_getStart(_:  &AzSvgQuadraticCurve) -> AzSvgPoint;
        pub(crate) fn AzSvgQuadraticCurve_getEnd(_:  &AzSvgQuadraticCurve) -> AzSvgPoint;
        pub(crate) fn AzSvgQuadraticCurve_getBounds(_:  &AzSvgQuadraticCurve) -> AzSvgRect;
        pub(crate) fn AzSvgQuadraticCurve_getLength(_:  &AzSvgQuadraticCurve) -> f64;
        pub(crate) fn AzSvgQuadraticCurve_getTAtOffset(_:  &AzSvgQuadraticCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgQuadraticCurve_getXAtT(_:  &AzSvgQuadraticCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgQuadraticCurve_getYAtT(_:  &AzSvgQuadraticCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgQuadraticCurve_getTangentVectorAtT(_:  &AzSvgQuadraticCurve, _:  f64) -> AzSvgVector;
        pub(crate) fn AzSvgQuadraticCurve_tessellateStroke(_:  &AzSvgQuadraticCurve, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgCubicCurve_reverse(_:  &mut AzSvgCubicCurve);
        pub(crate) fn AzSvgCubicCurve_getStart(_:  &AzSvgCubicCurve) -> AzSvgPoint;
        pub(crate) fn AzSvgCubicCurve_getEnd(_:  &AzSvgCubicCurve) -> AzSvgPoint;
        pub(crate) fn AzSvgCubicCurve_getBounds(_:  &AzSvgCubicCurve) -> AzSvgRect;
        pub(crate) fn AzSvgCubicCurve_getLength(_:  &AzSvgCubicCurve) -> f64;
        pub(crate) fn AzSvgCubicCurve_getTAtOffset(_:  &AzSvgCubicCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgCubicCurve_getXAtT(_:  &AzSvgCubicCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgCubicCurve_getYAtT(_:  &AzSvgCubicCurve, _:  f64) -> f64;
        pub(crate) fn AzSvgCubicCurve_getTangentVectorAtT(_:  &AzSvgCubicCurve, _:  f64) -> AzSvgVector;
        pub(crate) fn AzSvgCubicCurve_tessellateStroke(_:  &AzSvgCubicCurve, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgRect_getCenter(_:  &AzSvgRect) -> AzSvgPoint;
        pub(crate) fn AzSvgRect_containsPoint(_:  &AzSvgRect, _:  AzSvgPoint) -> bool;
        pub(crate) fn AzSvgRect_tessellateFill(_:  &AzSvgRect, _:  AzSvgFillStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzSvgRect_tessellateStroke(_:  &AzSvgRect, _:  AzSvgStrokeStyle) -> AzTessellatedSvgNode;
        pub(crate) fn AzTessellatedSvgNode_empty() -> AzTessellatedSvgNode;
        pub(crate) fn AzTessellatedSvgNode_fromNodes(_:  AzTessellatedSvgNodeVecRef) -> AzTessellatedSvgNode;
        pub(crate) fn AzTessellatedGPUSvgNode_new(_:  *const AzTessellatedSvgNode, _:  AzGl) -> AzTessellatedGPUSvgNode;
        pub(crate) fn AzSvgParseOptions_default() -> AzSvgParseOptions;
        pub(crate) fn AzSvgRenderOptions_default() -> AzSvgRenderOptions;
        pub(crate) fn AzSvgFillStyle_default() -> AzSvgFillStyle;
        pub(crate) fn AzSvgStrokeStyle_default() -> AzSvgStrokeStyle;
        pub(crate) fn AzXml_fromStr(_:  AzRefstr) -> AzResultXmlXmlError;
        pub(crate) fn AzFile_open(_:  AzString) -> AzOptionFile;
        pub(crate) fn AzFile_create(_:  AzString) -> AzOptionFile;
        pub(crate) fn AzFile_readToString(_:  &mut AzFile) -> AzOptionString;
        pub(crate) fn AzFile_readToBytes(_:  &mut AzFile) -> AzOptionU8Vec;
        pub(crate) fn AzFile_writeString(_:  &mut AzFile, _:  AzRefstr) -> bool;
        pub(crate) fn AzFile_writeBytes(_:  &mut AzFile, _:  AzU8VecRef) -> bool;
        pub(crate) fn AzFile_close(_:  &mut AzFile);
        pub(crate) fn AzFile_delete(_:  &mut AzFile);
        pub(crate) fn AzFile_deepCopy(_:  &AzFile) -> AzFile;
        pub(crate) fn AzMsgBox_ok(_:  AzMsgBoxIcon, _:  AzString, _:  AzString) -> bool;
        pub(crate) fn AzMsgBox_info(_:  AzString) -> bool;
        pub(crate) fn AzMsgBox_warning(_:  AzString) -> bool;
        pub(crate) fn AzMsgBox_error(_:  AzString) -> bool;
        pub(crate) fn AzMsgBox_question(_:  AzString) -> bool;
        pub(crate) fn AzMsgBox_okCancel(_:  AzMsgBoxIcon, _:  AzString, _:  AzString, _:  AzMsgBoxOkCancel) -> AzMsgBoxOkCancel;
        pub(crate) fn AzMsgBox_yesNo(_:  AzMsgBoxIcon, _:  AzString, _:  AzString, _:  AzMsgBoxYesNo) -> AzMsgBoxYesNo;
        pub(crate) fn AzFileDialog_selectFile(_:  AzString, _:  AzOptionString, _:  AzOptionFileTypeList) -> AzOptionString;
        pub(crate) fn AzFileDialog_selectMultipleFiles(_:  AzString, _:  AzOptionString, _:  AzOptionFileTypeList) -> AzOptionStringVec;
        pub(crate) fn AzFileDialog_selectFolder(_:  AzString, _:  AzOptionString) -> AzOptionString;
        pub(crate) fn AzFileDialog_saveFile(_:  AzString, _:  AzOptionString) -> AzOptionString;
        pub(crate) fn AzColorPickerDialog_open(_:  AzString, _:  AzOptionColorU) -> AzOptionColorU;
        pub(crate) fn AzSystemClipboard_new() -> AzOptionSystemClipboard;
        pub(crate) fn AzSystemClipboard_getStringContents(_:  &AzSystemClipboard) -> AzOptionString;
        pub(crate) fn AzSystemClipboard_setStringContents(_:  &mut AzSystemClipboard, _:  AzString) -> bool;
        pub(crate) fn AzSystemClipboard_delete(_:  &mut AzSystemClipboard);
        pub(crate) fn AzSystemClipboard_deepCopy(_:  &AzSystemClipboard) -> AzSystemClipboard;
        pub(crate) fn AzInstant_durationSince(_:  &AzInstant, _:  AzInstant) -> AzOptionDuration;
        pub(crate) fn AzInstant_addDuration(_:  &mut AzInstant, _:  AzDuration) -> AzInstant;
        pub(crate) fn AzInstant_linearInterpolate(_:  &AzInstant, _:  AzInstant, _:  AzInstant) -> f32;
        pub(crate) fn AzInstantPtr_delete(_:  &mut AzInstantPtr);
        pub(crate) fn AzInstantPtr_deepCopy(_:  &AzInstantPtr) -> AzInstantPtr;
        pub(crate) fn AzTimer_new(_:  AzRefAny, _:  AzTimerCallbackType, _:  AzGetSystemTimeFn) -> AzTimer;
        pub(crate) fn AzTimer_withDelay(_:  &AzTimer, _:  AzDuration) -> AzTimer;
        pub(crate) fn AzTimer_withInterval(_:  &AzTimer, _:  AzDuration) -> AzTimer;
        pub(crate) fn AzTimer_withTimeout(_:  &AzTimer, _:  AzDuration) -> AzTimer;
        pub(crate) fn AzThread_delete(_:  &mut AzThread);
        pub(crate) fn AzThread_deepCopy(_:  &AzThread) -> AzThread;
        pub(crate) fn AzThreadSender_send(_:  &mut AzThreadSender, _:  AzThreadReceiveMsg) -> bool;
        pub(crate) fn AzThreadSender_delete(_:  &mut AzThreadSender);
        pub(crate) fn AzThreadSender_deepCopy(_:  &AzThreadSender) -> AzThreadSender;
        pub(crate) fn AzThreadReceiver_receive(_:  &mut AzThreadReceiver) -> AzOptionThreadSendMsg;
        pub(crate) fn AzThreadReceiver_delete(_:  &mut AzThreadReceiver);
        pub(crate) fn AzThreadReceiver_deepCopy(_:  &AzThreadReceiver) -> AzThreadReceiver;
        pub(crate) fn AzString_format(_:  AzString, _:  AzFmtArgVec) -> AzString;
        pub(crate) fn AzString_copyFromBytes(_:  *const u8, _:  usize, _:  usize) -> AzString;
        pub(crate) fn AzString_trim(_:  &AzString) -> AzString;
        pub(crate) fn AzString_asRefstr(_:  &AzString) -> AzRefstr;
        pub(crate) fn AzStyleFilterVec_delete(_:  &mut AzStyleFilterVec);
        pub(crate) fn AzLogicalRectVec_delete(_:  &mut AzLogicalRectVec);
        pub(crate) fn AzNodeTypeIdInfoMapVec_delete(_:  &mut AzNodeTypeIdInfoMapVec);
        pub(crate) fn AzInputOutputTypeIdInfoMapVec_delete(_:  &mut AzInputOutputTypeIdInfoMapVec);
        pub(crate) fn AzNodeIdNodeMapVec_delete(_:  &mut AzNodeIdNodeMapVec);
        pub(crate) fn AzInputOutputTypeIdVec_delete(_:  &mut AzInputOutputTypeIdVec);
        pub(crate) fn AzNodeTypeFieldVec_delete(_:  &mut AzNodeTypeFieldVec);
        pub(crate) fn AzInputConnectionVec_delete(_:  &mut AzInputConnectionVec);
        pub(crate) fn AzOutputNodeAndIndexVec_delete(_:  &mut AzOutputNodeAndIndexVec);
        pub(crate) fn AzOutputConnectionVec_delete(_:  &mut AzOutputConnectionVec);
        pub(crate) fn AzInputNodeAndIndexVec_delete(_:  &mut AzInputNodeAndIndexVec);
        pub(crate) fn AzTabVec_delete(_:  &mut AzTabVec);
        pub(crate) fn AzAccessibilityStateVec_delete(_:  &mut AzAccessibilityStateVec);
        pub(crate) fn AzMenuItemVec_delete(_:  &mut AzMenuItemVec);
        pub(crate) fn AzTessellatedSvgNodeVec_asRefVec(_:  &AzTessellatedSvgNodeVec) -> AzTessellatedSvgNodeVecRef;
        pub(crate) fn AzTessellatedSvgNodeVec_delete(_:  &mut AzTessellatedSvgNodeVec);
        pub(crate) fn AzStyleFontFamilyVec_delete(_:  &mut AzStyleFontFamilyVec);
        pub(crate) fn AzXmlNodeVec_delete(_:  &mut AzXmlNodeVec);
        pub(crate) fn AzFmtArgVec_delete(_:  &mut AzFmtArgVec);
        pub(crate) fn AzInlineLineVec_delete(_:  &mut AzInlineLineVec);
        pub(crate) fn AzInlineWordVec_delete(_:  &mut AzInlineWordVec);
        pub(crate) fn AzInlineGlyphVec_delete(_:  &mut AzInlineGlyphVec);
        pub(crate) fn AzInlineTextHitVec_delete(_:  &mut AzInlineTextHitVec);
        pub(crate) fn AzMonitorVec_delete(_:  &mut AzMonitorVec);
        pub(crate) fn AzVideoModeVec_delete(_:  &mut AzVideoModeVec);
        pub(crate) fn AzDomVec_delete(_:  &mut AzDomVec);
        pub(crate) fn AzIdOrClassVec_delete(_:  &mut AzIdOrClassVec);
        pub(crate) fn AzNodeDataInlineCssPropertyVec_delete(_:  &mut AzNodeDataInlineCssPropertyVec);
        pub(crate) fn AzStyleBackgroundContentVec_delete(_:  &mut AzStyleBackgroundContentVec);
        pub(crate) fn AzStyleBackgroundPositionVec_delete(_:  &mut AzStyleBackgroundPositionVec);
        pub(crate) fn AzStyleBackgroundRepeatVec_delete(_:  &mut AzStyleBackgroundRepeatVec);
        pub(crate) fn AzStyleBackgroundSizeVec_delete(_:  &mut AzStyleBackgroundSizeVec);
        pub(crate) fn AzStyleTransformVec_delete(_:  &mut AzStyleTransformVec);
        pub(crate) fn AzCssPropertyVec_delete(_:  &mut AzCssPropertyVec);
        pub(crate) fn AzSvgMultiPolygonVec_delete(_:  &mut AzSvgMultiPolygonVec);
        pub(crate) fn AzSvgPathVec_delete(_:  &mut AzSvgPathVec);
        pub(crate) fn AzVertexAttributeVec_delete(_:  &mut AzVertexAttributeVec);
        pub(crate) fn AzSvgPathElementVec_delete(_:  &mut AzSvgPathElementVec);
        pub(crate) fn AzSvgVertexVec_delete(_:  &mut AzSvgVertexVec);
        pub(crate) fn AzU32Vec_delete(_:  &mut AzU32Vec);
        pub(crate) fn AzXWindowTypeVec_delete(_:  &mut AzXWindowTypeVec);
        pub(crate) fn AzVirtualKeyCodeVec_delete(_:  &mut AzVirtualKeyCodeVec);
        pub(crate) fn AzCascadeInfoVec_delete(_:  &mut AzCascadeInfoVec);
        pub(crate) fn AzScanCodeVec_delete(_:  &mut AzScanCodeVec);
        pub(crate) fn AzCssDeclarationVec_delete(_:  &mut AzCssDeclarationVec);
        pub(crate) fn AzCssPathSelectorVec_delete(_:  &mut AzCssPathSelectorVec);
        pub(crate) fn AzStylesheetVec_delete(_:  &mut AzStylesheetVec);
        pub(crate) fn AzCssRuleBlockVec_delete(_:  &mut AzCssRuleBlockVec);
        pub(crate) fn AzU16Vec_delete(_:  &mut AzU16Vec);
        pub(crate) fn AzF32Vec_delete(_:  &mut AzF32Vec);
        pub(crate) fn AzU8Vec_copyFromBytes(_:  *const u8, _:  usize, _:  usize) -> AzU8Vec;
        pub(crate) fn AzU8Vec_asRefVec(_:  &AzU8Vec) -> AzU8VecRef;
        pub(crate) fn AzU8Vec_delete(_:  &mut AzU8Vec);
        pub(crate) fn AzCallbackDataVec_delete(_:  &mut AzCallbackDataVec);
        pub(crate) fn AzDebugMessageVec_delete(_:  &mut AzDebugMessageVec);
        pub(crate) fn AzGLuintVec_delete(_:  &mut AzGLuintVec);
        pub(crate) fn AzGLintVec_delete(_:  &mut AzGLintVec);
        pub(crate) fn AzStringVec_delete(_:  &mut AzStringVec);
        pub(crate) fn AzStringPairVec_delete(_:  &mut AzStringPairVec);
        pub(crate) fn AzNormalizedLinearColorStopVec_delete(_:  &mut AzNormalizedLinearColorStopVec);
        pub(crate) fn AzNormalizedRadialColorStopVec_delete(_:  &mut AzNormalizedRadialColorStopVec);
        pub(crate) fn AzNodeIdVec_delete(_:  &mut AzNodeIdVec);
        pub(crate) fn AzNodeHierarchyItemVec_delete(_:  &mut AzNodeHierarchyItemVec);
        pub(crate) fn AzStyledNodeVec_delete(_:  &mut AzStyledNodeVec);
        pub(crate) fn AzTagIdToNodeIdMappingVec_delete(_:  &mut AzTagIdToNodeIdMappingVec);
        pub(crate) fn AzParentWithNodeDepthVec_delete(_:  &mut AzParentWithNodeDepthVec);
        pub(crate) fn AzNodeDataVec_delete(_:  &mut AzNodeDataVec);
    }

    }

    #[cfg(not(feature = "link_static"))]
    pub use self::dynamic_link::*;


}

pub mod app {
    #![allow(dead_code, unused_imports)]
    //! `App` construction and configuration
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::callbacks::RefAny;
    use crate::window::WindowCreateOptions;
    use crate::str::String;
    use crate::image::ImageRef;
    /// Main application class
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzApp as App;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AppCrossCrateImpl { pub _0: azul::AzApp }

    #[cfg(feature = "link_static")] pub use AppCrossCrateImpl as App;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AppCrossCrateImpl { type Target = AzApp; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AppCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl App {

        /// Creates a new App instance from the given `AppConfig`
        pub fn new(data: RefAny, config: AppConfig) -> Self { unsafe { crate::dll::AzApp_new(data, config) } }
        /// Spawn a new window on the screen when the app is run.
        pub fn add_window(&mut self, window: WindowCreateOptions)  { unsafe { crate::dll::AzApp_addWindow(self, window) } }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image(&mut self, id: String, image: ImageRef)  { unsafe { crate::dll::AzApp_addImage(self, id, image) } }
        /// Returns a list of monitors - useful for setting the monitor that a window should spawn on.
        pub fn get_monitors(&self)  -> crate::vec::MonitorVec { unsafe { crate::dll::AzApp_getMonitors(self) } }
        /// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
        pub fn run(&self, window: WindowCreateOptions)  { unsafe { crate::dll::AzApp_run(self, window) } }
    }

    #[cfg(feature = "link_static")]
    impl AppCrossCrateImpl {

        /// Creates a new App instance from the given `AppConfig`
        pub fn new(data: RefAny, config: AppConfig) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzApp_new(data._0, config._0) }) } }
        /// Spawn a new window on the screen when the app is run.
        pub fn add_window(&mut self, window: WindowCreateOptions)  {  unsafe { core::mem::transmute(unsafe { azul::AzApp_addWindow(&mut self._0, window._0) }) } }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image(&mut self, id: String, image: ImageRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzApp_addImage(&mut self._0, id._0, image._0) }) } }
        /// Returns a list of monitors - useful for setting the monitor that a window should spawn on.
        pub fn get_monitors(&self)  -> crate::vec::MonitorVec {  unsafe { core::mem::transmute(unsafe { azul::AzApp_getMonitors(&self._0) }) } }
        /// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
        pub fn run(&self, window: WindowCreateOptions)  {  unsafe { core::mem::transmute(unsafe { azul::AzApp_run(&self._0, window._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for App { fn clone(&self) -> Self { unsafe { crate::dll::AzApp_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for App { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzApp_delete(self) } } } }
    /// Configuration for optional features, such as whether to enable logging or panic hooks
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAppConfig as AppConfig;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AppConfigCrossCrateImpl { pub _0: azul::AzAppConfig }

    #[cfg(feature = "link_static")] pub use AppConfigCrossCrateImpl as AppConfig;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AppConfigCrossCrateImpl { type Target = AzAppConfig; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AppConfigCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl AppConfig {

        /// Constructs a default `AppConfig`, uses the layout solver currently available
        pub fn new(layout_solver: LayoutSolver) -> Self { unsafe { crate::dll::AzAppConfig_new(layout_solver) } }
    }

    #[cfg(feature = "link_static")]
    impl AppConfigCrossCrateImpl {

        /// Constructs a default `AppConfig`, uses the layout solver currently available
        pub fn new(layout_solver: LayoutSolver) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzAppConfig_new(layout_solver._0) }) } }
    }

    /// Configuration to set which messages should be logged.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAppLogLevel as AppLogLevel;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AppLogLevelCrossCrateImpl { pub _0: azul::AzAppLogLevel }

    #[cfg(feature = "link_static")] pub use AppLogLevelCrossCrateImpl as AppLogLevel;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AppLogLevelCrossCrateImpl { type Target = AzAppLogLevel; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AppLogLevelCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Version of the layout solver to use - future binary versions of azul may have more fields here, necessary so that old compiled applications don't break with newer releases of azul. Newer layout versions are opt-in only.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutSolver as LayoutSolver;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutSolverCrossCrateImpl { pub _0: azul::AzLayoutSolver }

    #[cfg(feature = "link_static")] pub use LayoutSolverCrossCrateImpl as LayoutSolver;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutSolverCrossCrateImpl { type Target = AzLayoutSolver; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutSolverCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// External system callbacks to get the system time or create / manage threads
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSystemCallbacks as SystemCallbacks;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SystemCallbacksCrossCrateImpl { pub _0: azul::AzSystemCallbacks }

    #[cfg(feature = "link_static")] pub use SystemCallbacksCrossCrateImpl as SystemCallbacks;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SystemCallbacksCrossCrateImpl { type Target = AzSystemCallbacks; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SystemCallbacksCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SystemCallbacks {

        /// Use the default, library-internal callbacks instead of providing your own
        pub fn library_internal() -> Self { unsafe { crate::dll::AzSystemCallbacks_libraryInternal() } }
    }

    #[cfg(feature = "link_static")]
    impl SystemCallbacksCrossCrateImpl {

        /// Use the default, library-internal callbacks instead of providing your own
        pub fn library_internal() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzSystemCallbacks_libraryInternal() }) } }
    }

}

pub mod window {
    #![allow(dead_code, unused_imports)]
    //! Window creation / startup configuration
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;

    #[cfg(not(feature = "link_static"))]
    impl LayoutSize {
        #[inline(always)]
        pub const fn new(width: isize, height: isize) -> Self { Self { width, height } }
        #[inline(always)]
        pub const fn zero() -> Self { Self::new(0, 0) }
    }

    #[cfg(not(feature = "link_static"))]
    impl LayoutPoint {
        #[inline(always)]
        pub const fn new(x: isize, y: isize) -> Self { Self { x, y } }
        #[inline(always)]
        pub const fn zero() -> Self { Self::new(0, 0) }
    }

    #[cfg(not(feature = "link_static"))]
    impl LayoutRect {
        #[inline(always)]
        pub const fn new(origin: LayoutPoint, size: LayoutSize) -> Self { Self { origin, size } }
        #[inline(always)]
        pub const fn zero() -> Self { Self::new(LayoutPoint::zero(), LayoutSize::zero()) }
        #[inline(always)]
        pub const fn max_x(&self) -> isize { self.origin.x + self.size.width }
        #[inline(always)]
        pub const fn min_x(&self) -> isize { self.origin.x }
        #[inline(always)]
        pub const fn max_y(&self) -> isize { self.origin.y + self.size.height }
        #[inline(always)]
        pub const fn min_y(&self) -> isize { self.origin.y }

        pub const fn contains(&self, other: &LayoutPoint) -> bool {
            self.min_x() <= other.x && other.x < self.max_x() &&
            self.min_y() <= other.y && other.y < self.max_y()
        }

        pub fn contains_f32(&self, other_x: f32, other_y: f32) -> bool {
            self.min_x() as f32 <= other_x && other_x < self.max_x() as f32 &&
            self.min_y() as f32 <= other_y && other_y < self.max_y() as f32
        }

        /// Same as `contains()`, but returns the (x, y) offset of the hit point
        ///
        /// On a regular computer this function takes ~3.2ns to run
        #[inline]
        pub const fn hit_test(&self, other: &LayoutPoint) -> Option<LayoutPoint> {
            let dx_left_edge = other.x - self.min_x();
            let dx_right_edge = self.max_x() - other.x;
            let dy_top_edge = other.y - self.min_y();
            let dy_bottom_edge = self.max_y() - other.y;
            if dx_left_edge > 0 &&
               dx_right_edge > 0 &&
               dy_top_edge > 0 &&
               dy_bottom_edge > 0
            {
                Some(LayoutPoint::new(dx_left_edge, dy_top_edge))
            } else {
                None
            }
        }

        // Returns if b overlaps a
        #[inline(always)]
        pub const fn contains_rect(&self, b: &LayoutRect) -> bool {

            let a = self;

            let a_x         = a.origin.x;
            let a_y         = a.origin.y;
            let a_width     = a.size.width;
            let a_height    = a.size.height;

            let b_x         = b.origin.x;
            let b_y         = b.origin.y;
            let b_width     = b.size.width;
            let b_height    = b.size.height;

            b_x >= a_x &&
            b_y >= a_y &&
            b_x + b_width <= a_x + a_width &&
            b_y + b_height <= a_y + a_height
        }
    }    use crate::callbacks::LayoutCallbackType;
    /// Options on how to initially create the window
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowCreateOptions as WindowCreateOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowCreateOptionsCrossCrateImpl { pub _0: azul::AzWindowCreateOptions }

    #[cfg(feature = "link_static")] pub use WindowCreateOptionsCrossCrateImpl as WindowCreateOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowCreateOptionsCrossCrateImpl { type Target = AzWindowCreateOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowCreateOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl WindowCreateOptions {

        /// Creates a new window configuration with a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self { unsafe { crate::dll::AzWindowCreateOptions_new(layout_callback) } }
    }

    #[cfg(feature = "link_static")]
    impl WindowCreateOptionsCrossCrateImpl {

        /// Creates a new window configuration with a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzWindowCreateOptions_new(layout_callback._0) }) } }
    }

    /// Force a specific renderer: note that azul will **crash** on startup if the `RendererOptions` are not satisfied.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRendererOptions as RendererOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RendererOptionsCrossCrateImpl { pub _0: azul::AzRendererOptions }

    #[cfg(feature = "link_static")] pub use RendererOptionsCrossCrateImpl as RendererOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RendererOptionsCrossCrateImpl { type Target = AzRendererOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RendererOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Whether the renderer has VSync enabled
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVsync as Vsync;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VsyncCrossCrateImpl { pub _0: azul::AzVsync }

    #[cfg(feature = "link_static")] pub use VsyncCrossCrateImpl as Vsync;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VsyncCrossCrateImpl { type Target = AzVsync; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VsyncCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Does the renderer render in SRGB color space? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSrgb as Srgb;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SrgbCrossCrateImpl { pub _0: azul::AzSrgb }

    #[cfg(feature = "link_static")] pub use SrgbCrossCrateImpl as Srgb;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SrgbCrossCrateImpl { type Target = AzSrgb; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SrgbCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Does the renderer render using hardware acceleration? By default, azul tries to set it to `Enabled` and falls back to `Disabled` if the OpenGL context can't be initialized properly
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzHwAcceleration as HwAcceleration;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct HwAccelerationCrossCrateImpl { pub _0: azul::AzHwAcceleration }

    #[cfg(feature = "link_static")] pub use HwAccelerationCrossCrateImpl as HwAcceleration;

    #[cfg(feature = "link_static")] impl core::ops::Deref for HwAccelerationCrossCrateImpl { type Target = AzHwAcceleration; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for HwAccelerationCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Offset in physical pixels (integer units)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPoint as LayoutPoint;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPointCrossCrateImpl { pub _0: azul::AzLayoutPoint }

    #[cfg(feature = "link_static")] pub use LayoutPointCrossCrateImpl as LayoutPoint;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPointCrossCrateImpl { type Target = AzLayoutPoint; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPointCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Size in physical pixels (integer units)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutSize as LayoutSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutSizeCrossCrateImpl { pub _0: azul::AzLayoutSize }

    #[cfg(feature = "link_static")] pub use LayoutSizeCrossCrateImpl as LayoutSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutSizeCrossCrateImpl { type Target = AzLayoutSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Represents a rectangle in physical pixels (integer units)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutRect as LayoutRect;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutRectCrossCrateImpl { pub _0: azul::AzLayoutRect }

    #[cfg(feature = "link_static")] pub use LayoutRectCrossCrateImpl as LayoutRect;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutRectCrossCrateImpl { type Target = AzLayoutRect; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutRectCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Raw platform handle, for integration in / with other toolkits and custom non-azul window extensions
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRawWindowHandle as RawWindowHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RawWindowHandleCrossCrateImpl { pub _0: azul::AzRawWindowHandle }

    #[cfg(feature = "link_static")] pub use RawWindowHandleCrossCrateImpl as RawWindowHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RawWindowHandleCrossCrateImpl { type Target = AzRawWindowHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RawWindowHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `IOSHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIOSHandle as IOSHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IOSHandleCrossCrateImpl { pub _0: azul::AzIOSHandle }

    #[cfg(feature = "link_static")] pub use IOSHandleCrossCrateImpl as IOSHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IOSHandleCrossCrateImpl { type Target = AzIOSHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IOSHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MacOSHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMacOSHandle as MacOSHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MacOSHandleCrossCrateImpl { pub _0: azul::AzMacOSHandle }

    #[cfg(feature = "link_static")] pub use MacOSHandleCrossCrateImpl as MacOSHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MacOSHandleCrossCrateImpl { type Target = AzMacOSHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MacOSHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XlibHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXlibHandle as XlibHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XlibHandleCrossCrateImpl { pub _0: azul::AzXlibHandle }

    #[cfg(feature = "link_static")] pub use XlibHandleCrossCrateImpl as XlibHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XlibHandleCrossCrateImpl { type Target = AzXlibHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XlibHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XcbHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXcbHandle as XcbHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XcbHandleCrossCrateImpl { pub _0: azul::AzXcbHandle }

    #[cfg(feature = "link_static")] pub use XcbHandleCrossCrateImpl as XcbHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XcbHandleCrossCrateImpl { type Target = AzXcbHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XcbHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WaylandHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWaylandHandle as WaylandHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WaylandHandleCrossCrateImpl { pub _0: azul::AzWaylandHandle }

    #[cfg(feature = "link_static")] pub use WaylandHandleCrossCrateImpl as WaylandHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WaylandHandleCrossCrateImpl { type Target = AzWaylandHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WaylandHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WindowsHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowsHandle as WindowsHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowsHandleCrossCrateImpl { pub _0: azul::AzWindowsHandle }

    #[cfg(feature = "link_static")] pub use WindowsHandleCrossCrateImpl as WindowsHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowsHandleCrossCrateImpl { type Target = AzWindowsHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowsHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WebHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWebHandle as WebHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WebHandleCrossCrateImpl { pub _0: azul::AzWebHandle }

    #[cfg(feature = "link_static")] pub use WebHandleCrossCrateImpl as WebHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WebHandleCrossCrateImpl { type Target = AzWebHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WebHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AndroidHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAndroidHandle as AndroidHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AndroidHandleCrossCrateImpl { pub _0: azul::AzAndroidHandle }

    #[cfg(feature = "link_static")] pub use AndroidHandleCrossCrateImpl as AndroidHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AndroidHandleCrossCrateImpl { type Target = AzAndroidHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AndroidHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// X11 window hint: Type of window
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXWindowType as XWindowType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XWindowTypeCrossCrateImpl { pub _0: azul::AzXWindowType }

    #[cfg(feature = "link_static")] pub use XWindowTypeCrossCrateImpl as XWindowType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XWindowTypeCrossCrateImpl { type Target = AzXWindowType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XWindowTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Same as `LayoutPoint`, but uses `i32` instead of `isize`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPhysicalPositionI32 as PhysicalPositionI32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PhysicalPositionI32CrossCrateImpl { pub _0: azul::AzPhysicalPositionI32 }

    #[cfg(feature = "link_static")] pub use PhysicalPositionI32CrossCrateImpl as PhysicalPositionI32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PhysicalPositionI32CrossCrateImpl { type Target = AzPhysicalPositionI32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PhysicalPositionI32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Same as `LayoutPoint`, but uses `u32` instead of `isize`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPhysicalSizeU32 as PhysicalSizeU32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PhysicalSizeU32CrossCrateImpl { pub _0: azul::AzPhysicalSizeU32 }

    #[cfg(feature = "link_static")] pub use PhysicalSizeU32CrossCrateImpl as PhysicalSizeU32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PhysicalSizeU32CrossCrateImpl { type Target = AzPhysicalSizeU32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PhysicalSizeU32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Logical rectangle area (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalRect as LogicalRect;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalRectCrossCrateImpl { pub _0: azul::AzLogicalRect }

    #[cfg(feature = "link_static")] pub use LogicalRectCrossCrateImpl as LogicalRect;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalRectCrossCrateImpl { type Target = AzLogicalRect; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalRectCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Logical position (can differ based on HiDPI settings). Usually this is what you'd want for hit-testing and positioning elements.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalPosition as LogicalPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalPositionCrossCrateImpl { pub _0: azul::AzLogicalPosition }

    #[cfg(feature = "link_static")] pub use LogicalPositionCrossCrateImpl as LogicalPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalPositionCrossCrateImpl { type Target = AzLogicalPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// A size in "logical" (non-HiDPI-adjusted) pixels in floating-point units
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalSize as LogicalSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalSizeCrossCrateImpl { pub _0: azul::AzLogicalSize }

    #[cfg(feature = "link_static")] pub use LogicalSizeCrossCrateImpl as LogicalSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalSizeCrossCrateImpl { type Target = AzLogicalSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl LogicalSize {

        /// Calls the `LogicalSize::to_physical` function.
        pub fn to_physical(&self, hidpi_factor: f32)  -> crate::window::PhysicalSizeU32 { unsafe { crate::dll::AzLogicalSize_toPhysical(self, hidpi_factor) } }
    }

    #[cfg(feature = "link_static")]
    impl LogicalSizeCrossCrateImpl {

        /// Calls the `LogicalSize::to_physical` function.
        pub fn to_physical(&self, hidpi_factor: f32)  -> crate::window::PhysicalSizeU32 {  unsafe { core::mem::transmute(unsafe { azul::AzLogicalSize_toPhysical(&self._0, hidpi_factor) }) } }
    }

    /// Unique hash of a window icon, so that azul does not have to compare the actual bytes to see wether the window icon has changed.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIconKey as IconKey;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IconKeyCrossCrateImpl { pub _0: azul::AzIconKey }

    #[cfg(feature = "link_static")] pub use IconKeyCrossCrateImpl as IconKey;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IconKeyCrossCrateImpl { type Target = AzIconKey; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IconKeyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Small (16x16x4) window icon, usually shown in the window titlebar
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSmallWindowIconBytes as SmallWindowIconBytes;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SmallWindowIconBytesCrossCrateImpl { pub _0: azul::AzSmallWindowIconBytes }

    #[cfg(feature = "link_static")] pub use SmallWindowIconBytesCrossCrateImpl as SmallWindowIconBytes;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SmallWindowIconBytesCrossCrateImpl { type Target = AzSmallWindowIconBytes; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SmallWindowIconBytesCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Large (32x32x4) window icon, usually used on high-resolution displays (instead of `SmallWindowIcon`)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLargeWindowIconBytes as LargeWindowIconBytes;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LargeWindowIconBytesCrossCrateImpl { pub _0: azul::AzLargeWindowIconBytes }

    #[cfg(feature = "link_static")] pub use LargeWindowIconBytesCrossCrateImpl as LargeWindowIconBytes;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LargeWindowIconBytesCrossCrateImpl { type Target = AzLargeWindowIconBytes; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LargeWindowIconBytesCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Window "favicon", usually shown in the top left of the window on Windows
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowIcon as WindowIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowIconCrossCrateImpl { pub _0: azul::AzWindowIcon }

    #[cfg(feature = "link_static")] pub use WindowIconCrossCrateImpl as WindowIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowIconCrossCrateImpl { type Target = AzWindowIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Application taskbar icon, 256x256x4 bytes in size
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTaskBarIcon as TaskBarIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TaskBarIconCrossCrateImpl { pub _0: azul::AzTaskBarIcon }

    #[cfg(feature = "link_static")] pub use TaskBarIconCrossCrateImpl as TaskBarIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TaskBarIconCrossCrateImpl { type Target = AzTaskBarIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TaskBarIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Symbolic name for a keyboard key, does **not** take the keyboard locale into account
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVirtualKeyCode as VirtualKeyCode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VirtualKeyCodeCrossCrateImpl { pub _0: azul::AzVirtualKeyCode }

    #[cfg(feature = "link_static")] pub use VirtualKeyCodeCrossCrateImpl as VirtualKeyCode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VirtualKeyCodeCrossCrateImpl { type Target = AzVirtualKeyCode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VirtualKeyCodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Symbolic accelerator key (ctrl, alt, shift)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAcceleratorKey as AcceleratorKey;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AcceleratorKeyCrossCrateImpl { pub _0: azul::AzAcceleratorKey }

    #[cfg(feature = "link_static")] pub use AcceleratorKeyCrossCrateImpl as AcceleratorKey;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AcceleratorKeyCrossCrateImpl { type Target = AzAcceleratorKey; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AcceleratorKeyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Minimum / maximum / current size of the window in logical dimensions
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowSize as WindowSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowSizeCrossCrateImpl { pub _0: azul::AzWindowSize }

    #[cfg(feature = "link_static")] pub use WindowSizeCrossCrateImpl as WindowSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowSizeCrossCrateImpl { type Target = AzWindowSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Boolean flags relating to the current window state
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowFlags as WindowFlags;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowFlagsCrossCrateImpl { pub _0: azul::AzWindowFlags }

    #[cfg(feature = "link_static")] pub use WindowFlagsCrossCrateImpl as WindowFlags;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowFlagsCrossCrateImpl { type Target = AzWindowFlags; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowFlagsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// State of the window frame (minimized, maximized, fullscreen or normal window)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowFrame as WindowFrame;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowFrameCrossCrateImpl { pub _0: azul::AzWindowFrame }

    #[cfg(feature = "link_static")] pub use WindowFrameCrossCrateImpl as WindowFrame;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowFrameCrossCrateImpl { type Target = AzWindowFrame; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowFrameCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Debugging information, will be rendered as an overlay on top of the UI
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDebugState as DebugState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DebugStateCrossCrateImpl { pub _0: azul::AzDebugState }

    #[cfg(feature = "link_static")] pub use DebugStateCrossCrateImpl as DebugState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DebugStateCrossCrateImpl { type Target = AzDebugState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DebugStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Current keyboard state, stores what keys / characters have been pressed
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzKeyboardState as KeyboardState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct KeyboardStateCrossCrateImpl { pub _0: azul::AzKeyboardState }

    #[cfg(feature = "link_static")] pub use KeyboardStateCrossCrateImpl as KeyboardState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for KeyboardStateCrossCrateImpl { type Target = AzKeyboardState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for KeyboardStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl KeyboardState {

        /// Returns if the `SHIFT` key is held down (left OR right shift)
        pub fn shift_down(&self)  -> bool { unsafe { crate::dll::AzKeyboardState_shiftDown(self) } }
        /// Returns if the `CTRL` key is held down
        pub fn ctrl_down(&self)  -> bool { unsafe { crate::dll::AzKeyboardState_ctrlDown(self) } }
        /// Returns if the `ALT` key is held down
        pub fn alt_down(&self)  -> bool { unsafe { crate::dll::AzKeyboardState_altDown(self) } }
        /// Returns if the `SUPER` ("Windows") key is held down
        pub fn super_down(&self)  -> bool { unsafe { crate::dll::AzKeyboardState_superDown(self) } }
        /// Returns if a key is held down
        pub fn is_key_down(&self, key: VirtualKeyCode)  -> bool { unsafe { crate::dll::AzKeyboardState_isKeyDown(self, key) } }
    }

    #[cfg(feature = "link_static")]
    impl KeyboardStateCrossCrateImpl {

        /// Returns if the `SHIFT` key is held down (left OR right shift)
        pub fn shift_down(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzKeyboardState_shiftDown(&self._0) }) } }
        /// Returns if the `CTRL` key is held down
        pub fn ctrl_down(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzKeyboardState_ctrlDown(&self._0) }) } }
        /// Returns if the `ALT` key is held down
        pub fn alt_down(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzKeyboardState_altDown(&self._0) }) } }
        /// Returns if the `SUPER` ("Windows") key is held down
        pub fn super_down(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzKeyboardState_superDown(&self._0) }) } }
        /// Returns if a key is held down
        pub fn is_key_down(&self, key: VirtualKeyCode)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzKeyboardState_isKeyDown(&self._0, key._0) }) } }
    }

    /// Current icon of the mouse cursor
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMouseCursorType as MouseCursorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MouseCursorTypeCrossCrateImpl { pub _0: azul::AzMouseCursorType }

    #[cfg(feature = "link_static")] pub use MouseCursorTypeCrossCrateImpl as MouseCursorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MouseCursorTypeCrossCrateImpl { type Target = AzMouseCursorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MouseCursorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Current position of the mouse cursor, relative to the window. Set to `Uninitialized` on startup (gets initialized on the first frame).
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCursorPosition as CursorPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CursorPositionCrossCrateImpl { pub _0: azul::AzCursorPosition }

    #[cfg(feature = "link_static")] pub use CursorPositionCrossCrateImpl as CursorPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CursorPositionCrossCrateImpl { type Target = AzCursorPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CursorPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl CursorPosition {

        /// Calls the `CursorPosition::get_position` function.
        pub fn get_position(&self)  -> crate::option::OptionLogicalPosition { unsafe { crate::dll::AzCursorPosition_getPosition(self) } }
    }

    #[cfg(feature = "link_static")]
    impl CursorPositionCrossCrateImpl {

        /// Calls the `CursorPosition::get_position` function.
        pub fn get_position(&self)  -> crate::option::OptionLogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzCursorPosition_getPosition(&self._0) }) } }
    }

    /// Current mouse / cursor state
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMouseState as MouseState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MouseStateCrossCrateImpl { pub _0: azul::AzMouseState }

    #[cfg(feature = "link_static")] pub use MouseStateCrossCrateImpl as MouseState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MouseStateCrossCrateImpl { type Target = AzMouseState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MouseStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Platform-specific window configuration, i.e. WM options that are not cross-platform
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPlatformSpecificOptions as PlatformSpecificOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PlatformSpecificOptionsCrossCrateImpl { pub _0: azul::AzPlatformSpecificOptions }

    #[cfg(feature = "link_static")] pub use PlatformSpecificOptionsCrossCrateImpl as PlatformSpecificOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PlatformSpecificOptionsCrossCrateImpl { type Target = AzPlatformSpecificOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PlatformSpecificOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Window configuration specific to Win32
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowsWindowOptions as WindowsWindowOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowsWindowOptionsCrossCrateImpl { pub _0: azul::AzWindowsWindowOptions }

    #[cfg(feature = "link_static")] pub use WindowsWindowOptionsCrossCrateImpl as WindowsWindowOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowsWindowOptionsCrossCrateImpl { type Target = AzWindowsWindowOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowsWindowOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// CSD theme of the window title / button controls
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWaylandTheme as WaylandTheme;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WaylandThemeCrossCrateImpl { pub _0: azul::AzWaylandTheme }

    #[cfg(feature = "link_static")] pub use WaylandThemeCrossCrateImpl as WaylandTheme;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WaylandThemeCrossCrateImpl { type Target = AzWaylandTheme; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WaylandThemeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Renderer type of the current windows OpenGL context
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRendererType as RendererType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RendererTypeCrossCrateImpl { pub _0: azul::AzRendererType }

    #[cfg(feature = "link_static")] pub use RendererTypeCrossCrateImpl as RendererType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RendererTypeCrossCrateImpl { type Target = AzRendererType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RendererTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Key-value pair, used for setting WM hints values specific to GNOME
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringPair as StringPair;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringPairCrossCrateImpl { pub _0: azul::AzStringPair }

    #[cfg(feature = "link_static")] pub use StringPairCrossCrateImpl as StringPair;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringPairCrossCrateImpl { type Target = AzStringPair; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringPairCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LinuxWindowOptions` struct

    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLinuxWindowOptions as LinuxWindowOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LinuxWindowOptionsCrossCrateImpl { pub _0: azul::AzLinuxWindowOptions }

    #[cfg(feature = "link_static")] pub use LinuxWindowOptionsCrossCrateImpl as LinuxWindowOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LinuxWindowOptionsCrossCrateImpl { type Target = AzLinuxWindowOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LinuxWindowOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MacWindowOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMacWindowOptions as MacWindowOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MacWindowOptionsCrossCrateImpl { pub _0: azul::AzMacWindowOptions }

    #[cfg(feature = "link_static")] pub use MacWindowOptionsCrossCrateImpl as MacWindowOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MacWindowOptionsCrossCrateImpl { type Target = AzMacWindowOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MacWindowOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WasmWindowOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWasmWindowOptions as WasmWindowOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WasmWindowOptionsCrossCrateImpl { pub _0: azul::AzWasmWindowOptions }

    #[cfg(feature = "link_static")] pub use WasmWindowOptionsCrossCrateImpl as WasmWindowOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WasmWindowOptionsCrossCrateImpl { type Target = AzWasmWindowOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WasmWindowOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FullScreenMode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFullScreenMode as FullScreenMode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FullScreenModeCrossCrateImpl { pub _0: azul::AzFullScreenMode }

    #[cfg(feature = "link_static")] pub use FullScreenModeCrossCrateImpl as FullScreenMode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FullScreenModeCrossCrateImpl { type Target = AzFullScreenMode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FullScreenModeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Window theme, set by the operating system or `WindowCreateOptions.theme` on startup
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowTheme as WindowTheme;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowThemeCrossCrateImpl { pub _0: azul::AzWindowTheme }

    #[cfg(feature = "link_static")] pub use WindowThemeCrossCrateImpl as WindowTheme;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowThemeCrossCrateImpl { type Target = AzWindowTheme; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowThemeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Position of the top left corner of the window relative to the top left of the monitor
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowPosition as WindowPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowPositionCrossCrateImpl { pub _0: azul::AzWindowPosition }

    #[cfg(feature = "link_static")] pub use WindowPositionCrossCrateImpl as WindowPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowPositionCrossCrateImpl { type Target = AzWindowPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Position of the virtual keyboard necessary to insert CJK characters
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzImePosition as ImePosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ImePositionCrossCrateImpl { pub _0: azul::AzImePosition }

    #[cfg(feature = "link_static")] pub use ImePositionCrossCrateImpl as ImePosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ImePositionCrossCrateImpl { type Target = AzImePosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ImePositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Current state of touch devices / touch inputs
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTouchState as TouchState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TouchStateCrossCrateImpl { pub _0: azul::AzTouchState }

    #[cfg(feature = "link_static")] pub use TouchStateCrossCrateImpl as TouchState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TouchStateCrossCrateImpl { type Target = AzTouchState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TouchStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Information about a single (or many) monitors, useful for dock widgets
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMonitor as Monitor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MonitorCrossCrateImpl { pub _0: azul::AzMonitor }

    #[cfg(feature = "link_static")] pub use MonitorCrossCrateImpl as Monitor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MonitorCrossCrateImpl { type Target = AzMonitor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MonitorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Describes a rendering configuration for a monitor
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVideoMode as VideoMode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VideoModeCrossCrateImpl { pub _0: azul::AzVideoMode }

    #[cfg(feature = "link_static")] pub use VideoModeCrossCrateImpl as VideoMode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VideoModeCrossCrateImpl { type Target = AzVideoMode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VideoModeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WindowState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowState as WindowState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowStateCrossCrateImpl { pub _0: azul::AzWindowState }

    #[cfg(feature = "link_static")] pub use WindowStateCrossCrateImpl as WindowState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowStateCrossCrateImpl { type Target = AzWindowState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl WindowState {

        /// Creates a new WindowState with default settings and a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self { unsafe { crate::dll::AzWindowState_new(layout_callback) } }
        /// Creates a default WindowState with an empty layout callback - useful only if you use the Rust `WindowState { .. WindowState::default() }` intialization syntax.
        pub fn default() -> Self { unsafe { crate::dll::AzWindowState_default() } }
    }

    #[cfg(feature = "link_static")]
    impl WindowStateCrossCrateImpl {

        /// Creates a new WindowState with default settings and a custom layout callback
        pub fn new(layout_callback: LayoutCallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzWindowState_new(layout_callback._0) }) } }
        /// Creates a default WindowState with an empty layout callback - useful only if you use the Rust `WindowState { .. WindowState::default() }` intialization syntax.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzWindowState_default() }) } }
    }

}

pub mod callbacks {
    #![allow(dead_code, unused_imports)]
    //! Callback type definitions + struct definitions of `CallbackInfo`s
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;

    #[cfg_attr(not(feature = "link_static"), derive(Debug))]
    #[repr(C)]
    pub struct Ref<'a, T> {
        ptr: &'a T,
        sharing_info: RefCount,
    }

    impl<'a, T> Drop for Ref<'a, T> {
        fn drop(&mut self) {
            self.sharing_info.decrease_ref();
        }
    }

    impl<'a, T> core::ops::Deref for Ref<'a, T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            self.ptr
        }
    }

    #[cfg_attr(not(feature = "link_static"), derive(Debug))]
    #[repr(C)]
    pub struct RefMut<'a, T> {
        ptr: &'a mut T,
        sharing_info: RefCount,
    }

    impl<'a, T> Drop for RefMut<'a, T> {
        fn drop(&mut self) {
            self.sharing_info.decrease_refmut();
        }
    }

    impl<'a, T> core::ops::Deref for RefMut<'a, T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            &*self.ptr
        }
    }

    impl<'a, T> core::ops::DerefMut for RefMut<'a, T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            self.ptr
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl RefAny {

        /// Creates a new, type-erased pointer by casting the `T` value into a `Vec<u8>` and saving the length + type ID
        pub fn new<T: 'static>(value: T) -> Self {
            use crate::dll::*;

            extern "C" fn default_custom_destructor<U: 'static>(ptr: &mut c_void) {
                use core::{mem, ptr};

                // note: in the default constructor, we do not need to check whether U == T

                unsafe {
                    // copy the struct from the heap to the stack and
                    // call mem::drop on U to run the destructor
                    let mut stack_mem = mem::MaybeUninit::<U>::uninit();
                    ptr::copy_nonoverlapping((ptr as *mut c_void) as *const U, stack_mem.as_mut_ptr(), mem::size_of::<U>());
                    let stack_mem = stack_mem.assume_init();
                    mem::drop(stack_mem);
                }
            }

            let type_name_str = ::core::any::type_name::<T>();
            let st = crate::str::String::from_const_str(type_name_str);
            let s = unsafe { crate::dll::AzRefAny_newC(
                (&value as *const T) as *const c_void,
                ::core::mem::size_of::<T>(),
                Self::type_id::<T>(),
                st,
                default_custom_destructor::<T>,
            ) };
            ::core::mem::forget(value); // do not run the destructor of T here!
            s
        }

        /// Downcasts the type-erased pointer to a type `&U`, returns `None` if the types don't match
        #[inline]
        pub fn downcast_ref<'a, U: 'static>(&'a mut self) -> Option<Ref<'a, U>> {
            let is_same_type = self.get_type_id() == Self::type_id::<U>();
            if !is_same_type { return None; }

            let can_be_shared = self.sharing_info.can_be_shared();
            if !can_be_shared { return None; }

            self.sharing_info.increase_ref();
            Some(Ref {
                ptr: unsafe { &*(self._internal_ptr as *const U) },
                sharing_info: self.sharing_info.clone(),
            })
        }

        /// Downcasts the type-erased pointer to a type `&mut U`, returns `None` if the types don't match
        #[inline]
        pub fn downcast_mut<'a, U: 'static>(&'a mut self) -> Option<RefMut<'a, U>> {
            let is_same_type = self.get_type_id() == Self::type_id::<U>();
            if !is_same_type { return None; }

            let can_be_shared_mut = self.sharing_info.can_be_shared_mut();
            if !can_be_shared_mut { return None; }

            self.sharing_info.increase_refmut();

            Some(RefMut {
                ptr: unsafe { &mut *(self._internal_ptr as *mut U) },
                sharing_info: self.sharing_info.clone(),
            })
        }

        // Returns the typeid of `T` as a u64 (necessary because `core::any::TypeId` is not C-ABI compatible)
        #[inline]
        pub fn type_id<T: 'static>() -> u64 {
            use core::any::TypeId;
            use core::mem;

            // fast method to serialize the type id into a u64
            let t_id = TypeId::of::<T>();
            let struct_as_bytes = unsafe { ::core::slice::from_raw_parts((&t_id as *const TypeId) as *const u8, mem::size_of::<TypeId>()) };
            struct_as_bytes.into_iter().enumerate().map(|(s_pos, s)| ((*s as u64) << s_pos)).sum()
        }
    }    use crate::str::String;
    use crate::css::{CssProperty, CssPropertyType};
    use crate::window::{LogicalPosition, WindowCreateOptions, WindowState};
    use crate::image::{ImageMask, ImageRef};
    use crate::task::{ThreadId, ThreadSendMsg, Timer, TimerId};
    /// `LayoutCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutCallback as LayoutCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutCallbackCrossCrateImpl { pub _0: azul::AzLayoutCallback }

    #[cfg(feature = "link_static")] pub use LayoutCallbackCrossCrateImpl as LayoutCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutCallbackCrossCrateImpl { type Target = AzLayoutCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable wrapper over a `MarshaledLayoutCallback`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMarshaledLayoutCallback as MarshaledLayoutCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MarshaledLayoutCallbackCrossCrateImpl { pub _0: azul::AzMarshaledLayoutCallback }

    #[cfg(feature = "link_static")] pub use MarshaledLayoutCallbackCrossCrateImpl as MarshaledLayoutCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MarshaledLayoutCallbackCrossCrateImpl { type Target = AzMarshaledLayoutCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MarshaledLayoutCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable wrapper over a `MarshaledLayoutCallbackInner`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMarshaledLayoutCallbackInner as MarshaledLayoutCallbackInner;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MarshaledLayoutCallbackInnerCrossCrateImpl { pub _0: azul::AzMarshaledLayoutCallbackInner }

    #[cfg(feature = "link_static")] pub use MarshaledLayoutCallbackInnerCrossCrateImpl as MarshaledLayoutCallbackInner;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MarshaledLayoutCallbackInnerCrossCrateImpl { type Target = AzMarshaledLayoutCallbackInner; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MarshaledLayoutCallbackInnerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Marshaled version of LayoutCallback, carrys an extra "marshal_data" containing the (usually external) function object
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMarshaledLayoutCallbackType as MarshaledLayoutCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MarshaledLayoutCallbackTypeCrossCrateImpl { pub _0: azul::AzMarshaledLayoutCallbackType }

    #[cfg(feature = "link_static")] pub use MarshaledLayoutCallbackTypeCrossCrateImpl as MarshaledLayoutCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MarshaledLayoutCallbackTypeCrossCrateImpl { type Target = AzMarshaledLayoutCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MarshaledLayoutCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable wrapper over a `LayoutCallbackType`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutCallbackInner as LayoutCallbackInner;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutCallbackInnerCrossCrateImpl { pub _0: azul::AzLayoutCallbackInner }

    #[cfg(feature = "link_static")] pub use LayoutCallbackInnerCrossCrateImpl as LayoutCallbackInner;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutCallbackInnerCrossCrateImpl { type Target = AzLayoutCallbackInner; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutCallbackInnerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Main callback to layout the UI. azul will only call this callback when necessary (usually when one of the callback or timer returns `RegenerateStyledDomForCurrentWindow`), however azul may also call this callback at any given time, so it should be performant. This is the main entry point for your app UI.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutCallbackType as LayoutCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutCallbackTypeCrossCrateImpl { pub _0: azul::AzLayoutCallbackType }

    #[cfg(feature = "link_static")] pub use LayoutCallbackTypeCrossCrateImpl as LayoutCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutCallbackTypeCrossCrateImpl { type Target = AzLayoutCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable wrapper over a `CallbackType`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallback as Callback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackCrossCrateImpl { pub _0: azul::AzCallback }

    #[cfg(feature = "link_static")] pub use CallbackCrossCrateImpl as Callback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackCrossCrateImpl { type Target = AzCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Generic UI callback function pointer: called when the `EventFilter` is active
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackType as CallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackTypeCrossCrateImpl { pub _0: azul::AzCallbackType }

    #[cfg(feature = "link_static")] pub use CallbackTypeCrossCrateImpl as CallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackTypeCrossCrateImpl { type Target = AzCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CallbackInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackInfo as CallbackInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackInfoCrossCrateImpl { pub _0: azul::AzCallbackInfo }

    #[cfg(feature = "link_static")] pub use CallbackInfoCrossCrateImpl as CallbackInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackInfoCrossCrateImpl { type Target = AzCallbackInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl CallbackInfo {

        /// Returns the `DomNodeId` of the element that the callback was attached to.
        pub fn get_hit_node(&self)  -> crate::callbacks::DomNodeId { unsafe { crate::dll::AzCallbackInfo_getHitNode(self) } }
        /// Returns the function pointer necessary to query the current time.
        pub fn get_system_time_fn(&self)  -> crate::task::GetSystemTimeFn { unsafe { crate::dll::AzCallbackInfo_getSystemTimeFn(self) } }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not in the current window.
        pub fn get_cursor_relative_to_viewport(&self)  -> crate::option::OptionLogicalPosition { unsafe { crate::dll::AzCallbackInfo_getCursorRelativeToViewport(self) } }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not hovering over the current node.
        pub fn get_cursor_relative_to_node(&self)  -> crate::option::OptionLogicalPosition { unsafe { crate::dll::AzCallbackInfo_getCursorRelativeToNode(self) } }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_current_window_state(&self)  -> crate::window::WindowState { unsafe { crate::dll::AzCallbackInfo_getCurrentWindowState(self) } }
        /// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
        pub fn get_current_keyboard_state(&self)  -> crate::window::KeyboardState { unsafe { crate::dll::AzCallbackInfo_getCurrentKeyboardState(self) } }
        /// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
        pub fn get_current_mouse_state(&self)  -> crate::window::MouseState { unsafe { crate::dll::AzCallbackInfo_getCurrentMouseState(self) } }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_previous_window_state(&self)  -> crate::option::OptionWindowState { unsafe { crate::dll::AzCallbackInfo_getPreviousWindowState(self) } }
        /// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
        pub fn get_previous_keyboard_state(&self)  -> crate::option::OptionKeyboardState { unsafe { crate::dll::AzCallbackInfo_getPreviousKeyboardState(self) } }
        /// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
        pub fn get_previous_mouse_state(&self)  -> crate::option::OptionMouseState { unsafe { crate::dll::AzCallbackInfo_getPreviousMouseState(self) } }
        /// Returns a copy of the current windows `RawWindowHandle`.
        pub fn get_current_window_handle(&self)  -> crate::window::RawWindowHandle { unsafe { crate::dll::AzCallbackInfo_getCurrentWindowHandle(self) } }
        /// Returns a **reference-counted copy** of the current windows' `Gl` (context). You can use this to render OpenGL textures.
        pub fn get_gl_context(&self)  -> crate::option::OptionGl { unsafe { crate::dll::AzCallbackInfo_getGlContext(self) } }
        /// Returns the x / y offset that this node has been scrolled to by the user or `None` if the node has not been scrolled.
        pub fn get_scroll_position(&self, node_id: DomNodeId)  -> crate::option::OptionLogicalPosition { unsafe { crate::dll::AzCallbackInfo_getScrollPosition(self, node_id) } }
        /// Returns the `dataset` property of the given Node or `None` if the node doesn't have a `dataset` property.
        pub fn get_dataset(&mut self, node_id: DomNodeId)  -> crate::option::OptionRefAny { unsafe { crate::dll::AzCallbackInfo_getDataset(self, node_id) } }
        /// Given a dataset, returns the node ID of the "root" `RefAny`, i.e. the `RefAny` with the lowest `instance` count that is set as a `dataset` on any node.
        pub fn get_node_id_of_root_dataset(&mut self, dataset: RefAny)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getNodeIdOfRootDataset(self, dataset) } }
        /// If the node is a `Text` node, returns a copy of the internal string contents.
        pub fn get_string_contents(&self, node_id: DomNodeId)  -> crate::option::OptionString { unsafe { crate::dll::AzCallbackInfo_getStringContents(self, node_id) } }
        /// If the node is a `Text` node, returns the layouted inline glyphs of the text currently rendered on the screen
        pub fn get_inline_text(&self, node_id: DomNodeId)  -> crate::option::OptionInlineText { unsafe { crate::dll::AzCallbackInfo_getInlineText(self, node_id) } }
        /// If the node is a `Text` node, returns the `FontRef` that was used to render this node. Useful for getting font metrics for a text string
        pub fn get_font_ref(&self, node_id: DomNodeId)  -> crate::option::OptionFontRef { unsafe { crate::dll::AzCallbackInfo_getFontRef(self, node_id) } }
        /// Calls the `CallbackInfo::get_text_layout_options` function.
        pub fn get_text_layout_options(&self, node_id: DomNodeId)  -> crate::option::OptionResolvedTextLayoutOptions { unsafe { crate::dll::AzCallbackInfo_getTextLayoutOptions(self, node_id) } }
        /// Similar to `get_inline_text()`: If the node is a `Text` node, shape the `text` string with the same parameters as the current text and return the calculated InlineTextLayout. Necessary to calculate text cursor offsets and to detect when a line overflows content.
        pub fn shape_text(&self, node_id: DomNodeId, text: String)  -> crate::option::OptionInlineText { unsafe { crate::dll::AzCallbackInfo_shapeText(self, node_id, text) } }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent(&mut self, node_id: DomNodeId)  -> usize { unsafe { crate::dll::AzCallbackInfo_getIndexInParent(self, node_id) } }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_parent(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getParent(self, node_id) } }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_previous_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getPreviousSibling(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_next_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getNextSibling(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_first_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getFirstChild(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_last_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzCallbackInfo_getLastChild(self, node_id) } }
        /// Returns the position of a given DOM node in the UI
        pub fn get_node_position(&mut self, node_id: DomNodeId)  -> crate::option::OptionPositionInfo { unsafe { crate::dll::AzCallbackInfo_getNodePosition(self, node_id) } }
        /// Returns the size of a given DOM node in the UI
        pub fn get_node_size(&mut self, node_id: DomNodeId)  -> crate::option::OptionLogicalSize { unsafe { crate::dll::AzCallbackInfo_getNodeSize(self, node_id) } }
        /// Returns the current computed CSS property of a given DOM node in the UI
        pub fn get_computed_css_property(&mut self, node_id: DomNodeId, property_type: CssPropertyType)  -> crate::option::OptionCssProperty { unsafe { crate::dll::AzCallbackInfo_getComputedCssProperty(self, node_id, property_type) } }
        /// Sets the new `WindowState` for the next frame. The window is updated after all callbacks are run.
        pub fn set_window_state(&mut self, new_state: WindowState)  { unsafe { crate::dll::AzCallbackInfo_setWindowState(self, new_state) } }
        /// Sets the new `FocusTarget` for the next frame. Note that this will emit a `On::FocusLost` and `On::FocusReceived` event, if the focused node has changed.
        pub fn set_focus(&mut self, target: FocusTarget)  { unsafe { crate::dll::AzCallbackInfo_setFocus(self, target) } }
        /// Sets a `CssProperty` on a given node to its new value. If this property change affects the layout, this will automatically trigger a relayout and redraw of the screen.
        pub fn set_css_property(&mut self, node_id: DomNodeId, new_property: CssProperty)  { unsafe { crate::dll::AzCallbackInfo_setCssProperty(self, node_id, new_property) } }
        /// Sets the scroll position of the node
        pub fn set_scroll_position(&mut self, node_id: DomNodeId, scroll_position: LogicalPosition)  { unsafe { crate::dll::AzCallbackInfo_setScrollPosition(self, node_id, scroll_position) } }
        /// If the node is a `Text` node, overwrites the `Text` content with the new string, without requiring the entire UI to be rebuilt.
        pub fn set_string_contents(&mut self, node_id: DomNodeId, string: String)  { unsafe { crate::dll::AzCallbackInfo_setStringContents(self, node_id, string) } }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image(&mut self, id: String, image: ImageRef)  { unsafe { crate::dll::AzCallbackInfo_addImage(self, id, image) } }
        /// Returns whether an image with a given CSS ID already exists
        pub fn has_image(&self, id: String)  -> bool { unsafe { crate::dll::AzCallbackInfo_hasImage(self, id) } }
        /// Returns the image with a given CSS ID
        pub fn get_image(&self, id: String)  -> crate::option::OptionImageRef { unsafe { crate::dll::AzCallbackInfo_getImage(self, id) } }
        /// If the node is an `Image`, exchanges the current image with a new source
        pub fn update_image(&mut self, node_id: DomNodeId, new_image: ImageRef, image_type: UpdateImageType)  { unsafe { crate::dll::AzCallbackInfo_updateImage(self, node_id, new_image, image_type) } }
        /// Deletes an image identified by a CSS ID from the image cache
        pub fn delete_image(&mut self, id: String)  { unsafe { crate::dll::AzCallbackInfo_deleteImage(self, id) } }
        /// If the node has an `ImageMask`, exchanges the current mask for the new mask
        pub fn update_image_mask(&mut self, node_id: DomNodeId, new_mask: ImageMask)  { unsafe { crate::dll::AzCallbackInfo_updateImageMask(self, node_id, new_mask) } }
        /// Stops the propagation of the current callback event type to the parent. Events are bubbled from the inside out (children first, then parents), this event stops the propagation of the event to the parent.
        pub fn stop_propagation(&mut self)  { unsafe { crate::dll::AzCallbackInfo_stopPropagation(self) } }
        /// Spawns a new window with the given `WindowCreateOptions`.
        pub fn create_window(&mut self, new_window: WindowCreateOptions)  { unsafe { crate::dll::AzCallbackInfo_createWindow(self, new_window) } }
        /// Adds a new `Timer` to the runtime. See the documentation for `Timer` for more information.
        pub fn start_timer(&mut self, timer: Timer)  -> crate::task::TimerId { unsafe { crate::dll::AzCallbackInfo_startTimer(self, timer) } }
        /// Starts an animation timer on a give NodeId - same as a `Timer`, but uses a pre-configured interpolation function to drive the animation timer
        pub fn start_animation(&mut self, node: DomNodeId, animation: Animation)  -> crate::option::OptionTimerId { unsafe { crate::dll::AzCallbackInfo_startAnimation(self, node, animation) } }
        /// Stops / cancels a `Timer`. See the documentation for `Timer` for more information.
        pub fn stop_timer(&mut self, timer_id: TimerId)  -> bool { unsafe { crate::dll::AzCallbackInfo_stopTimer(self, timer_id) } }
        /// Starts a new `Thread` to the runtime. See the documentation for `Thread` for more information.
        pub fn start_thread(&mut self, thread_initialize_data: RefAny, writeback_data: RefAny, callback: ThreadCallbackType)  -> crate::option::OptionThreadId { unsafe { crate::dll::AzCallbackInfo_startThread(self, thread_initialize_data, writeback_data, callback) } }
        /// Sends a message to a background thread
        pub fn send_thread_msg(&mut self, thread_id: ThreadId, msg: ThreadSendMsg)  -> bool { unsafe { crate::dll::AzCallbackInfo_sendThreadMsg(self, thread_id, msg) } }
        /// Stops a thread at the nearest possible opportunity. Sends a `ThreadSendMsg::TerminateThread` message to the thread and joins the thread.
        pub fn stop_thread(&mut self, thread_id: ThreadId)  -> bool { unsafe { crate::dll::AzCallbackInfo_stopThread(self, thread_id) } }
    }

    #[cfg(feature = "link_static")]
    impl CallbackInfoCrossCrateImpl {

        /// Returns the `DomNodeId` of the element that the callback was attached to.
        pub fn get_hit_node(&self)  -> crate::callbacks::DomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getHitNode(&self._0) }) } }
        /// Returns the function pointer necessary to query the current time.
        pub fn get_system_time_fn(&self)  -> crate::task::GetSystemTimeFn {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getSystemTimeFn(&self._0) }) } }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not in the current window.
        pub fn get_cursor_relative_to_viewport(&self)  -> crate::option::OptionLogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCursorRelativeToViewport(&self._0) }) } }
        /// Returns the `LayoutPoint` of the cursor in the viewport (relative to the origin of the `Dom`). Set to `None` if the cursor is not hovering over the current node.
        pub fn get_cursor_relative_to_node(&self)  -> crate::option::OptionLogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCursorRelativeToNode(&self._0) }) } }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_current_window_state(&self)  -> crate::window::WindowState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCurrentWindowState(&self._0) }) } }
        /// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
        pub fn get_current_keyboard_state(&self)  -> crate::window::KeyboardState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCurrentKeyboardState(&self._0) }) } }
        /// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
        pub fn get_current_mouse_state(&self)  -> crate::window::MouseState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCurrentMouseState(&self._0) }) } }
        /// Returns a copy of the current windows `WindowState`.
        pub fn get_previous_window_state(&self)  -> crate::option::OptionWindowState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getPreviousWindowState(&self._0) }) } }
        /// Returns a copy of the internal `KeyboardState`. Same as `self.get_window_state().keyboard_state`
        pub fn get_previous_keyboard_state(&self)  -> crate::option::OptionKeyboardState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getPreviousKeyboardState(&self._0) }) } }
        /// Returns a copy of the internal `MouseState`. Same as `self.get_window_state().mouse_state`
        pub fn get_previous_mouse_state(&self)  -> crate::option::OptionMouseState {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getPreviousMouseState(&self._0) }) } }
        /// Returns a copy of the current windows `RawWindowHandle`.
        pub fn get_current_window_handle(&self)  -> crate::window::RawWindowHandle {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getCurrentWindowHandle(&self._0) }) } }
        /// Returns a **reference-counted copy** of the current windows' `Gl` (context). You can use this to render OpenGL textures.
        pub fn get_gl_context(&self)  -> crate::option::OptionGl {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getGlContext(&self._0) }) } }
        /// Returns the x / y offset that this node has been scrolled to by the user or `None` if the node has not been scrolled.
        pub fn get_scroll_position(&self, node_id: DomNodeId)  -> crate::option::OptionLogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getScrollPosition(&self._0, node_id._0) }) } }
        /// Returns the `dataset` property of the given Node or `None` if the node doesn't have a `dataset` property.
        pub fn get_dataset(&mut self, node_id: DomNodeId)  -> crate::option::OptionRefAny {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getDataset(&mut self._0, node_id._0) }) } }
        /// Given a dataset, returns the node ID of the "root" `RefAny`, i.e. the `RefAny` with the lowest `instance` count that is set as a `dataset` on any node.
        pub fn get_node_id_of_root_dataset(&mut self, dataset: RefAny)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getNodeIdOfRootDataset(&mut self._0, dataset._0) }) } }
        /// If the node is a `Text` node, returns a copy of the internal string contents.
        pub fn get_string_contents(&self, node_id: DomNodeId)  -> crate::option::OptionString {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getStringContents(&self._0, node_id._0) }) } }
        /// If the node is a `Text` node, returns the layouted inline glyphs of the text currently rendered on the screen
        pub fn get_inline_text(&self, node_id: DomNodeId)  -> crate::option::OptionInlineText {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getInlineText(&self._0, node_id._0) }) } }
        /// If the node is a `Text` node, returns the `FontRef` that was used to render this node. Useful for getting font metrics for a text string
        pub fn get_font_ref(&self, node_id: DomNodeId)  -> crate::option::OptionFontRef {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getFontRef(&self._0, node_id._0) }) } }
        /// Calls the `CallbackInfo::get_text_layout_options` function.
        pub fn get_text_layout_options(&self, node_id: DomNodeId)  -> crate::option::OptionResolvedTextLayoutOptions {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getTextLayoutOptions(&self._0, node_id._0) }) } }
        /// Similar to `get_inline_text()`: If the node is a `Text` node, shape the `text` string with the same parameters as the current text and return the calculated InlineTextLayout. Necessary to calculate text cursor offsets and to detect when a line overflows content.
        pub fn shape_text(&self, node_id: DomNodeId, text: String)  -> crate::option::OptionInlineText {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_shapeText(&self._0, node_id._0, text._0) }) } }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent(&mut self, node_id: DomNodeId)  -> usize {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getIndexInParent(&mut self._0, node_id._0) }) } }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_parent(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getParent(&mut self._0, node_id._0) }) } }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_previous_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getPreviousSibling(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_next_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getNextSibling(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_first_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getFirstChild(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_last_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getLastChild(&mut self._0, node_id._0) }) } }
        /// Returns the position of a given DOM node in the UI
        pub fn get_node_position(&mut self, node_id: DomNodeId)  -> crate::option::OptionPositionInfo {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getNodePosition(&mut self._0, node_id._0) }) } }
        /// Returns the size of a given DOM node in the UI
        pub fn get_node_size(&mut self, node_id: DomNodeId)  -> crate::option::OptionLogicalSize {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getNodeSize(&mut self._0, node_id._0) }) } }
        /// Returns the current computed CSS property of a given DOM node in the UI
        pub fn get_computed_css_property(&mut self, node_id: DomNodeId, property_type: CssPropertyType)  -> crate::option::OptionCssProperty {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getComputedCssProperty(&mut self._0, node_id._0, property_type._0) }) } }
        /// Sets the new `WindowState` for the next frame. The window is updated after all callbacks are run.
        pub fn set_window_state(&mut self, new_state: WindowState)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_setWindowState(&mut self._0, new_state._0) }) } }
        /// Sets the new `FocusTarget` for the next frame. Note that this will emit a `On::FocusLost` and `On::FocusReceived` event, if the focused node has changed.
        pub fn set_focus(&mut self, target: FocusTarget)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_setFocus(&mut self._0, target._0) }) } }
        /// Sets a `CssProperty` on a given node to its new value. If this property change affects the layout, this will automatically trigger a relayout and redraw of the screen.
        pub fn set_css_property(&mut self, node_id: DomNodeId, new_property: CssProperty)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_setCssProperty(&mut self._0, node_id._0, new_property._0) }) } }
        /// Sets the scroll position of the node
        pub fn set_scroll_position(&mut self, node_id: DomNodeId, scroll_position: LogicalPosition)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_setScrollPosition(&mut self._0, node_id._0, scroll_position._0) }) } }
        /// If the node is a `Text` node, overwrites the `Text` content with the new string, without requiring the entire UI to be rebuilt.
        pub fn set_string_contents(&mut self, node_id: DomNodeId, string: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_setStringContents(&mut self._0, node_id._0, string._0) }) } }
        /// Adds a new image identified by an ID to the image cache
        pub fn add_image(&mut self, id: String, image: ImageRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_addImage(&mut self._0, id._0, image._0) }) } }
        /// Returns whether an image with a given CSS ID already exists
        pub fn has_image(&self, id: String)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_hasImage(&self._0, id._0) }) } }
        /// Returns the image with a given CSS ID
        pub fn get_image(&self, id: String)  -> crate::option::OptionImageRef {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_getImage(&self._0, id._0) }) } }
        /// If the node is an `Image`, exchanges the current image with a new source
        pub fn update_image(&mut self, node_id: DomNodeId, new_image: ImageRef, image_type: UpdateImageType)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_updateImage(&mut self._0, node_id._0, new_image._0, image_type._0) }) } }
        /// Deletes an image identified by a CSS ID from the image cache
        pub fn delete_image(&mut self, id: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_deleteImage(&mut self._0, id._0) }) } }
        /// If the node has an `ImageMask`, exchanges the current mask for the new mask
        pub fn update_image_mask(&mut self, node_id: DomNodeId, new_mask: ImageMask)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_updateImageMask(&mut self._0, node_id._0, new_mask._0) }) } }
        /// Stops the propagation of the current callback event type to the parent. Events are bubbled from the inside out (children first, then parents), this event stops the propagation of the event to the parent.
        pub fn stop_propagation(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_stopPropagation(&mut self._0) }) } }
        /// Spawns a new window with the given `WindowCreateOptions`.
        pub fn create_window(&mut self, new_window: WindowCreateOptions)  {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_createWindow(&mut self._0, new_window._0) }) } }
        /// Adds a new `Timer` to the runtime. See the documentation for `Timer` for more information.
        pub fn start_timer(&mut self, timer: Timer)  -> crate::task::TimerId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_startTimer(&mut self._0, timer._0) }) } }
        /// Starts an animation timer on a give NodeId - same as a `Timer`, but uses a pre-configured interpolation function to drive the animation timer
        pub fn start_animation(&mut self, node: DomNodeId, animation: Animation)  -> crate::option::OptionTimerId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_startAnimation(&mut self._0, node._0, animation._0) }) } }
        /// Stops / cancels a `Timer`. See the documentation for `Timer` for more information.
        pub fn stop_timer(&mut self, timer_id: TimerId)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_stopTimer(&mut self._0, timer_id._0) }) } }
        /// Starts a new `Thread` to the runtime. See the documentation for `Thread` for more information.
        pub fn start_thread(&mut self, thread_initialize_data: RefAny, writeback_data: RefAny, callback: ThreadCallbackType)  -> crate::option::OptionThreadId {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_startThread(&mut self._0, thread_initialize_data._0, writeback_data._0, callback._0) }) } }
        /// Sends a message to a background thread
        pub fn send_thread_msg(&mut self, thread_id: ThreadId, msg: ThreadSendMsg)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_sendThreadMsg(&mut self._0, thread_id._0, msg._0) }) } }
        /// Stops a thread at the nearest possible opportunity. Sends a `ThreadSendMsg::TerminateThread` message to the thread and joins the thread.
        pub fn stop_thread(&mut self, thread_id: ThreadId)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzCallbackInfo_stopThread(&mut self._0, thread_id._0) }) } }
    }

    /// Which type of image should be updated: background image (the CSS background) or content image (the <img src=""> content)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzUpdateImageType as UpdateImageType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct UpdateImageTypeCrossCrateImpl { pub _0: azul::AzUpdateImageType }

    #[cfg(feature = "link_static")] pub use UpdateImageTypeCrossCrateImpl as UpdateImageType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for UpdateImageTypeCrossCrateImpl { type Target = AzUpdateImageType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for UpdateImageTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Specifies if the screen should be updated after the callback function has returned
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzUpdate as Update;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct UpdateCrossCrateImpl { pub _0: azul::AzUpdate }

    #[cfg(feature = "link_static")] pub use UpdateCrossCrateImpl as Update;

    #[cfg(feature = "link_static")] impl core::ops::Deref for UpdateCrossCrateImpl { type Target = AzUpdate; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for UpdateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Index of a Node in the internal `NodeDataContainer`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeId as NodeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdCrossCrateImpl { pub _0: azul::AzNodeId }

    #[cfg(feature = "link_static")] pub use NodeIdCrossCrateImpl as NodeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdCrossCrateImpl { type Target = AzNodeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// ID of a DOM - one window can contain multiple, nested DOMs (such as iframes)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDomId as DomId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomIdCrossCrateImpl { pub _0: azul::AzDomId }

    #[cfg(feature = "link_static")] pub use DomIdCrossCrateImpl as DomId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomIdCrossCrateImpl { type Target = AzDomId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Combination of node ID + DOM ID, both together can identify a node
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDomNodeId as DomNodeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomNodeIdCrossCrateImpl { pub _0: azul::AzDomNodeId }

    #[cfg(feature = "link_static")] pub use DomNodeIdCrossCrateImpl as DomNodeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomNodeIdCrossCrateImpl { type Target = AzDomNodeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomNodeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `PositionInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPositionInfo as PositionInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PositionInfoCrossCrateImpl { pub _0: azul::AzPositionInfo }

    #[cfg(feature = "link_static")] pub use PositionInfoCrossCrateImpl as PositionInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PositionInfoCrossCrateImpl { type Target = AzPositionInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PositionInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl PositionInfo {

        /// Calls the `PositionInfo::is_positioned` function.
        pub fn is_positioned(&self)  -> bool { unsafe { crate::dll::AzPositionInfo_isPositioned(self) } }
        /// Calls the `PositionInfo::get_static_offset` function.
        pub fn get_static_offset(&self)  -> crate::window::LogicalPosition { unsafe { crate::dll::AzPositionInfo_getStaticOffset(self) } }
        /// Calls the `PositionInfo::get_relative_offset` function.
        pub fn get_relative_offset(&self)  -> crate::window::LogicalPosition { unsafe { crate::dll::AzPositionInfo_getRelativeOffset(self) } }
    }

    #[cfg(feature = "link_static")]
    impl PositionInfoCrossCrateImpl {

        /// Calls the `PositionInfo::is_positioned` function.
        pub fn is_positioned(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzPositionInfo_isPositioned(&self._0) }) } }
        /// Calls the `PositionInfo::get_static_offset` function.
        pub fn get_static_offset(&self)  -> crate::window::LogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzPositionInfo_getStaticOffset(&self._0) }) } }
        /// Calls the `PositionInfo::get_relative_offset` function.
        pub fn get_relative_offset(&self)  -> crate::window::LogicalPosition {  unsafe { core::mem::transmute(unsafe { azul::AzPositionInfo_getRelativeOffset(&self._0) }) } }
    }

    /// `PositionInfoInner` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPositionInfoInner as PositionInfoInner;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PositionInfoInnerCrossCrateImpl { pub _0: azul::AzPositionInfoInner }

    #[cfg(feature = "link_static")] pub use PositionInfoInnerCrossCrateImpl as PositionInfoInner;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PositionInfoInnerCrossCrateImpl { type Target = AzPositionInfoInner; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PositionInfoInnerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `HidpiAdjustedBounds` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzHidpiAdjustedBounds as HidpiAdjustedBounds;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct HidpiAdjustedBoundsCrossCrateImpl { pub _0: azul::AzHidpiAdjustedBounds }

    #[cfg(feature = "link_static")] pub use HidpiAdjustedBoundsCrossCrateImpl as HidpiAdjustedBounds;

    #[cfg(feature = "link_static")] impl core::ops::Deref for HidpiAdjustedBoundsCrossCrateImpl { type Target = AzHidpiAdjustedBounds; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for HidpiAdjustedBoundsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl HidpiAdjustedBounds {

        /// Returns the size of the bounds in logical units
        pub fn get_logical_size(&self)  -> crate::window::LogicalSize { unsafe { crate::dll::AzHidpiAdjustedBounds_getLogicalSize(self) } }
        /// Returns the size of the bounds in physical units
        pub fn get_physical_size(&self)  -> crate::window::PhysicalSizeU32 { unsafe { crate::dll::AzHidpiAdjustedBounds_getPhysicalSize(self) } }
        /// Returns the hidpi factor of the bounds
        pub fn get_hidpi_factor(&self)  -> f32 { unsafe { crate::dll::AzHidpiAdjustedBounds_getHidpiFactor(self) } }
    }

    #[cfg(feature = "link_static")]
    impl HidpiAdjustedBoundsCrossCrateImpl {

        /// Returns the size of the bounds in logical units
        pub fn get_logical_size(&self)  -> crate::window::LogicalSize {  unsafe { core::mem::transmute(unsafe { azul::AzHidpiAdjustedBounds_getLogicalSize(&self._0) }) } }
        /// Returns the size of the bounds in physical units
        pub fn get_physical_size(&self)  -> crate::window::PhysicalSizeU32 {  unsafe { core::mem::transmute(unsafe { azul::AzHidpiAdjustedBounds_getPhysicalSize(&self._0) }) } }
        /// Returns the hidpi factor of the bounds
        pub fn get_hidpi_factor(&self)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzHidpiAdjustedBounds_getHidpiFactor(&self._0) }) } }
    }

    /// `InlineText` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineText as InlineText;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextCrossCrateImpl { pub _0: azul::AzInlineText }

    #[cfg(feature = "link_static")] pub use InlineTextCrossCrateImpl as InlineText;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextCrossCrateImpl { type Target = AzInlineText; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl InlineText {

        /// Hit-tests the inline text, returns detailed information about which glyph / word / line, etc. the position (usually the mouse cursor) is currently over. Result may be empty (no hits) or contain more than one result (cursor is hovering over multiple overlapping glyphs at once).
        pub fn hit_test(&self, position: LogicalPosition)  -> crate::vec::InlineTextHitVec { unsafe { crate::dll::AzInlineText_hitTest(self, position) } }
    }

    #[cfg(feature = "link_static")]
    impl InlineTextCrossCrateImpl {

        /// Hit-tests the inline text, returns detailed information about which glyph / word / line, etc. the position (usually the mouse cursor) is currently over. Result may be empty (no hits) or contain more than one result (cursor is hovering over multiple overlapping glyphs at once).
        pub fn hit_test(&self, position: LogicalPosition)  -> crate::vec::InlineTextHitVec {  unsafe { core::mem::transmute(unsafe { azul::AzInlineText_hitTest(&self._0, position._0) }) } }
    }

    /// `InlineLine` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineLine as InlineLine;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineLineCrossCrateImpl { pub _0: azul::AzInlineLine }

    #[cfg(feature = "link_static")] pub use InlineLineCrossCrateImpl as InlineLine;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineLineCrossCrateImpl { type Target = AzInlineLine; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineLineCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineWord` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineWord as InlineWord;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineWordCrossCrateImpl { pub _0: azul::AzInlineWord }

    #[cfg(feature = "link_static")] pub use InlineWordCrossCrateImpl as InlineWord;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineWordCrossCrateImpl { type Target = AzInlineWord; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineWordCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineTextContents` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineTextContents as InlineTextContents;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextContentsCrossCrateImpl { pub _0: azul::AzInlineTextContents }

    #[cfg(feature = "link_static")] pub use InlineTextContentsCrossCrateImpl as InlineTextContents;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextContentsCrossCrateImpl { type Target = AzInlineTextContents; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextContentsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineGlyph` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineGlyph as InlineGlyph;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineGlyphCrossCrateImpl { pub _0: azul::AzInlineGlyph }

    #[cfg(feature = "link_static")] pub use InlineGlyphCrossCrateImpl as InlineGlyph;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineGlyphCrossCrateImpl { type Target = AzInlineGlyph; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineGlyphCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineTextHit` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineTextHit as InlineTextHit;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextHitCrossCrateImpl { pub _0: azul::AzInlineTextHit }

    #[cfg(feature = "link_static")] pub use InlineTextHitCrossCrateImpl as InlineTextHit;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextHitCrossCrateImpl { type Target = AzInlineTextHit; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextHitCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Defines the keyboard input focus target
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFocusTarget as FocusTarget;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FocusTargetCrossCrateImpl { pub _0: azul::AzFocusTarget }

    #[cfg(feature = "link_static")] pub use FocusTargetCrossCrateImpl as FocusTarget;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FocusTargetCrossCrateImpl { type Target = AzFocusTarget; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FocusTargetCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// CSS path to set the keyboard input focus
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFocusTargetPath as FocusTargetPath;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FocusTargetPathCrossCrateImpl { pub _0: azul::AzFocusTargetPath }

    #[cfg(feature = "link_static")] pub use FocusTargetPathCrossCrateImpl as FocusTargetPath;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FocusTargetPathCrossCrateImpl { type Target = AzFocusTargetPath; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FocusTargetPathCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ResolvedTextLayoutOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResolvedTextLayoutOptions as ResolvedTextLayoutOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResolvedTextLayoutOptionsCrossCrateImpl { pub _0: azul::AzResolvedTextLayoutOptions }

    #[cfg(feature = "link_static")] pub use ResolvedTextLayoutOptionsCrossCrateImpl as ResolvedTextLayoutOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResolvedTextLayoutOptionsCrossCrateImpl { type Target = AzResolvedTextLayoutOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResolvedTextLayoutOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ResolvedTextLayoutOptions {

        /// Creates a new `ResolvedTextLayoutOptions` instance.
        pub fn default() -> Self { unsafe { crate::dll::AzResolvedTextLayoutOptions_default() } }
    }

    #[cfg(feature = "link_static")]
    impl ResolvedTextLayoutOptionsCrossCrateImpl {

        /// Creates a new `ResolvedTextLayoutOptions` instance.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzResolvedTextLayoutOptions_default() }) } }
    }

    /// Animation struct to start a new animation
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAnimation as Animation;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AnimationCrossCrateImpl { pub _0: azul::AzAnimation }

    #[cfg(feature = "link_static")] pub use AnimationCrossCrateImpl as Animation;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AnimationCrossCrateImpl { type Target = AzAnimation; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AnimationCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// How should an animation repeat (loop, ping-pong, etc.)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAnimationRepeat as AnimationRepeat;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AnimationRepeatCrossCrateImpl { pub _0: azul::AzAnimationRepeat }

    #[cfg(feature = "link_static")] pub use AnimationRepeatCrossCrateImpl as AnimationRepeat;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AnimationRepeatCrossCrateImpl { type Target = AzAnimationRepeat; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AnimationRepeatCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// How many times should an animation repeat
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAnimationRepeatCount as AnimationRepeatCount;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AnimationRepeatCountCrossCrateImpl { pub _0: azul::AzAnimationRepeatCount }

    #[cfg(feature = "link_static")] pub use AnimationRepeatCountCrossCrateImpl as AnimationRepeatCount;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AnimationRepeatCountCrossCrateImpl { type Target = AzAnimationRepeatCount; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AnimationRepeatCountCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Easing function of the animation (ease-in, ease-out, ease-in-out, custom)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAnimationEasing as AnimationEasing;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AnimationEasingCrossCrateImpl { pub _0: azul::AzAnimationEasing }

    #[cfg(feature = "link_static")] pub use AnimationEasingCrossCrateImpl as AnimationEasing;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AnimationEasingCrossCrateImpl { type Target = AzAnimationEasing; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AnimationEasingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI wrapper over an `IFrameCallbackType`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIFrameCallback as IFrameCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IFrameCallbackCrossCrateImpl { pub _0: azul::AzIFrameCallback }

    #[cfg(feature = "link_static")] pub use IFrameCallbackCrossCrateImpl as IFrameCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IFrameCallbackCrossCrateImpl { type Target = AzIFrameCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IFrameCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// For rendering large or infinite datasets such as tables or lists, azul uses `IFrameCallbacks` that allow the library user to only render the visible portion of DOM nodes, not the entire set. IFrames are rendered after the screen has been laid out, but before it gets composited. IFrames can be used recursively (i.e. iframes within iframes are possible). IFrames are re-rendered once the user scrolls to the bounds (see `IFrameCallbackReturn` on how to set the bounds) or the parent DOM was recreated.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIFrameCallbackType as IFrameCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IFrameCallbackTypeCrossCrateImpl { pub _0: azul::AzIFrameCallbackType }

    #[cfg(feature = "link_static")] pub use IFrameCallbackTypeCrossCrateImpl as IFrameCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IFrameCallbackTypeCrossCrateImpl { type Target = AzIFrameCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IFrameCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `IFrameCallbackInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIFrameCallbackInfo as IFrameCallbackInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IFrameCallbackInfoCrossCrateImpl { pub _0: azul::AzIFrameCallbackInfo }

    #[cfg(feature = "link_static")] pub use IFrameCallbackInfoCrossCrateImpl as IFrameCallbackInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IFrameCallbackInfoCrossCrateImpl { type Target = AzIFrameCallbackInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IFrameCallbackInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// <img src="../images/scrollbounds.png"/>
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIFrameCallbackReturn as IFrameCallbackReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IFrameCallbackReturnCrossCrateImpl { pub _0: azul::AzIFrameCallbackReturn }

    #[cfg(feature = "link_static")] pub use IFrameCallbackReturnCrossCrateImpl as IFrameCallbackReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IFrameCallbackReturnCrossCrateImpl { type Target = AzIFrameCallbackReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IFrameCallbackReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RenderImageCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRenderImageCallback as RenderImageCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RenderImageCallbackCrossCrateImpl { pub _0: azul::AzRenderImageCallback }

    #[cfg(feature = "link_static")] pub use RenderImageCallbackCrossCrateImpl as RenderImageCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RenderImageCallbackCrossCrateImpl { type Target = AzRenderImageCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RenderImageCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RenderImageCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRenderImageCallbackType as RenderImageCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RenderImageCallbackTypeCrossCrateImpl { pub _0: azul::AzRenderImageCallbackType }

    #[cfg(feature = "link_static")] pub use RenderImageCallbackTypeCrossCrateImpl as RenderImageCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RenderImageCallbackTypeCrossCrateImpl { type Target = AzRenderImageCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RenderImageCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RenderImageCallbackInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRenderImageCallbackInfo as RenderImageCallbackInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RenderImageCallbackInfoCrossCrateImpl { pub _0: azul::AzRenderImageCallbackInfo }

    #[cfg(feature = "link_static")] pub use RenderImageCallbackInfoCrossCrateImpl as RenderImageCallbackInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RenderImageCallbackInfoCrossCrateImpl { type Target = AzRenderImageCallbackInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RenderImageCallbackInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl RenderImageCallbackInfo {

        /// Returns a copy of the internal `Gl`
        pub fn get_gl_context(&self)  -> crate::option::OptionGl { unsafe { crate::dll::AzRenderImageCallbackInfo_getGlContext(self) } }
        /// Returns a copy of the internal `HidpiAdjustedBounds`
        pub fn get_bounds(&self)  -> crate::callbacks::HidpiAdjustedBounds { unsafe { crate::dll::AzRenderImageCallbackInfo_getBounds(self) } }
        /// Returns the `DomNodeId` that this callback was called on
        pub fn get_callback_node_id(&self)  -> crate::callbacks::DomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getCallbackNodeId(self) } }
        /// If the node is a `Text` node, returns the layouted inline glyphs
        pub fn get_inline_text(&self, node_id: DomNodeId)  -> crate::option::OptionInlineText { unsafe { crate::dll::AzRenderImageCallbackInfo_getInlineText(self, node_id) } }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent(&mut self, node_id: DomNodeId)  -> usize { unsafe { crate::dll::AzRenderImageCallbackInfo_getIndexInParent(self, node_id) } }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_parent(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getParent(self, node_id) } }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_previous_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getPreviousSibling(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_next_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getNextSibling(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_first_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getFirstChild(self, node_id) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_last_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId { unsafe { crate::dll::AzRenderImageCallbackInfo_getLastChild(self, node_id) } }
    }

    #[cfg(feature = "link_static")]
    impl RenderImageCallbackInfoCrossCrateImpl {

        /// Returns a copy of the internal `Gl`
        pub fn get_gl_context(&self)  -> crate::option::OptionGl {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getGlContext(&self._0) }) } }
        /// Returns a copy of the internal `HidpiAdjustedBounds`
        pub fn get_bounds(&self)  -> crate::callbacks::HidpiAdjustedBounds {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getBounds(&self._0) }) } }
        /// Returns the `DomNodeId` that this callback was called on
        pub fn get_callback_node_id(&self)  -> crate::callbacks::DomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getCallbackNodeId(&self._0) }) } }
        /// If the node is a `Text` node, returns the layouted inline glyphs
        pub fn get_inline_text(&self, node_id: DomNodeId)  -> crate::option::OptionInlineText {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getInlineText(&self._0, node_id._0) }) } }
        /// Returns the index of the node relative to the parent node.
        pub fn get_index_in_parent(&mut self, node_id: DomNodeId)  -> usize {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getIndexInParent(&mut self._0, node_id._0) }) } }
        /// Returns the parent `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_parent(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getParent(&mut self._0, node_id._0) }) } }
        /// Returns the previous siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_previous_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getPreviousSibling(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_next_sibling(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getNextSibling(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_first_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getFirstChild(&mut self._0, node_id._0) }) } }
        /// Returns the next siblings `DomNodeId` of the given `DomNodeId`. Returns `None` on an invalid NodeId.
        pub fn get_last_child(&mut self, node_id: DomNodeId)  -> crate::option::OptionDomNodeId {  unsafe { core::mem::transmute(unsafe { azul::AzRenderImageCallbackInfo_getLastChild(&mut self._0, node_id._0) }) } }
    }

    /// `TimerCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimerCallback as TimerCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerCallbackCrossCrateImpl { pub _0: azul::AzTimerCallback }

    #[cfg(feature = "link_static")] pub use TimerCallbackCrossCrateImpl as TimerCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerCallbackCrossCrateImpl { type Target = AzTimerCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TimerCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimerCallbackType as TimerCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerCallbackTypeCrossCrateImpl { pub _0: azul::AzTimerCallbackType }

    #[cfg(feature = "link_static")] pub use TimerCallbackTypeCrossCrateImpl as TimerCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerCallbackTypeCrossCrateImpl { type Target = AzTimerCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TimerCallbackInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimerCallbackInfo as TimerCallbackInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerCallbackInfoCrossCrateImpl { pub _0: azul::AzTimerCallbackInfo }

    #[cfg(feature = "link_static")] pub use TimerCallbackInfoCrossCrateImpl as TimerCallbackInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerCallbackInfoCrossCrateImpl { type Target = AzTimerCallbackInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerCallbackInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TimerCallbackReturn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimerCallbackReturn as TimerCallbackReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerCallbackReturnCrossCrateImpl { pub _0: azul::AzTimerCallbackReturn }

    #[cfg(feature = "link_static")] pub use TimerCallbackReturnCrossCrateImpl as TimerCallbackReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerCallbackReturnCrossCrateImpl { type Target = AzTimerCallbackReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerCallbackReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WriteBackCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWriteBackCallbackType as WriteBackCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WriteBackCallbackTypeCrossCrateImpl { pub _0: azul::AzWriteBackCallbackType }

    #[cfg(feature = "link_static")] pub use WriteBackCallbackTypeCrossCrateImpl as WriteBackCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WriteBackCallbackTypeCrossCrateImpl { type Target = AzWriteBackCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WriteBackCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WriteBackCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWriteBackCallback as WriteBackCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WriteBackCallbackCrossCrateImpl { pub _0: azul::AzWriteBackCallback }

    #[cfg(feature = "link_static")] pub use WriteBackCallbackCrossCrateImpl as WriteBackCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WriteBackCallbackCrossCrateImpl { type Target = AzWriteBackCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WriteBackCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadCallback as ThreadCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadCallbackCrossCrateImpl { pub _0: azul::AzThreadCallback }

    #[cfg(feature = "link_static")] pub use ThreadCallbackCrossCrateImpl as ThreadCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadCallbackCrossCrateImpl { type Target = AzThreadCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadCallbackType as ThreadCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadCallbackTypeCrossCrateImpl { pub _0: azul::AzThreadCallbackType }

    #[cfg(feature = "link_static")] pub use ThreadCallbackTypeCrossCrateImpl as ThreadCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadCallbackTypeCrossCrateImpl { type Target = AzThreadCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RefAnyDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRefAnyDestructorType as RefAnyDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RefAnyDestructorTypeCrossCrateImpl { pub _0: azul::AzRefAnyDestructorType }

    #[cfg(feature = "link_static")] pub use RefAnyDestructorTypeCrossCrateImpl as RefAnyDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RefAnyDestructorTypeCrossCrateImpl { type Target = AzRefAnyDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RefAnyDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RefCount` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRefCount as RefCount;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RefCountCrossCrateImpl { pub _0: azul::AzRefCount }

    #[cfg(feature = "link_static")] pub use RefCountCrossCrateImpl as RefCount;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RefCountCrossCrateImpl { type Target = AzRefCount; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RefCountCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl RefCount {

        /// Calls the `RefCount::can_be_shared` function.
        pub fn can_be_shared(&self)  -> bool { unsafe { crate::dll::AzRefCount_canBeShared(self) } }
        /// Calls the `RefCount::can_be_shared_mut` function.
        pub fn can_be_shared_mut(&self)  -> bool { unsafe { crate::dll::AzRefCount_canBeSharedMut(self) } }
        /// Calls the `RefCount::increase_ref` function.
        pub fn increase_ref(&mut self)  { unsafe { crate::dll::AzRefCount_increaseRef(self) } }
        /// Calls the `RefCount::decrease_ref` function.
        pub fn decrease_ref(&mut self)  { unsafe { crate::dll::AzRefCount_decreaseRef(self) } }
        /// Calls the `RefCount::increase_refmut` function.
        pub fn increase_refmut(&mut self)  { unsafe { crate::dll::AzRefCount_increaseRefmut(self) } }
        /// Calls the `RefCount::decrease_refmut` function.
        pub fn decrease_refmut(&mut self)  { unsafe { crate::dll::AzRefCount_decreaseRefmut(self) } }
    }

    #[cfg(feature = "link_static")]
    impl RefCountCrossCrateImpl {

        /// Calls the `RefCount::can_be_shared` function.
        pub fn can_be_shared(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_canBeShared(&self._0) }) } }
        /// Calls the `RefCount::can_be_shared_mut` function.
        pub fn can_be_shared_mut(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_canBeSharedMut(&self._0) }) } }
        /// Calls the `RefCount::increase_ref` function.
        pub fn increase_ref(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_increaseRef(&mut self._0) }) } }
        /// Calls the `RefCount::decrease_ref` function.
        pub fn decrease_ref(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_decreaseRef(&mut self._0) }) } }
        /// Calls the `RefCount::increase_refmut` function.
        pub fn increase_refmut(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_increaseRefmut(&mut self._0) }) } }
        /// Calls the `RefCount::decrease_refmut` function.
        pub fn decrease_refmut(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzRefCount_decreaseRefmut(&mut self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for RefCount { fn clone(&self) -> Self { unsafe { crate::dll::AzRefCount_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for RefCount { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzRefCount_delete(self) } } } }
    /// RefAny is a reference-counted, opaque pointer, which stores a reference to a struct. `RefAny` can be up- and downcasted (this usually done via generics and can't be expressed in the Rust API)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRefAny as RefAny;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RefAnyCrossCrateImpl { pub _0: azul::AzRefAny }

    #[cfg(feature = "link_static")] pub use RefAnyCrossCrateImpl as RefAny;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RefAnyCrossCrateImpl { type Target = AzRefAny; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RefAnyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl RefAny {

        /// Creates a new `RefAny` instance.
        pub fn new_c(ptr: *const c_void, len: usize, type_id: u64, type_name: String, destructor: RefAnyDestructorType) -> Self { unsafe { crate::dll::AzRefAny_newC(ptr, len, type_id, type_name, destructor) } }
        /// Calls the `RefAny::get_type_id` function.
        pub fn get_type_id(&self)  -> u64 { unsafe { crate::dll::AzRefAny_getTypeId(self) } }
        /// Calls the `RefAny::get_type_name` function.
        pub fn get_type_name(&self)  -> crate::str::String { unsafe { crate::dll::AzRefAny_getTypeName(self) } }
    }

    #[cfg(feature = "link_static")]
    impl RefAnyCrossCrateImpl {

        /// Creates a new `RefAny` instance.
        pub fn new_c(ptr: *const c_void, len: usize, type_id: u64, type_name: String, destructor: RefAnyDestructorType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzRefAny_newC(ptr, len, type_id, type_name._0, destructor._0) }) } }
        /// Calls the `RefAny::get_type_id` function.
        pub fn get_type_id(&self)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzRefAny_getTypeId(&self._0) }) } }
        /// Calls the `RefAny::get_type_name` function.
        pub fn get_type_name(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzRefAny_getTypeName(&self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for RefAny { fn clone(&self) -> Self { unsafe { crate::dll::AzRefAny_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for RefAny { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzRefAny_delete(self) } } } }
    /// `LayoutCallbackInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutCallbackInfo as LayoutCallbackInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutCallbackInfoCrossCrateImpl { pub _0: azul::AzLayoutCallbackInfo }

    #[cfg(feature = "link_static")] pub use LayoutCallbackInfoCrossCrateImpl as LayoutCallbackInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutCallbackInfoCrossCrateImpl { type Target = AzLayoutCallbackInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutCallbackInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl LayoutCallbackInfo {

        /// Returns a copy of the OpenGL context
        pub fn get_gl_context(&self)  -> crate::option::OptionGl { unsafe { crate::dll::AzLayoutCallbackInfo_getGlContext(self) } }
        /// Returns all system-native fonts with their respective file paths as values
        pub fn get_system_fonts(&self)  -> crate::vec::StringPairVec { unsafe { crate::dll::AzLayoutCallbackInfo_getSystemFonts(self) } }
        /// Returns an `ImageRef` referenced by a CSS ID
        pub fn get_image(&self, id: String)  -> crate::option::OptionImageRef { unsafe { crate::dll::AzLayoutCallbackInfo_getImage(self, id) } }
    }

    #[cfg(feature = "link_static")]
    impl LayoutCallbackInfoCrossCrateImpl {

        /// Returns a copy of the OpenGL context
        pub fn get_gl_context(&self)  -> crate::option::OptionGl {  unsafe { core::mem::transmute(unsafe { azul::AzLayoutCallbackInfo_getGlContext(&self._0) }) } }
        /// Returns all system-native fonts with their respective file paths as values
        pub fn get_system_fonts(&self)  -> crate::vec::StringPairVec {  unsafe { core::mem::transmute(unsafe { azul::AzLayoutCallbackInfo_getSystemFonts(&self._0) }) } }
        /// Returns an `ImageRef` referenced by a CSS ID
        pub fn get_image(&self, id: String)  -> crate::option::OptionImageRef {  unsafe { core::mem::transmute(unsafe { azul::AzLayoutCallbackInfo_getImage(&self._0, id._0) }) } }
    }

}

pub mod dom {
    #![allow(dead_code, unused_imports)]
    //! `Dom` construction and configuration
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    #[cfg(not(feature = "link_static"))]
    impl Default for Dom {
        fn default() -> Self {
            Dom::div()
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Default for NodeData {
        fn default() -> Self {
            NodeData::new(NodeType::Div)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Default for TabIndex {
        fn default() -> Self {
            TabIndex::Auto
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl core::iter::FromIterator<Dom> for Dom {
        fn from_iter<I: IntoIterator<Item=Dom>>(iter: I) -> Self {
            use crate::vec::DomVec;
            let mut total_children = 0;
            let children = iter.into_iter().map(|c| {
                total_children += c.total_children + 1;
                c
            }).collect::<DomVec>();

            Dom {
                root: NodeData::div(),
                children,
                total_children,
            }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl core::iter::FromIterator<NodeData> for Dom {
        fn from_iter<I: IntoIterator<Item=NodeData>>(iter: I) -> Self {
            use crate::vec::DomVec;
            let children = iter.into_iter().map(|c| Dom {
                root: c,
                children: DomVec::from_const_slice(&[]),
                total_children: 0
            }).collect::<DomVec>();
            let total_children = children.len();

            Dom {
                root: NodeData::div(),
                children: children,
                total_children,
            }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl core::iter::FromIterator<NodeType> for Dom {
        fn from_iter<I: core::iter::IntoIterator<Item=NodeType>>(iter: I) -> Self {
            iter.into_iter().map(|i| {
                let mut nd = NodeData::default();
                nd.node_type = i;
                nd
            }).collect()
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<On> for AzEventFilter {
        fn from(on: On) -> AzEventFilter {
            on.into_event_filter()
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl NodeData {
        pub const fn const_new(node_type: NodeType) -> Self {
            use crate::option::{OptionRefAny, OptionTabIndex};
            Self {
                node_type,
                dataset: OptionRefAny::None,
                ids_and_classes: IdOrClassVec::from_const_slice(&[]),
                callbacks: CallbackDataVec::from_const_slice(&[]),
                inline_css_props: NodeDataInlineCssPropertyVec::from_const_slice(&[]),
                tab_index: OptionTabIndex::None,
                extra: ::core::ptr::null_mut(),
            }
        }

        pub const fn const_body() -> Self {
            Self::const_new(NodeType::Body)
        }

        pub const fn const_div() -> Self {
            Self::const_new(NodeType::Div)
        }

        pub const fn const_text(text: AzString) -> Self {
            Self::const_new(NodeType::Text(text))
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Dom {

        pub const fn const_new(node_data: NodeData) -> Self {
            Dom {
                root: node_data,
                children: DomVec::from_const_slice(&[]),
                total_children: 0,
            }
        }

        pub const fn const_body() -> Self {
            Self::const_new(NodeData::const_body())
        }

        pub const fn const_div() -> Self {
            Self::const_new(NodeData::const_div())
        }

        pub const fn const_text(text: AzString) -> Self {
            Self::const_new(NodeData::const_text(text))
        }
    }    use crate::str::String;
    use crate::image::{ImageMask, ImageRef};
    use crate::callbacks::{CallbackType, IFrameCallbackType, RefAny};
    use crate::vec::{CallbackDataVec, DomVec, IdOrClassVec, NodeDataInlineCssPropertyVec};
    use crate::css::{Css, CssProperty};
    use crate::menu::Menu;
    /// `Dom` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDom as Dom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomCrossCrateImpl { pub _0: azul::AzDom }

    #[cfg(feature = "link_static")] pub use DomCrossCrateImpl as Dom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomCrossCrateImpl { type Target = AzDom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Dom {

        /// Creates a new `Dom` instance.
        pub fn new(node_type: NodeType) -> Self { unsafe { crate::dll::AzDom_new(node_type) } }
        /// Creates a new `Dom` instance.
        pub fn body() -> Self { unsafe { crate::dll::AzDom_body() } }
        /// Creates a new `Dom` instance.
        pub fn div() -> Self { unsafe { crate::dll::AzDom_div() } }
        /// Creates a new `Dom` instance.
        pub fn br() -> Self { unsafe { crate::dll::AzDom_br() } }
        /// Creates a new `Dom` instance.
        pub fn text(string: String) -> Self { unsafe { crate::dll::AzDom_text(string) } }
        /// Creates a new `Dom` instance.
        pub fn image(image: ImageRef) -> Self { unsafe { crate::dll::AzDom_image(image) } }
        /// Creates a new `Dom` instance.
        pub fn iframe(data: RefAny, callback: IFrameCallbackType) -> Self { unsafe { crate::dll::AzDom_iframe(data, callback) } }
        /// Calls the `Dom::set_node_type` function.
        pub fn set_node_type(&mut self, node_type: NodeType)  { unsafe { crate::dll::AzDom_setNodeType(self, node_type) } }
        /// Calls the `Dom::with_node_type` function.
        pub fn with_node_type(&mut self, node_type: NodeType)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withNodeType(self, node_type) } }
        /// Calls the `Dom::set_dataset` function.
        pub fn set_dataset(&mut self, dataset: RefAny)  { unsafe { crate::dll::AzDom_setDataset(self, dataset) } }
        /// Calls the `Dom::with_dataset` function.
        pub fn with_dataset(&mut self, dataset: RefAny)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withDataset(self, dataset) } }
        /// Calls the `Dom::set_ids_and_classes` function.
        pub fn set_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  { unsafe { crate::dll::AzDom_setIdsAndClasses(self, ids_and_classes) } }
        /// Calls the `Dom::with_ids_and_classes` function.
        pub fn with_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withIdsAndClasses(self, ids_and_classes) } }
        /// Calls the `Dom::set_callbacks` function.
        pub fn set_callbacks(&mut self, callbacks: CallbackDataVec)  { unsafe { crate::dll::AzDom_setCallbacks(self, callbacks) } }
        /// Calls the `Dom::with_callbacks` function.
        pub fn with_callbacks(&mut self, callbacks: CallbackDataVec)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withCallbacks(self, callbacks) } }
        /// Calls the `Dom::set_inline_css_props` function.
        pub fn set_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzDom_setInlineCssProps(self, css_properties) } }
        /// Calls the `Dom::with_inline_css_props` function.
        pub fn with_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withInlineCssProps(self, css_properties) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn add_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  { unsafe { crate::dll::AzDom_addCallback(self, event, data, callback) } }
        /// Same as add_child, but as a builder method.
        pub fn with_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withCallback(self, event, data, callback) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn add_child(&mut self, child: Dom)  { unsafe { crate::dll::AzDom_addChild(self, child) } }
        /// Same as add_child, but as a builder method.
        pub fn with_child(&mut self, child: Dom)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withChild(self, child) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn set_children(&mut self, children: DomVec)  { unsafe { crate::dll::AzDom_setChildren(self, children) } }
        /// Same as set_children, but as a builder method.
        pub fn with_children(&mut self, children: DomVec)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withChildren(self, children) } }
        /// Adds an CSS ID to the DOM root node.
        pub fn add_id(&mut self, id: String)  { unsafe { crate::dll::AzDom_addId(self, id) } }
        /// Same as add_id, but as a builder method
        pub fn with_id(&mut self, id: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withId(self, id) } }
        /// Adds a CSS class to the DOM root node.
        pub fn add_class(&mut self, class: String)  { unsafe { crate::dll::AzDom_addClass(self, class) } }
        /// Same as add_class, but as a builder method
        pub fn with_class(&mut self, class: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withClass(self, class) } }
        /// Adds an inline (normal) CSS property to the DOM root node.
        pub fn add_css_property(&mut self, prop: CssProperty)  { unsafe { crate::dll::AzDom_addCssProperty(self, prop) } }
        /// Same as add_class, but as a builder method
        pub fn with_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withCssProperty(self, prop) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_hover_css_property(&mut self, prop: CssProperty)  { unsafe { crate::dll::AzDom_addHoverCssProperty(self, prop) } }
        /// Same as add_class, but as a builder method
        pub fn with_hover_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withHoverCssProperty(self, prop) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_active_css_property(&mut self, prop: CssProperty)  { unsafe { crate::dll::AzDom_addActiveCssProperty(self, prop) } }
        /// Same as add_class, but as a builder method
        pub fn with_active_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withActiveCssProperty(self, prop) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_focus_css_property(&mut self, prop: CssProperty)  { unsafe { crate::dll::AzDom_addFocusCssProperty(self, prop) } }
        /// Same as add_class, but as a builder method
        pub fn with_focus_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withFocusCssProperty(self, prop) } }
        /// Calls the `Dom::set_inline_style` function.
        pub fn set_inline_style(&mut self, style: String)  { unsafe { crate::dll::AzDom_setInlineStyle(self, style) } }
        /// Calls the `Dom::with_inline_style` function.
        pub fn with_inline_style(&mut self, style: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withInlineStyle(self, style) } }
        /// Calls the `Dom::set_inline_hover_style` function.
        pub fn set_inline_hover_style(&mut self, style: String)  { unsafe { crate::dll::AzDom_setInlineHoverStyle(self, style) } }
        /// Calls the `Dom::with_inline_hover_style` function.
        pub fn with_inline_hover_style(&mut self, style: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withInlineHoverStyle(self, style) } }
        /// Calls the `Dom::set_inline_active_style` function.
        pub fn set_inline_active_style(&mut self, style: String)  { unsafe { crate::dll::AzDom_setInlineActiveStyle(self, style) } }
        /// Calls the `Dom::with_inline_active_style` function.
        pub fn with_inline_active_style(&mut self, style: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withInlineActiveStyle(self, style) } }
        /// Calls the `Dom::set_inline_focus_style` function.
        pub fn set_inline_focus_style(&mut self, style: String)  { unsafe { crate::dll::AzDom_setInlineFocusStyle(self, style) } }
        /// Calls the `Dom::with_inline_focus_style` function.
        pub fn with_inline_focus_style(&mut self, style: String)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withInlineFocusStyle(self, style) } }
        /// Sets the clip mask for the DOM root node.
        pub fn set_clip_mask(&mut self, clip_mask: ImageMask)  { unsafe { crate::dll::AzDom_setClipMask(self, clip_mask) } }
        /// Same as set_clip_mask, but as a builder method
        pub fn with_clip_mask(&mut self, clip_mask: ImageMask)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withClipMask(self, clip_mask) } }
        /// Sets the tab index for the DOM root node.
        pub fn set_tab_index(&mut self, tab_index: TabIndex)  { unsafe { crate::dll::AzDom_setTabIndex(self, tab_index) } }
        /// Same as set_tab_index, but as a builder method
        pub fn with_tab_index(&mut self, tab_index: TabIndex)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withTabIndex(self, tab_index) } }
        /// Sets accessibility attributes for the DOM root node.
        pub fn set_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  { unsafe { crate::dll::AzDom_setAccessibilityInfo(self, accessibility_info) } }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withAccessibilityInfo(self, accessibility_info) } }
        /// Sets the menu bar for the DOM root node. See `NodeData::set_menu_bar` for more information.
        pub fn set_menu_bar(&mut self, menu_bar: Menu)  { unsafe { crate::dll::AzDom_setMenuBar(self, menu_bar) } }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_menu_bar(&mut self, menu_bar: Menu)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withMenuBar(self, menu_bar) } }
        /// Sets the context menu for the DOM root node. See `NodeData::set_context_menu` for more information.
        pub fn set_context_menu(&mut self, context_menu: Menu)  { unsafe { crate::dll::AzDom_setContextMenu(self, context_menu) } }
        /// Same as set_context_menu, but as a builder method
        pub fn with_context_menu(&mut self, context_menu: Menu)  -> crate::dom::Dom { unsafe { crate::dll::AzDom_withContextMenu(self, context_menu) } }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
        pub fn hash(&self)  -> u64 { unsafe { crate::dll::AzDom_hash(self) } }
        /// Returns the number of nodes in the DOM, including all child DOM trees. Result is equal to `self.total_children + 1` (count of all child trees + the root node)
        pub fn node_count(&self)  -> usize { unsafe { crate::dll::AzDom_nodeCount(self) } }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
        pub fn get_html_string(&mut self)  -> crate::str::String { unsafe { crate::dll::AzDom_getHtmlString(self) } }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&mut self)  -> crate::str::String { unsafe { crate::dll::AzDom_getHtmlStringTest(self) } }
        /// Same as `StyledDom::new(dom, css)`: NOTE - replaces self with an empty DOM, in order to prevent cloning the DOM entirely
        pub fn style(&mut self, css: Css)  -> crate::style::StyledDom { unsafe { crate::dll::AzDom_style(self, css) } }
    }

    #[cfg(feature = "link_static")]
    impl DomCrossCrateImpl {

        /// Creates a new `Dom` instance.
        pub fn new(node_type: NodeType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_new(node_type._0) }) } }
        /// Creates a new `Dom` instance.
        pub fn body() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_body() }) } }
        /// Creates a new `Dom` instance.
        pub fn div() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_div() }) } }
        /// Creates a new `Dom` instance.
        pub fn br() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_br() }) } }
        /// Creates a new `Dom` instance.
        pub fn text(string: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_text(string._0) }) } }
        /// Creates a new `Dom` instance.
        pub fn image(image: ImageRef) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_image(image._0) }) } }
        /// Creates a new `Dom` instance.
        pub fn iframe(data: RefAny, callback: IFrameCallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDom_iframe(data._0, callback._0) }) } }
        /// Calls the `Dom::set_node_type` function.
        pub fn set_node_type(&mut self, node_type: NodeType)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setNodeType(&mut self._0, node_type._0) }) } }
        /// Calls the `Dom::with_node_type` function.
        pub fn with_node_type(&mut self, node_type: NodeType)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withNodeType(&mut self._0, node_type._0) }) } }
        /// Calls the `Dom::set_dataset` function.
        pub fn set_dataset(&mut self, dataset: RefAny)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setDataset(&mut self._0, dataset._0) }) } }
        /// Calls the `Dom::with_dataset` function.
        pub fn with_dataset(&mut self, dataset: RefAny)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withDataset(&mut self._0, dataset._0) }) } }
        /// Calls the `Dom::set_ids_and_classes` function.
        pub fn set_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setIdsAndClasses(&mut self._0, ids_and_classes._0) }) } }
        /// Calls the `Dom::with_ids_and_classes` function.
        pub fn with_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withIdsAndClasses(&mut self._0, ids_and_classes._0) }) } }
        /// Calls the `Dom::set_callbacks` function.
        pub fn set_callbacks(&mut self, callbacks: CallbackDataVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setCallbacks(&mut self._0, callbacks._0) }) } }
        /// Calls the `Dom::with_callbacks` function.
        pub fn with_callbacks(&mut self, callbacks: CallbackDataVec)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withCallbacks(&mut self._0, callbacks._0) }) } }
        /// Calls the `Dom::set_inline_css_props` function.
        pub fn set_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setInlineCssProps(&mut self._0, css_properties._0) }) } }
        /// Calls the `Dom::with_inline_css_props` function.
        pub fn with_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withInlineCssProps(&mut self._0, css_properties._0) }) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn add_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addCallback(&mut self._0, event._0, data._0, callback._0) }) } }
        /// Same as add_child, but as a builder method.
        pub fn with_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withCallback(&mut self._0, event._0, data._0, callback._0) }) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn add_child(&mut self, child: Dom)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addChild(&mut self._0, child._0) }) } }
        /// Same as add_child, but as a builder method.
        pub fn with_child(&mut self, child: Dom)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withChild(&mut self._0, child._0) }) } }
        /// Adds a child node to this DOM (potentially heap-allocates in Rust code). Swaps `self` with a default `Dom` in order to prevent accidental copies.
        pub fn set_children(&mut self, children: DomVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setChildren(&mut self._0, children._0) }) } }
        /// Same as set_children, but as a builder method.
        pub fn with_children(&mut self, children: DomVec)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withChildren(&mut self._0, children._0) }) } }
        /// Adds an CSS ID to the DOM root node.
        pub fn add_id(&mut self, id: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addId(&mut self._0, id._0) }) } }
        /// Same as add_id, but as a builder method
        pub fn with_id(&mut self, id: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withId(&mut self._0, id._0) }) } }
        /// Adds a CSS class to the DOM root node.
        pub fn add_class(&mut self, class: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addClass(&mut self._0, class._0) }) } }
        /// Same as add_class, but as a builder method
        pub fn with_class(&mut self, class: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withClass(&mut self._0, class._0) }) } }
        /// Adds an inline (normal) CSS property to the DOM root node.
        pub fn add_css_property(&mut self, prop: CssProperty)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addCssProperty(&mut self._0, prop._0) }) } }
        /// Same as add_class, but as a builder method
        pub fn with_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withCssProperty(&mut self._0, prop._0) }) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_hover_css_property(&mut self, prop: CssProperty)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addHoverCssProperty(&mut self._0, prop._0) }) } }
        /// Same as add_class, but as a builder method
        pub fn with_hover_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withHoverCssProperty(&mut self._0, prop._0) }) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_active_css_property(&mut self, prop: CssProperty)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addActiveCssProperty(&mut self._0, prop._0) }) } }
        /// Same as add_class, but as a builder method
        pub fn with_active_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withActiveCssProperty(&mut self._0, prop._0) }) } }
        /// Adds an inline (hover) CSS property to the DOM root node.
        pub fn add_focus_css_property(&mut self, prop: CssProperty)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_addFocusCssProperty(&mut self._0, prop._0) }) } }
        /// Same as add_class, but as a builder method
        pub fn with_focus_css_property(&mut self, prop: CssProperty)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withFocusCssProperty(&mut self._0, prop._0) }) } }
        /// Calls the `Dom::set_inline_style` function.
        pub fn set_inline_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setInlineStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::with_inline_style` function.
        pub fn with_inline_style(&mut self, style: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withInlineStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::set_inline_hover_style` function.
        pub fn set_inline_hover_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setInlineHoverStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::with_inline_hover_style` function.
        pub fn with_inline_hover_style(&mut self, style: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withInlineHoverStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::set_inline_active_style` function.
        pub fn set_inline_active_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setInlineActiveStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::with_inline_active_style` function.
        pub fn with_inline_active_style(&mut self, style: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withInlineActiveStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::set_inline_focus_style` function.
        pub fn set_inline_focus_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setInlineFocusStyle(&mut self._0, style._0) }) } }
        /// Calls the `Dom::with_inline_focus_style` function.
        pub fn with_inline_focus_style(&mut self, style: String)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withInlineFocusStyle(&mut self._0, style._0) }) } }
        /// Sets the clip mask for the DOM root node.
        pub fn set_clip_mask(&mut self, clip_mask: ImageMask)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setClipMask(&mut self._0, clip_mask._0) }) } }
        /// Same as set_clip_mask, but as a builder method
        pub fn with_clip_mask(&mut self, clip_mask: ImageMask)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withClipMask(&mut self._0, clip_mask._0) }) } }
        /// Sets the tab index for the DOM root node.
        pub fn set_tab_index(&mut self, tab_index: TabIndex)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setTabIndex(&mut self._0, tab_index._0) }) } }
        /// Same as set_tab_index, but as a builder method
        pub fn with_tab_index(&mut self, tab_index: TabIndex)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withTabIndex(&mut self._0, tab_index._0) }) } }
        /// Sets accessibility attributes for the DOM root node.
        pub fn set_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setAccessibilityInfo(&mut self._0, accessibility_info._0) }) } }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withAccessibilityInfo(&mut self._0, accessibility_info._0) }) } }
        /// Sets the menu bar for the DOM root node. See `NodeData::set_menu_bar` for more information.
        pub fn set_menu_bar(&mut self, menu_bar: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setMenuBar(&mut self._0, menu_bar._0) }) } }
        /// Same as set_accessibility_info, but as a builder method
        pub fn with_menu_bar(&mut self, menu_bar: Menu)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withMenuBar(&mut self._0, menu_bar._0) }) } }
        /// Sets the context menu for the DOM root node. See `NodeData::set_context_menu` for more information.
        pub fn set_context_menu(&mut self, context_menu: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzDom_setContextMenu(&mut self._0, context_menu._0) }) } }
        /// Same as set_context_menu, but as a builder method
        pub fn with_context_menu(&mut self, context_menu: Menu)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_withContextMenu(&mut self._0, context_menu._0) }) } }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
        pub fn hash(&self)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzDom_hash(&self._0) }) } }
        /// Returns the number of nodes in the DOM, including all child DOM trees. Result is equal to `self.total_children + 1` (count of all child trees + the root node)
        pub fn node_count(&self)  -> usize {  unsafe { core::mem::transmute(unsafe { azul::AzDom_nodeCount(&self._0) }) } }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
        pub fn get_html_string(&mut self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzDom_getHtmlString(&mut self._0) }) } }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&mut self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzDom_getHtmlStringTest(&mut self._0) }) } }
        /// Same as `StyledDom::new(dom, css)`: NOTE - replaces self with an empty DOM, in order to prevent cloning the DOM entirely
        pub fn style(&mut self, css: Css)  -> crate::style::StyledDom {  unsafe { core::mem::transmute(unsafe { azul::AzDom_style(&mut self._0, css._0) }) } }
    }

    /// `IFrameNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIFrameNode as IFrameNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IFrameNodeCrossCrateImpl { pub _0: azul::AzIFrameNode }

    #[cfg(feature = "link_static")] pub use IFrameNodeCrossCrateImpl as IFrameNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IFrameNodeCrossCrateImpl { type Target = AzIFrameNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IFrameNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CallbackData` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackData as CallbackData;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackDataCrossCrateImpl { pub _0: azul::AzCallbackData }

    #[cfg(feature = "link_static")] pub use CallbackDataCrossCrateImpl as CallbackData;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackDataCrossCrateImpl { type Target = AzCallbackData; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackDataCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Represents one single DOM node (node type, classes, ids and callbacks are stored here)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeData as NodeData;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataCrossCrateImpl { pub _0: azul::AzNodeData }

    #[cfg(feature = "link_static")] pub use NodeDataCrossCrateImpl as NodeData;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataCrossCrateImpl { type Target = AzNodeData; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl NodeData {

        /// Creates an new, empty `NodeData` struct
        pub fn new(node_type: NodeType) -> Self { unsafe { crate::dll::AzNodeData_new(node_type) } }
        /// Creates a new `NodeData` instance.
        pub fn body() -> Self { unsafe { crate::dll::AzNodeData_body() } }
        /// Creates a new `NodeData` instance.
        pub fn div() -> Self { unsafe { crate::dll::AzNodeData_div() } }
        /// Creates a new `NodeData` instance.
        pub fn br() -> Self { unsafe { crate::dll::AzNodeData_br() } }
        /// Creates a new `NodeData` instance.
        pub fn text(string: String) -> Self { unsafe { crate::dll::AzNodeData_text(string) } }
        /// Creates a new `NodeData` instance.
        pub fn image(image: ImageRef) -> Self { unsafe { crate::dll::AzNodeData_image(image) } }
        /// Creates a new `NodeData` instance.
        pub fn iframe(data: RefAny, callback: IFrameCallbackType) -> Self { unsafe { crate::dll::AzNodeData_iframe(data, callback) } }
        /// Calls the `NodeData::set_node_type` function.
        pub fn set_node_type(&mut self, node_type: NodeType)  { unsafe { crate::dll::AzNodeData_setNodeType(self, node_type) } }
        /// Calls the `NodeData::with_node_type` function.
        pub fn with_node_type(&mut self, node_type: NodeType)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withNodeType(self, node_type) } }
        /// Calls the `NodeData::set_dataset` function.
        pub fn set_dataset(&mut self, dataset: RefAny)  { unsafe { crate::dll::AzNodeData_setDataset(self, dataset) } }
        /// Calls the `NodeData::with_dataset` function.
        pub fn with_dataset(&mut self, dataset: RefAny)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withDataset(self, dataset) } }
        /// Calls the `NodeData::set_ids_and_classes` function.
        pub fn set_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  { unsafe { crate::dll::AzNodeData_setIdsAndClasses(self, ids_and_classes) } }
        /// Calls the `NodeData::with_ids_and_classes` function.
        pub fn with_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withIdsAndClasses(self, ids_and_classes) } }
        /// Adds a callback this DOM (potentially heap-allocates in Rust code)
        pub fn add_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  { unsafe { crate::dll::AzNodeData_addCallback(self, event, data, callback) } }
        /// Same as add_child, but as a builder method.
        pub fn with_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withCallback(self, event, data, callback) } }
        /// Calls the `NodeData::set_callbacks` function.
        pub fn set_callbacks(&mut self, callbacks: CallbackDataVec)  { unsafe { crate::dll::AzNodeData_setCallbacks(self, callbacks) } }
        /// Calls the `NodeData::with_callbacks` function.
        pub fn with_callbacks(&mut self, callbacks: CallbackDataVec)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withCallbacks(self, callbacks) } }
        /// Calls the `NodeData::set_inline_css_props` function.
        pub fn set_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzNodeData_setInlineCssProps(self, css_properties) } }
        /// Calls the `NodeData::with_inline_css_props` function.
        pub fn with_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withInlineCssProps(self, css_properties) } }
        /// Calls the `NodeData::set_inline_style` function.
        pub fn set_inline_style(&mut self, style: String)  { unsafe { crate::dll::AzNodeData_setInlineStyle(self, style) } }
        /// Calls the `NodeData::with_inline_style` function.
        pub fn with_inline_style(&mut self, style: String)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withInlineStyle(self, style) } }
        /// Calls the `NodeData::set_inline_hover_style` function.
        pub fn set_inline_hover_style(&mut self, style: String)  { unsafe { crate::dll::AzNodeData_setInlineHoverStyle(self, style) } }
        /// Calls the `NodeData::with_inline_hover_style` function.
        pub fn with_inline_hover_style(&mut self, style: String)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withInlineHoverStyle(self, style) } }
        /// Calls the `NodeData::set_inline_active_style` function.
        pub fn set_inline_active_style(&mut self, style: String)  { unsafe { crate::dll::AzNodeData_setInlineActiveStyle(self, style) } }
        /// Calls the `NodeData::with_inline_active_style` function.
        pub fn with_inline_active_style(&mut self, style: String)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withInlineActiveStyle(self, style) } }
        /// Calls the `NodeData::set_inline_focus_style` function.
        pub fn set_inline_focus_style(&mut self, style: String)  { unsafe { crate::dll::AzNodeData_setInlineFocusStyle(self, style) } }
        /// Calls the `NodeData::with_inline_focus_style` function.
        pub fn with_inline_focus_style(&mut self, style: String)  -> crate::dom::NodeData { unsafe { crate::dll::AzNodeData_withInlineFocusStyle(self, style) } }
        /// Sets the `extra.clip_mask` field for this node
        pub fn set_clip_mask(&mut self, image_mask: ImageMask)  { unsafe { crate::dll::AzNodeData_setClipMask(self, image_mask) } }
        /// Sets the tab index for this node
        pub fn set_tab_index(&mut self, tab_index: TabIndex)  { unsafe { crate::dll::AzNodeData_setTabIndex(self, tab_index) } }
        /// Sets accessibility attributes for this node
        pub fn set_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  { unsafe { crate::dll::AzNodeData_setAccessibilityInfo(self, accessibility_info) } }
        /// Adds a (native) menu bar: If this node is the root node the menu bar will be added to the window, else it will be displayed using the width and position of the bounding rectangle
        pub fn set_menu_bar(&mut self, menu_bar: Menu)  { unsafe { crate::dll::AzNodeData_setMenuBar(self, menu_bar) } }
        /// Signalizes that this node has a (native) context-aware menu. If set, the user can left-click the node to open the menu
        pub fn set_context_menu(&mut self, context_menu: Menu)  { unsafe { crate::dll::AzNodeData_setContextMenu(self, context_menu) } }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
        pub fn hash(&self)  -> u64 { unsafe { crate::dll::AzNodeData_hash(self) } }
    }

    #[cfg(feature = "link_static")]
    impl NodeDataCrossCrateImpl {

        /// Creates an new, empty `NodeData` struct
        pub fn new(node_type: NodeType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_new(node_type._0) }) } }
        /// Creates a new `NodeData` instance.
        pub fn body() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_body() }) } }
        /// Creates a new `NodeData` instance.
        pub fn div() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_div() }) } }
        /// Creates a new `NodeData` instance.
        pub fn br() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_br() }) } }
        /// Creates a new `NodeData` instance.
        pub fn text(string: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_text(string._0) }) } }
        /// Creates a new `NodeData` instance.
        pub fn image(image: ImageRef) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_image(image._0) }) } }
        /// Creates a new `NodeData` instance.
        pub fn iframe(data: RefAny, callback: IFrameCallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNodeData_iframe(data._0, callback._0) }) } }
        /// Calls the `NodeData::set_node_type` function.
        pub fn set_node_type(&mut self, node_type: NodeType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setNodeType(&mut self._0, node_type._0) }) } }
        /// Calls the `NodeData::with_node_type` function.
        pub fn with_node_type(&mut self, node_type: NodeType)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withNodeType(&mut self._0, node_type._0) }) } }
        /// Calls the `NodeData::set_dataset` function.
        pub fn set_dataset(&mut self, dataset: RefAny)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setDataset(&mut self._0, dataset._0) }) } }
        /// Calls the `NodeData::with_dataset` function.
        pub fn with_dataset(&mut self, dataset: RefAny)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withDataset(&mut self._0, dataset._0) }) } }
        /// Calls the `NodeData::set_ids_and_classes` function.
        pub fn set_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setIdsAndClasses(&mut self._0, ids_and_classes._0) }) } }
        /// Calls the `NodeData::with_ids_and_classes` function.
        pub fn with_ids_and_classes(&mut self, ids_and_classes: IdOrClassVec)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withIdsAndClasses(&mut self._0, ids_and_classes._0) }) } }
        /// Adds a callback this DOM (potentially heap-allocates in Rust code)
        pub fn add_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_addCallback(&mut self._0, event._0, data._0, callback._0) }) } }
        /// Same as add_child, but as a builder method.
        pub fn with_callback(&mut self, event: EventFilter, data: RefAny, callback: CallbackType)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withCallback(&mut self._0, event._0, data._0, callback._0) }) } }
        /// Calls the `NodeData::set_callbacks` function.
        pub fn set_callbacks(&mut self, callbacks: CallbackDataVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setCallbacks(&mut self._0, callbacks._0) }) } }
        /// Calls the `NodeData::with_callbacks` function.
        pub fn with_callbacks(&mut self, callbacks: CallbackDataVec)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withCallbacks(&mut self._0, callbacks._0) }) } }
        /// Calls the `NodeData::set_inline_css_props` function.
        pub fn set_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setInlineCssProps(&mut self._0, css_properties._0) }) } }
        /// Calls the `NodeData::with_inline_css_props` function.
        pub fn with_inline_css_props(&mut self, css_properties: NodeDataInlineCssPropertyVec)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withInlineCssProps(&mut self._0, css_properties._0) }) } }
        /// Calls the `NodeData::set_inline_style` function.
        pub fn set_inline_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setInlineStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::with_inline_style` function.
        pub fn with_inline_style(&mut self, style: String)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withInlineStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::set_inline_hover_style` function.
        pub fn set_inline_hover_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setInlineHoverStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::with_inline_hover_style` function.
        pub fn with_inline_hover_style(&mut self, style: String)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withInlineHoverStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::set_inline_active_style` function.
        pub fn set_inline_active_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setInlineActiveStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::with_inline_active_style` function.
        pub fn with_inline_active_style(&mut self, style: String)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withInlineActiveStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::set_inline_focus_style` function.
        pub fn set_inline_focus_style(&mut self, style: String)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setInlineFocusStyle(&mut self._0, style._0) }) } }
        /// Calls the `NodeData::with_inline_focus_style` function.
        pub fn with_inline_focus_style(&mut self, style: String)  -> crate::dom::NodeData {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_withInlineFocusStyle(&mut self._0, style._0) }) } }
        /// Sets the `extra.clip_mask` field for this node
        pub fn set_clip_mask(&mut self, image_mask: ImageMask)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setClipMask(&mut self._0, image_mask._0) }) } }
        /// Sets the tab index for this node
        pub fn set_tab_index(&mut self, tab_index: TabIndex)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setTabIndex(&mut self._0, tab_index._0) }) } }
        /// Sets accessibility attributes for this node
        pub fn set_accessibility_info(&mut self, accessibility_info: AccessibilityInfo)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setAccessibilityInfo(&mut self._0, accessibility_info._0) }) } }
        /// Adds a (native) menu bar: If this node is the root node the menu bar will be added to the window, else it will be displayed using the width and position of the bounding rectangle
        pub fn set_menu_bar(&mut self, menu_bar: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setMenuBar(&mut self._0, menu_bar._0) }) } }
        /// Signalizes that this node has a (native) context-aware menu. If set, the user can left-click the node to open the menu
        pub fn set_context_menu(&mut self, context_menu: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_setContextMenu(&mut self._0, context_menu._0) }) } }
        /// Calculates the hash of this node (note: in order to be truly unique, you also have to hash the DOM and Node ID).
        pub fn hash(&self)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzNodeData_hash(&self._0) }) } }
    }

    /// List of core DOM node types built-into by `azul`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeType as NodeType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeCrossCrateImpl { pub _0: azul::AzNodeType }

    #[cfg(feature = "link_static")] pub use NodeTypeCrossCrateImpl as NodeType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeCrossCrateImpl { type Target = AzNodeType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// When to call a callback action - `On::MouseOver`, `On::MouseOut`, etc.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOn as On;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OnCrossCrateImpl { pub _0: azul::AzOn }

    #[cfg(feature = "link_static")] pub use OnCrossCrateImpl as On;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OnCrossCrateImpl { type Target = AzOn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl On {

        /// Converts the `On` shorthand into a `EventFilter`
        pub fn into_event_filter(self)  -> crate::dom::EventFilter { unsafe { crate::dll::AzOn_intoEventFilter(self) } }
    }

    #[cfg(feature = "link_static")]
    impl OnCrossCrateImpl {

        /// Converts the `On` shorthand into a `EventFilter`
        pub fn into_event_filter(self)  -> crate::dom::EventFilter {  unsafe { core::mem::transmute(unsafe { azul::AzOn_intoEventFilter(self._0) }) } }
    }

    /// `EventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzEventFilter as EventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct EventFilterCrossCrateImpl { pub _0: azul::AzEventFilter }

    #[cfg(feature = "link_static")] pub use EventFilterCrossCrateImpl as EventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for EventFilterCrossCrateImpl { type Target = AzEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for EventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `HoverEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzHoverEventFilter as HoverEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct HoverEventFilterCrossCrateImpl { pub _0: azul::AzHoverEventFilter }

    #[cfg(feature = "link_static")] pub use HoverEventFilterCrossCrateImpl as HoverEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for HoverEventFilterCrossCrateImpl { type Target = AzHoverEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for HoverEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FocusEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFocusEventFilter as FocusEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FocusEventFilterCrossCrateImpl { pub _0: azul::AzFocusEventFilter }

    #[cfg(feature = "link_static")] pub use FocusEventFilterCrossCrateImpl as FocusEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FocusEventFilterCrossCrateImpl { type Target = AzFocusEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FocusEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NotEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNotEventFilter as NotEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NotEventFilterCrossCrateImpl { pub _0: azul::AzNotEventFilter }

    #[cfg(feature = "link_static")] pub use NotEventFilterCrossCrateImpl as NotEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NotEventFilterCrossCrateImpl { type Target = AzNotEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NotEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `WindowEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzWindowEventFilter as WindowEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct WindowEventFilterCrossCrateImpl { pub _0: azul::AzWindowEventFilter }

    #[cfg(feature = "link_static")] pub use WindowEventFilterCrossCrateImpl as WindowEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for WindowEventFilterCrossCrateImpl { type Target = AzWindowEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for WindowEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ComponentEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzComponentEventFilter as ComponentEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ComponentEventFilterCrossCrateImpl { pub _0: azul::AzComponentEventFilter }

    #[cfg(feature = "link_static")] pub use ComponentEventFilterCrossCrateImpl as ComponentEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ComponentEventFilterCrossCrateImpl { type Target = AzComponentEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ComponentEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ApplicationEventFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzApplicationEventFilter as ApplicationEventFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ApplicationEventFilterCrossCrateImpl { pub _0: azul::AzApplicationEventFilter }

    #[cfg(feature = "link_static")] pub use ApplicationEventFilterCrossCrateImpl as ApplicationEventFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ApplicationEventFilterCrossCrateImpl { type Target = AzApplicationEventFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ApplicationEventFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Accessibility information (MSAA wrapper). See `NodeData.set_accessibility_info()`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityInfo as AccessibilityInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityInfoCrossCrateImpl { pub _0: azul::AzAccessibilityInfo }

    #[cfg(feature = "link_static")] pub use AccessibilityInfoCrossCrateImpl as AccessibilityInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityInfoCrossCrateImpl { type Target = AzAccessibilityInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// MSAA Accessibility role constants. For information on what each role does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-roles">MSDN Role Constants page</a>
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityRole as AccessibilityRole;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityRoleCrossCrateImpl { pub _0: azul::AzAccessibilityRole }

    #[cfg(feature = "link_static")] pub use AccessibilityRoleCrossCrateImpl as AccessibilityRole;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityRoleCrossCrateImpl { type Target = AzAccessibilityRole; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityRoleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// MSAA accessibility state. For information on what each state does, see the <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/object-state-constants">MSDN State Constants page</a>.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityState as AccessibilityState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityStateCrossCrateImpl { pub _0: azul::AzAccessibilityState }

    #[cfg(feature = "link_static")] pub use AccessibilityStateCrossCrateImpl as AccessibilityState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityStateCrossCrateImpl { type Target = AzAccessibilityState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TabIndex` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTabIndex as TabIndex;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabIndexCrossCrateImpl { pub _0: azul::AzTabIndex }

    #[cfg(feature = "link_static")] pub use TabIndexCrossCrateImpl as TabIndex;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabIndexCrossCrateImpl { type Target = AzTabIndex; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabIndexCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `IdOrClass` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIdOrClass as IdOrClass;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IdOrClassCrossCrateImpl { pub _0: azul::AzIdOrClass }

    #[cfg(feature = "link_static")] pub use IdOrClassCrossCrateImpl as IdOrClass;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IdOrClassCrossCrateImpl { type Target = AzIdOrClass; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IdOrClassCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDataInlineCssProperty` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataInlineCssProperty as NodeDataInlineCssProperty;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataInlineCssPropertyCrossCrateImpl { pub _0: azul::AzNodeDataInlineCssProperty }

    #[cfg(feature = "link_static")] pub use NodeDataInlineCssPropertyCrossCrateImpl as NodeDataInlineCssProperty;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataInlineCssPropertyCrossCrateImpl { type Target = AzNodeDataInlineCssProperty; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataInlineCssPropertyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod menu {
    #![allow(dead_code, unused_imports)]
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::vec::MenuItemVec;
    use crate::str::String;
    use crate::callbacks::{CallbackType, RefAny};
    /// Menu struct (application / window menu, dropdown menu, context menu). Modeled after the Windows API
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenu as Menu;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuCrossCrateImpl { pub _0: azul::AzMenu }

    #[cfg(feature = "link_static")] pub use MenuCrossCrateImpl as Menu;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuCrossCrateImpl { type Target = AzMenu; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Menu {

        /// Creates an new, empty Menu
        pub fn new(items: MenuItemVec) -> Self { unsafe { crate::dll::AzMenu_new(items) } }
        /// Sets the popup position of the menu, ignored on menu bars
        pub fn set_popup_position(&mut self, position: MenuPopupPosition)  { unsafe { crate::dll::AzMenu_setPopupPosition(self, position) } }
        /// Sets the popup position of the menu, ignored on menu bars (builder method)
        pub fn with_popup_position(&mut self, position: MenuPopupPosition)  -> crate::menu::Menu { unsafe { crate::dll::AzMenu_withPopupPosition(self, position) } }
    }

    #[cfg(feature = "link_static")]
    impl MenuCrossCrateImpl {

        /// Creates an new, empty Menu
        pub fn new(items: MenuItemVec) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzMenu_new(items._0) }) } }
        /// Sets the popup position of the menu, ignored on menu bars
        pub fn set_popup_position(&mut self, position: MenuPopupPosition)  {  unsafe { core::mem::transmute(unsafe { azul::AzMenu_setPopupPosition(&mut self._0, position._0) }) } }
        /// Sets the popup position of the menu, ignored on menu bars (builder method)
        pub fn with_popup_position(&mut self, position: MenuPopupPosition)  -> crate::menu::Menu {  unsafe { core::mem::transmute(unsafe { azul::AzMenu_withPopupPosition(&mut self._0, position._0) }) } }
    }

    /// Determines whether this context menu should pop up on a left, right or middle click
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzContextMenuMouseButton as ContextMenuMouseButton;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ContextMenuMouseButtonCrossCrateImpl { pub _0: azul::AzContextMenuMouseButton }

    #[cfg(feature = "link_static")] pub use ContextMenuMouseButtonCrossCrateImpl as ContextMenuMouseButton;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ContextMenuMouseButtonCrossCrateImpl { type Target = AzContextMenuMouseButton; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ContextMenuMouseButtonCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Position of where the context menu should pop up
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuPopupPosition as MenuPopupPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuPopupPositionCrossCrateImpl { pub _0: azul::AzMenuPopupPosition }

    #[cfg(feature = "link_static")] pub use MenuPopupPositionCrossCrateImpl as MenuPopupPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuPopupPositionCrossCrateImpl { type Target = AzMenuPopupPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuPopupPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Item entry in a menu or menu bar
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItem as MenuItem;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemCrossCrateImpl { pub _0: azul::AzMenuItem }

    #[cfg(feature = "link_static")] pub use MenuItemCrossCrateImpl as MenuItem;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemCrossCrateImpl { type Target = AzMenuItem; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Regular labeled menu item
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringMenuItem as StringMenuItem;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringMenuItemCrossCrateImpl { pub _0: azul::AzStringMenuItem }

    #[cfg(feature = "link_static")] pub use StringMenuItemCrossCrateImpl as StringMenuItem;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringMenuItemCrossCrateImpl { type Target = AzStringMenuItem; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringMenuItemCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl StringMenuItem {

        /// Creates a new menu item
        pub fn new(label: String) -> Self { unsafe { crate::dll::AzStringMenuItem_new(label) } }
        /// Adds a callback to the menu item
        pub fn set_callback(&mut self, data: RefAny, callback: CallbackType)  { unsafe { crate::dll::AzStringMenuItem_setCallback(self, data, callback) } }
        /// Adds a callback to the menu item
        pub fn with_callback(&mut self, data: RefAny, callback: CallbackType)  -> crate::menu::StringMenuItem { unsafe { crate::dll::AzStringMenuItem_withCallback(self, data, callback) } }
        /// Adds a single child submenu to the current menu
        pub fn add_child(&mut self, child: MenuItem)  { unsafe { crate::dll::AzStringMenuItem_addChild(self, child) } }
        /// Adds a single child submenu to the current menu
        pub fn with_child(&mut self, child: MenuItem)  -> crate::menu::StringMenuItem { unsafe { crate::dll::AzStringMenuItem_withChild(self, child) } }
        /// Sets the children of this menu
        pub fn set_children(&mut self, children: MenuItemVec)  { unsafe { crate::dll::AzStringMenuItem_setChildren(self, children) } }
        /// Adds a child submenu to the current menu
        pub fn with_children(&mut self, children: MenuItemVec)  -> crate::menu::StringMenuItem { unsafe { crate::dll::AzStringMenuItem_withChildren(self, children) } }
    }

    #[cfg(feature = "link_static")]
    impl StringMenuItemCrossCrateImpl {

        /// Creates a new menu item
        pub fn new(label: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_new(label._0) }) } }
        /// Adds a callback to the menu item
        pub fn set_callback(&mut self, data: RefAny, callback: CallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_setCallback(&mut self._0, data._0, callback._0) }) } }
        /// Adds a callback to the menu item
        pub fn with_callback(&mut self, data: RefAny, callback: CallbackType)  -> crate::menu::StringMenuItem {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_withCallback(&mut self._0, data._0, callback._0) }) } }
        /// Adds a single child submenu to the current menu
        pub fn add_child(&mut self, child: MenuItem)  {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_addChild(&mut self._0, child._0) }) } }
        /// Adds a single child submenu to the current menu
        pub fn with_child(&mut self, child: MenuItem)  -> crate::menu::StringMenuItem {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_withChild(&mut self._0, child._0) }) } }
        /// Sets the children of this menu
        pub fn set_children(&mut self, children: MenuItemVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_setChildren(&mut self._0, children._0) }) } }
        /// Adds a child submenu to the current menu
        pub fn with_children(&mut self, children: MenuItemVec)  -> crate::menu::StringMenuItem {  unsafe { core::mem::transmute(unsafe { azul::AzStringMenuItem_withChildren(&mut self._0, children._0) }) } }
    }

    /// Combination of virtual key codes that have to be pressed together
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVirtualKeyCodeCombo as VirtualKeyCodeCombo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VirtualKeyCodeComboCrossCrateImpl { pub _0: azul::AzVirtualKeyCodeCombo }

    #[cfg(feature = "link_static")] pub use VirtualKeyCodeComboCrossCrateImpl as VirtualKeyCodeCombo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VirtualKeyCodeComboCrossCrateImpl { type Target = AzVirtualKeyCodeCombo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VirtualKeyCodeComboCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Similar to `dom.CallbackData`, stores some data + a callback to call when the menu is activated
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuCallback as MenuCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuCallbackCrossCrateImpl { pub _0: azul::AzMenuCallback }

    #[cfg(feature = "link_static")] pub use MenuCallbackCrossCrateImpl as MenuCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuCallbackCrossCrateImpl { type Target = AzMenuCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl MenuCallback {

        /// Creates a new `MenuCallback` instance.
        pub fn new(data: RefAny, callback: CallbackType) -> Self { unsafe { crate::dll::AzMenuCallback_new(data, callback) } }
    }

    #[cfg(feature = "link_static")]
    impl MenuCallbackCrossCrateImpl {

        /// Creates a new `MenuCallback` instance.
        pub fn new(data: RefAny, callback: CallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzMenuCallback_new(data._0, callback._0) }) } }
    }

    /// Icon of a menu entry
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItemIcon as MenuItemIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemIconCrossCrateImpl { pub _0: azul::AzMenuItemIcon }

    #[cfg(feature = "link_static")] pub use MenuItemIconCrossCrateImpl as MenuItemIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemIconCrossCrateImpl { type Target = AzMenuItemIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Describes the state of a menu item
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItemState as MenuItemState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemStateCrossCrateImpl { pub _0: azul::AzMenuItemState }

    #[cfg(feature = "link_static")] pub use MenuItemStateCrossCrateImpl as MenuItemState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemStateCrossCrateImpl { type Target = AzMenuItemState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod css {
    #![allow(dead_code, unused_imports)]
    //! `Css` parsing module
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::vec::{
        StyleBackgroundPositionVec,
        StyleBackgroundContentVec,
        StyleBackgroundSizeVec,
        StyleBackgroundRepeatVec,
        StyleTransformVec,
        StyleFontFamilyVec,
        StyleFilterVec,
    };

    macro_rules! css_property_from_type {($prop_type:expr, $content_type:ident) => ({
        match $prop_type {
            CssPropertyType::TextColor => CssProperty::TextColor(StyleTextColorValue::$content_type),
            CssPropertyType::FontSize => CssProperty::FontSize(StyleFontSizeValue::$content_type),
            CssPropertyType::FontFamily => CssProperty::FontFamily(StyleFontFamilyVecValue::$content_type),
            CssPropertyType::TextAlign => CssProperty::TextAlign(StyleTextAlignValue::$content_type),
            CssPropertyType::LetterSpacing => CssProperty::LetterSpacing(StyleLetterSpacingValue::$content_type),
            CssPropertyType::LineHeight => CssProperty::LineHeight(StyleLineHeightValue::$content_type),
            CssPropertyType::WordSpacing => CssProperty::WordSpacing(StyleWordSpacingValue::$content_type),
            CssPropertyType::TabWidth => CssProperty::TabWidth(StyleTabWidthValue::$content_type),
            CssPropertyType::Cursor => CssProperty::Cursor(StyleCursorValue::$content_type),
            CssPropertyType::Display => CssProperty::Display(LayoutDisplayValue::$content_type),
            CssPropertyType::Float => CssProperty::Float(LayoutFloatValue::$content_type),
            CssPropertyType::BoxSizing => CssProperty::BoxSizing(LayoutBoxSizingValue::$content_type),
            CssPropertyType::Width => CssProperty::Width(LayoutWidthValue::$content_type),
            CssPropertyType::Height => CssProperty::Height(LayoutHeightValue::$content_type),
            CssPropertyType::MinWidth => CssProperty::MinWidth(LayoutMinWidthValue::$content_type),
            CssPropertyType::MinHeight => CssProperty::MinHeight(LayoutMinHeightValue::$content_type),
            CssPropertyType::MaxWidth => CssProperty::MaxWidth(LayoutMaxWidthValue::$content_type),
            CssPropertyType::MaxHeight => CssProperty::MaxHeight(LayoutMaxHeightValue::$content_type),
            CssPropertyType::Position => CssProperty::Position(LayoutPositionValue::$content_type),
            CssPropertyType::Top => CssProperty::Top(LayoutTopValue::$content_type),
            CssPropertyType::Right => CssProperty::Right(LayoutRightValue::$content_type),
            CssPropertyType::Left => CssProperty::Left(LayoutLeftValue::$content_type),
            CssPropertyType::Bottom => CssProperty::Bottom(LayoutBottomValue::$content_type),
            CssPropertyType::FlexWrap => CssProperty::FlexWrap(LayoutFlexWrapValue::$content_type),
            CssPropertyType::FlexDirection => CssProperty::FlexDirection(LayoutFlexDirectionValue::$content_type),
            CssPropertyType::FlexGrow => CssProperty::FlexGrow(LayoutFlexGrowValue::$content_type),
            CssPropertyType::FlexShrink => CssProperty::FlexShrink(LayoutFlexShrinkValue::$content_type),
            CssPropertyType::JustifyContent => CssProperty::JustifyContent(LayoutJustifyContentValue::$content_type),
            CssPropertyType::AlignItems => CssProperty::AlignItems(LayoutAlignItemsValue::$content_type),
            CssPropertyType::AlignContent => CssProperty::AlignContent(LayoutAlignContentValue::$content_type),
            CssPropertyType::BackgroundContent => CssProperty::BackgroundContent(StyleBackgroundContentVecValue::$content_type),
            CssPropertyType::BackgroundPosition => CssProperty::BackgroundPosition(StyleBackgroundPositionVecValue::$content_type),
            CssPropertyType::BackgroundSize => CssProperty::BackgroundSize(StyleBackgroundSizeVecValue::$content_type),
            CssPropertyType::BackgroundRepeat => CssProperty::BackgroundRepeat(StyleBackgroundRepeatVecValue::$content_type),
            CssPropertyType::OverflowX => CssProperty::OverflowX(LayoutOverflowValue::$content_type),
            CssPropertyType::OverflowY => CssProperty::OverflowY(LayoutOverflowValue::$content_type),
            CssPropertyType::PaddingTop => CssProperty::PaddingTop(LayoutPaddingTopValue::$content_type),
            CssPropertyType::PaddingLeft => CssProperty::PaddingLeft(LayoutPaddingLeftValue::$content_type),
            CssPropertyType::PaddingRight => CssProperty::PaddingRight(LayoutPaddingRightValue::$content_type),
            CssPropertyType::PaddingBottom => CssProperty::PaddingBottom(LayoutPaddingBottomValue::$content_type),
            CssPropertyType::MarginTop => CssProperty::MarginTop(LayoutMarginTopValue::$content_type),
            CssPropertyType::MarginLeft => CssProperty::MarginLeft(LayoutMarginLeftValue::$content_type),
            CssPropertyType::MarginRight => CssProperty::MarginRight(LayoutMarginRightValue::$content_type),
            CssPropertyType::MarginBottom => CssProperty::MarginBottom(LayoutMarginBottomValue::$content_type),
            CssPropertyType::BorderTopLeftRadius => CssProperty::BorderTopLeftRadius(StyleBorderTopLeftRadiusValue::$content_type),
            CssPropertyType::BorderTopRightRadius => CssProperty::BorderTopRightRadius(StyleBorderTopRightRadiusValue::$content_type),
            CssPropertyType::BorderBottomLeftRadius => CssProperty::BorderBottomLeftRadius(StyleBorderBottomLeftRadiusValue::$content_type),
            CssPropertyType::BorderBottomRightRadius => CssProperty::BorderBottomRightRadius(StyleBorderBottomRightRadiusValue::$content_type),
            CssPropertyType::BorderTopColor => CssProperty::BorderTopColor(StyleBorderTopColorValue::$content_type),
            CssPropertyType::BorderRightColor => CssProperty::BorderRightColor(StyleBorderRightColorValue::$content_type),
            CssPropertyType::BorderLeftColor => CssProperty::BorderLeftColor(StyleBorderLeftColorValue::$content_type),
            CssPropertyType::BorderBottomColor => CssProperty::BorderBottomColor(StyleBorderBottomColorValue::$content_type),
            CssPropertyType::BorderTopStyle => CssProperty::BorderTopStyle(StyleBorderTopStyleValue::$content_type),
            CssPropertyType::BorderRightStyle => CssProperty::BorderRightStyle(StyleBorderRightStyleValue::$content_type),
            CssPropertyType::BorderLeftStyle => CssProperty::BorderLeftStyle(StyleBorderLeftStyleValue::$content_type),
            CssPropertyType::BorderBottomStyle => CssProperty::BorderBottomStyle(StyleBorderBottomStyleValue::$content_type),
            CssPropertyType::BorderTopWidth => CssProperty::BorderTopWidth(LayoutBorderTopWidthValue::$content_type),
            CssPropertyType::BorderRightWidth => CssProperty::BorderRightWidth(LayoutBorderRightWidthValue::$content_type),
            CssPropertyType::BorderLeftWidth => CssProperty::BorderLeftWidth(LayoutBorderLeftWidthValue::$content_type),
            CssPropertyType::BorderBottomWidth => CssProperty::BorderBottomWidth(LayoutBorderBottomWidthValue::$content_type),
            CssPropertyType::BoxShadowLeft => CssProperty::BoxShadowLeft(StyleBoxShadowValue::$content_type),
            CssPropertyType::BoxShadowRight => CssProperty::BoxShadowRight(StyleBoxShadowValue::$content_type),
            CssPropertyType::BoxShadowTop => CssProperty::BoxShadowTop(StyleBoxShadowValue::$content_type),
            CssPropertyType::BoxShadowBottom => CssProperty::BoxShadowBottom(StyleBoxShadowValue::$content_type),
            CssPropertyType::ScrollbarStyle => CssProperty::ScrollbarStyle(ScrollbarStyleValue::$content_type),
            CssPropertyType::Opacity => CssProperty::Opacity(StyleOpacityValue::$content_type),
            CssPropertyType::Transform => CssProperty::Transform(StyleTransformVecValue::$content_type),
            CssPropertyType::PerspectiveOrigin => CssProperty::PerspectiveOrigin(StylePerspectiveOriginValue::$content_type),
            CssPropertyType::TransformOrigin => CssProperty::TransformOrigin(StyleTransformOriginValue::$content_type),
            CssPropertyType::BackfaceVisibility => CssProperty::BackfaceVisibility(StyleBackfaceVisibilityValue::$content_type),
            CssPropertyType::MixBlendMode => CssProperty::MixBlendMode(StyleMixBlendModeValue::$content_type),
            CssPropertyType::Filter => CssProperty::Filter(StyleFilterVecValue::$content_type),
            CssPropertyType::BackdropFilter => CssProperty::BackdropFilter(StyleFilterVecValue::$content_type),
            CssPropertyType::TextShadow => CssProperty::TextShadow(StyleBoxShadowValue::$content_type),
        }
    })}

    #[cfg(not(feature = "link_static"))]
    impl CssProperty {

        /// Return the type (key) of this property as a statically typed enum
        pub const fn get_type(&self) -> CssPropertyType {
            match &self {
                CssProperty::TextColor(_) => CssPropertyType::TextColor,
                CssProperty::FontSize(_) => CssPropertyType::FontSize,
                CssProperty::FontFamily(_) => CssPropertyType::FontFamily,
                CssProperty::TextAlign(_) => CssPropertyType::TextAlign,
                CssProperty::LetterSpacing(_) => CssPropertyType::LetterSpacing,
                CssProperty::LineHeight(_) => CssPropertyType::LineHeight,
                CssProperty::WordSpacing(_) => CssPropertyType::WordSpacing,
                CssProperty::TabWidth(_) => CssPropertyType::TabWidth,
                CssProperty::Cursor(_) => CssPropertyType::Cursor,
                CssProperty::Display(_) => CssPropertyType::Display,
                CssProperty::Float(_) => CssPropertyType::Float,
                CssProperty::BoxSizing(_) => CssPropertyType::BoxSizing,
                CssProperty::Width(_) => CssPropertyType::Width,
                CssProperty::Height(_) => CssPropertyType::Height,
                CssProperty::MinWidth(_) => CssPropertyType::MinWidth,
                CssProperty::MinHeight(_) => CssPropertyType::MinHeight,
                CssProperty::MaxWidth(_) => CssPropertyType::MaxWidth,
                CssProperty::MaxHeight(_) => CssPropertyType::MaxHeight,
                CssProperty::Position(_) => CssPropertyType::Position,
                CssProperty::Top(_) => CssPropertyType::Top,
                CssProperty::Right(_) => CssPropertyType::Right,
                CssProperty::Left(_) => CssPropertyType::Left,
                CssProperty::Bottom(_) => CssPropertyType::Bottom,
                CssProperty::FlexWrap(_) => CssPropertyType::FlexWrap,
                CssProperty::FlexDirection(_) => CssPropertyType::FlexDirection,
                CssProperty::FlexGrow(_) => CssPropertyType::FlexGrow,
                CssProperty::FlexShrink(_) => CssPropertyType::FlexShrink,
                CssProperty::JustifyContent(_) => CssPropertyType::JustifyContent,
                CssProperty::AlignItems(_) => CssPropertyType::AlignItems,
                CssProperty::AlignContent(_) => CssPropertyType::AlignContent,
                CssProperty::BackgroundContent(_) => CssPropertyType::BackgroundContent,
                CssProperty::BackgroundPosition(_) => CssPropertyType::BackgroundPosition,
                CssProperty::BackgroundSize(_) => CssPropertyType::BackgroundSize,
                CssProperty::BackgroundRepeat(_) => CssPropertyType::BackgroundRepeat,
                CssProperty::OverflowX(_) => CssPropertyType::OverflowX,
                CssProperty::OverflowY(_) => CssPropertyType::OverflowY,
                CssProperty::PaddingTop(_) => CssPropertyType::PaddingTop,
                CssProperty::PaddingLeft(_) => CssPropertyType::PaddingLeft,
                CssProperty::PaddingRight(_) => CssPropertyType::PaddingRight,
                CssProperty::PaddingBottom(_) => CssPropertyType::PaddingBottom,
                CssProperty::MarginTop(_) => CssPropertyType::MarginTop,
                CssProperty::MarginLeft(_) => CssPropertyType::MarginLeft,
                CssProperty::MarginRight(_) => CssPropertyType::MarginRight,
                CssProperty::MarginBottom(_) => CssPropertyType::MarginBottom,
                CssProperty::BorderTopLeftRadius(_) => CssPropertyType::BorderTopLeftRadius,
                CssProperty::BorderTopRightRadius(_) => CssPropertyType::BorderTopRightRadius,
                CssProperty::BorderBottomLeftRadius(_) => CssPropertyType::BorderBottomLeftRadius,
                CssProperty::BorderBottomRightRadius(_) => CssPropertyType::BorderBottomRightRadius,
                CssProperty::BorderTopColor(_) => CssPropertyType::BorderTopColor,
                CssProperty::BorderRightColor(_) => CssPropertyType::BorderRightColor,
                CssProperty::BorderLeftColor(_) => CssPropertyType::BorderLeftColor,
                CssProperty::BorderBottomColor(_) => CssPropertyType::BorderBottomColor,
                CssProperty::BorderTopStyle(_) => CssPropertyType::BorderTopStyle,
                CssProperty::BorderRightStyle(_) => CssPropertyType::BorderRightStyle,
                CssProperty::BorderLeftStyle(_) => CssPropertyType::BorderLeftStyle,
                CssProperty::BorderBottomStyle(_) => CssPropertyType::BorderBottomStyle,
                CssProperty::BorderTopWidth(_) => CssPropertyType::BorderTopWidth,
                CssProperty::BorderRightWidth(_) => CssPropertyType::BorderRightWidth,
                CssProperty::BorderLeftWidth(_) => CssPropertyType::BorderLeftWidth,
                CssProperty::BorderBottomWidth(_) => CssPropertyType::BorderBottomWidth,
                CssProperty::BoxShadowLeft(_) => CssPropertyType::BoxShadowLeft,
                CssProperty::BoxShadowRight(_) => CssPropertyType::BoxShadowRight,
                CssProperty::BoxShadowTop(_) => CssPropertyType::BoxShadowTop,
                CssProperty::BoxShadowBottom(_) => CssPropertyType::BoxShadowBottom,
                CssProperty::ScrollbarStyle(_) => CssPropertyType::ScrollbarStyle,
                CssProperty::Opacity(_) => CssPropertyType::Opacity,
                CssProperty::Transform(_) => CssPropertyType::Transform,
                CssProperty::PerspectiveOrigin(_) => CssPropertyType::PerspectiveOrigin,
                CssProperty::TransformOrigin(_) => CssPropertyType::TransformOrigin,
                CssProperty::BackfaceVisibility(_) => CssPropertyType::BackfaceVisibility,
                CssProperty::MixBlendMode(_) => CssPropertyType::MixBlendMode,
                CssProperty::Filter(_) => CssPropertyType::Filter,
                CssProperty::BackdropFilter(_) => CssPropertyType::BackdropFilter,
                CssProperty::TextShadow(_) => CssPropertyType::TextShadow,
            }
        }

        // const constructors for easier API access

        pub const fn none(prop_type: CssPropertyType) -> Self { css_property_from_type!(prop_type, None) }
        pub const fn auto(prop_type: CssPropertyType) -> Self { css_property_from_type!(prop_type, Auto) }
        pub const fn initial(prop_type: CssPropertyType) -> Self { css_property_from_type!(prop_type, Initial) }
        pub const fn inherit(prop_type: CssPropertyType) -> Self { css_property_from_type!(prop_type, Inherit) }

        pub const fn text_color(input: StyleTextColor) -> Self { CssProperty::TextColor(StyleTextColorValue::Exact(input)) }
        pub const fn font_size(input: StyleFontSize) -> Self { CssProperty::FontSize(StyleFontSizeValue::Exact(input)) }
        pub const fn font_family(input: StyleFontFamilyVec) -> Self { CssProperty::FontFamily(StyleFontFamilyVecValue::Exact(input)) }
        pub const fn text_align(input: StyleTextAlign) -> Self { CssProperty::TextAlign(StyleTextAlignValue::Exact(input)) }
        pub const fn letter_spacing(input: StyleLetterSpacing) -> Self { CssProperty::LetterSpacing(StyleLetterSpacingValue::Exact(input)) }
        pub const fn line_height(input: StyleLineHeight) -> Self { CssProperty::LineHeight(StyleLineHeightValue::Exact(input)) }
        pub const fn word_spacing(input: StyleWordSpacing) -> Self { CssProperty::WordSpacing(StyleWordSpacingValue::Exact(input)) }
        pub const fn tab_width(input: StyleTabWidth) -> Self { CssProperty::TabWidth(StyleTabWidthValue::Exact(input)) }
        pub const fn cursor(input: StyleCursor) -> Self { CssProperty::Cursor(StyleCursorValue::Exact(input)) }
        pub const fn display(input: LayoutDisplay) -> Self { CssProperty::Display(LayoutDisplayValue::Exact(input)) }
        pub const fn float(input: LayoutFloat) -> Self { CssProperty::Float(LayoutFloatValue::Exact(input)) }
        pub const fn box_sizing(input: LayoutBoxSizing) -> Self { CssProperty::BoxSizing(LayoutBoxSizingValue::Exact(input)) }
        pub const fn width(input: LayoutWidth) -> Self { CssProperty::Width(LayoutWidthValue::Exact(input)) }
        pub const fn height(input: LayoutHeight) -> Self { CssProperty::Height(LayoutHeightValue::Exact(input)) }
        pub const fn min_width(input: LayoutMinWidth) -> Self { CssProperty::MinWidth(LayoutMinWidthValue::Exact(input)) }
        pub const fn min_height(input: LayoutMinHeight) -> Self { CssProperty::MinHeight(LayoutMinHeightValue::Exact(input)) }
        pub const fn max_width(input: LayoutMaxWidth) -> Self { CssProperty::MaxWidth(LayoutMaxWidthValue::Exact(input)) }
        pub const fn max_height(input: LayoutMaxHeight) -> Self { CssProperty::MaxHeight(LayoutMaxHeightValue::Exact(input)) }
        pub const fn position(input: LayoutPosition) -> Self { CssProperty::Position(LayoutPositionValue::Exact(input)) }
        pub const fn top(input: LayoutTop) -> Self { CssProperty::Top(LayoutTopValue::Exact(input)) }
        pub const fn right(input: LayoutRight) -> Self { CssProperty::Right(LayoutRightValue::Exact(input)) }
        pub const fn left(input: LayoutLeft) -> Self { CssProperty::Left(LayoutLeftValue::Exact(input)) }
        pub const fn bottom(input: LayoutBottom) -> Self { CssProperty::Bottom(LayoutBottomValue::Exact(input)) }
        pub const fn flex_wrap(input: LayoutFlexWrap) -> Self { CssProperty::FlexWrap(LayoutFlexWrapValue::Exact(input)) }
        pub const fn flex_direction(input: LayoutFlexDirection) -> Self { CssProperty::FlexDirection(LayoutFlexDirectionValue::Exact(input)) }
        pub const fn flex_grow(input: LayoutFlexGrow) -> Self { CssProperty::FlexGrow(LayoutFlexGrowValue::Exact(input)) }
        pub const fn flex_shrink(input: LayoutFlexShrink) -> Self { CssProperty::FlexShrink(LayoutFlexShrinkValue::Exact(input)) }
        pub const fn justify_content(input: LayoutJustifyContent) -> Self { CssProperty::JustifyContent(LayoutJustifyContentValue::Exact(input)) }
        pub const fn align_items(input: LayoutAlignItems) -> Self { CssProperty::AlignItems(LayoutAlignItemsValue::Exact(input)) }
        pub const fn align_content(input: LayoutAlignContent) -> Self { CssProperty::AlignContent(LayoutAlignContentValue::Exact(input)) }
        pub const fn background_content(input: StyleBackgroundContentVec) -> Self { CssProperty::BackgroundContent(StyleBackgroundContentVecValue::Exact(input)) }
        pub const fn background_position(input: StyleBackgroundPositionVec) -> Self { CssProperty::BackgroundPosition(StyleBackgroundPositionVecValue::Exact(input)) }
        pub const fn background_size(input: StyleBackgroundSizeVec) -> Self { CssProperty::BackgroundSize(StyleBackgroundSizeVecValue::Exact(input)) }
        pub const fn background_repeat(input: StyleBackgroundRepeatVec) -> Self { CssProperty::BackgroundRepeat(StyleBackgroundRepeatVecValue::Exact(input)) }
        pub const fn overflow_x(input: LayoutOverflow) -> Self { CssProperty::OverflowX(LayoutOverflowValue::Exact(input)) }
        pub const fn overflow_y(input: LayoutOverflow) -> Self { CssProperty::OverflowY(LayoutOverflowValue::Exact(input)) }
        pub const fn padding_top(input: LayoutPaddingTop) -> Self { CssProperty::PaddingTop(LayoutPaddingTopValue::Exact(input)) }
        pub const fn padding_left(input: LayoutPaddingLeft) -> Self { CssProperty::PaddingLeft(LayoutPaddingLeftValue::Exact(input)) }
        pub const fn padding_right(input: LayoutPaddingRight) -> Self { CssProperty::PaddingRight(LayoutPaddingRightValue::Exact(input)) }
        pub const fn padding_bottom(input: LayoutPaddingBottom) -> Self { CssProperty::PaddingBottom(LayoutPaddingBottomValue::Exact(input)) }
        pub const fn margin_top(input: LayoutMarginTop) -> Self { CssProperty::MarginTop(LayoutMarginTopValue::Exact(input)) }
        pub const fn margin_left(input: LayoutMarginLeft) -> Self { CssProperty::MarginLeft(LayoutMarginLeftValue::Exact(input)) }
        pub const fn margin_right(input: LayoutMarginRight) -> Self { CssProperty::MarginRight(LayoutMarginRightValue::Exact(input)) }
        pub const fn margin_bottom(input: LayoutMarginBottom) -> Self { CssProperty::MarginBottom(LayoutMarginBottomValue::Exact(input)) }
        pub const fn border_top_left_radius(input: StyleBorderTopLeftRadius) -> Self { CssProperty::BorderTopLeftRadius(StyleBorderTopLeftRadiusValue::Exact(input)) }
        pub const fn border_top_right_radius(input: StyleBorderTopRightRadius) -> Self { CssProperty::BorderTopRightRadius(StyleBorderTopRightRadiusValue::Exact(input)) }
        pub const fn border_bottom_left_radius(input: StyleBorderBottomLeftRadius) -> Self { CssProperty::BorderBottomLeftRadius(StyleBorderBottomLeftRadiusValue::Exact(input)) }
        pub const fn border_bottom_right_radius(input: StyleBorderBottomRightRadius) -> Self { CssProperty::BorderBottomRightRadius(StyleBorderBottomRightRadiusValue::Exact(input)) }
        pub const fn border_top_color(input: StyleBorderTopColor) -> Self { CssProperty::BorderTopColor(StyleBorderTopColorValue::Exact(input)) }
        pub const fn border_right_color(input: StyleBorderRightColor) -> Self { CssProperty::BorderRightColor(StyleBorderRightColorValue::Exact(input)) }
        pub const fn border_left_color(input: StyleBorderLeftColor) -> Self { CssProperty::BorderLeftColor(StyleBorderLeftColorValue::Exact(input)) }
        pub const fn border_bottom_color(input: StyleBorderBottomColor) -> Self { CssProperty::BorderBottomColor(StyleBorderBottomColorValue::Exact(input)) }
        pub const fn border_top_style(input: StyleBorderTopStyle) -> Self { CssProperty::BorderTopStyle(StyleBorderTopStyleValue::Exact(input)) }
        pub const fn border_right_style(input: StyleBorderRightStyle) -> Self { CssProperty::BorderRightStyle(StyleBorderRightStyleValue::Exact(input)) }
        pub const fn border_left_style(input: StyleBorderLeftStyle) -> Self { CssProperty::BorderLeftStyle(StyleBorderLeftStyleValue::Exact(input)) }
        pub const fn border_bottom_style(input: StyleBorderBottomStyle) -> Self { CssProperty::BorderBottomStyle(StyleBorderBottomStyleValue::Exact(input)) }
        pub const fn border_top_width(input: LayoutBorderTopWidth) -> Self { CssProperty::BorderTopWidth(LayoutBorderTopWidthValue::Exact(input)) }
        pub const fn border_right_width(input: LayoutBorderRightWidth) -> Self { CssProperty::BorderRightWidth(LayoutBorderRightWidthValue::Exact(input)) }
        pub const fn border_left_width(input: LayoutBorderLeftWidth) -> Self { CssProperty::BorderLeftWidth(LayoutBorderLeftWidthValue::Exact(input)) }
        pub const fn border_bottom_width(input: LayoutBorderBottomWidth) -> Self { CssProperty::BorderBottomWidth(LayoutBorderBottomWidthValue::Exact(input)) }
        pub const fn box_shadow_left(input: StyleBoxShadow) -> Self { CssProperty::BoxShadowLeft(StyleBoxShadowValue::Exact(input)) }
        pub const fn box_shadow_right(input: StyleBoxShadow) -> Self { CssProperty::BoxShadowRight(StyleBoxShadowValue::Exact(input)) }
        pub const fn box_shadow_top(input: StyleBoxShadow) -> Self { CssProperty::BoxShadowTop(StyleBoxShadowValue::Exact(input)) }
        pub const fn box_shadow_bottom(input: StyleBoxShadow) -> Self { CssProperty::BoxShadowBottom(StyleBoxShadowValue::Exact(input)) }
        pub const fn opacity(input: StyleOpacity) -> Self { CssProperty::Opacity(StyleOpacityValue::Exact(input)) }
        pub const fn transform(input: StyleTransformVec) -> Self { CssProperty::Transform(StyleTransformVecValue::Exact(input)) }
        pub const fn transform_origin(input: StyleTransformOrigin) -> Self { CssProperty::TransformOrigin(StyleTransformOriginValue::Exact(input)) }
        pub const fn perspective_origin(input: StylePerspectiveOrigin) -> Self { CssProperty::PerspectiveOrigin(StylePerspectiveOriginValue::Exact(input)) }
        pub const fn backface_visiblity(input: StyleBackfaceVisibility) -> Self { CssProperty::BackfaceVisibility(StyleBackfaceVisibilityValue::Exact(input)) }
        pub const fn mix_blend_mode(input: StyleMixBlendMode) -> Self { CssProperty::MixBlendMode(StyleMixBlendModeValue::Exact(input)) }
        pub const fn filter(input: StyleFilterVec) -> Self { CssProperty::Filter(StyleFilterVecValue::Exact(input)) }
        pub const fn backdrop_filter(input: StyleFilterVec) -> Self { CssProperty::BackdropFilter(StyleFilterVecValue::Exact(input)) }
        pub const fn text_shadow(input: StyleBoxShadow) -> Self { CssProperty::TextShadow(StyleBoxShadowValue::Exact(input)) }
    }

    const FP_PRECISION_MULTIPLIER: f32 = 1000.0;
    const FP_PRECISION_MULTIPLIER_CONST: isize = FP_PRECISION_MULTIPLIER as isize;

    #[cfg(not(feature = "link_static"))]
    impl FloatValue {
        /// Same as `FloatValue::new()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        pub const fn const_new(value: isize)  -> Self {
            Self { number: value * FP_PRECISION_MULTIPLIER_CONST }
        }

        pub fn new(value: f32) -> Self {
            Self { number: (value * FP_PRECISION_MULTIPLIER) as isize }
        }

        pub fn get(&self) -> f32 {
            self.number as f32 / FP_PRECISION_MULTIPLIER
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<f32> for FloatValue {
        fn from(val: f32) -> Self {
            Self::new(val)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl AngleValue {

        #[inline]
        pub const fn zero() -> Self {
            const ZERO_DEG: AngleValue = AngleValue::const_deg(0);
            ZERO_DEG
        }

        /// Same as `PixelValue::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_deg(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Degree, value)
        }

        /// Same as `PixelValue::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_rad(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Radians, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_grad(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Grad, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_turn(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Turn, value)
        }

        #[inline]
        pub fn const_percent(value: isize) -> Self {
            Self::const_from_metric(AngleMetric::Percent, value)
        }

        #[inline]
        pub const fn const_from_metric(metric: AngleMetric, value: isize) -> Self {
            Self {
                metric: metric,
                number: FloatValue::const_new(value),
            }
        }

        #[inline]
        pub fn deg(value: f32) -> Self {
            Self::from_metric(AngleMetric::Degree, value)
        }

        #[inline]
        pub fn rad(value: f32) -> Self {
            Self::from_metric(AngleMetric::Radians, value)
        }

        #[inline]
        pub fn grad(value: f32) -> Self {
            Self::from_metric(AngleMetric::Grad, value)
        }

        #[inline]
        pub fn turn(value: f32) -> Self {
            Self::from_metric(AngleMetric::Turn, value)
        }

        #[inline]
        pub fn percent(value: f32) -> Self {
            Self::from_metric(AngleMetric::Percent, value)
        }

        #[inline]
        pub fn from_metric(metric: AngleMetric, value: f32) -> Self {
            Self {
                metric: metric,
                number: FloatValue::new(value),
            }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl PixelValue {

        #[inline]
        pub const fn zero() -> Self {
            const ZERO_PX: PixelValue = PixelValue::const_px(0);
            ZERO_PX
        }

        /// Same as `PixelValue::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_px(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Px, value)
        }

        /// Same as `PixelValue::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_em(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Em, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_pt(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Pt, value)
        }

        /// Same as `PixelValue::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_percent(value: isize) -> Self {
            Self::const_from_metric(SizeMetric::Percent, value)
        }

        #[inline]
        pub const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
            Self {
                metric: metric,
                number: FloatValue::const_new(value),
            }
        }

        #[inline]
        pub fn px(value: f32) -> Self {
            Self::from_metric(SizeMetric::Px, value)
        }

        #[inline]
        pub fn em(value: f32) -> Self {
            Self::from_metric(SizeMetric::Em, value)
        }

        #[inline]
        pub fn pt(value: f32) -> Self {
            Self::from_metric(SizeMetric::Pt, value)
        }

        #[inline]
        pub fn percent(value: f32) -> Self {
            Self::from_metric(SizeMetric::Percent, value)
        }

        #[inline]
        pub fn from_metric(metric: SizeMetric, value: f32) -> Self {
            Self {
                metric: metric,
                number: FloatValue::new(value),
            }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl PixelValueNoPercent {

        #[inline]
        pub const fn zero() -> Self {
            Self { inner: PixelValue::zero() }
        }

        /// Same as `PixelValueNoPercent::px()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_px(value: isize) -> Self {
            Self { inner: PixelValue::const_px(value) }
        }

        /// Same as `PixelValueNoPercent::em()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_em(value: isize) -> Self {
            Self { inner: PixelValue::const_em(value) }
        }

        /// Same as `PixelValueNoPercent::pt()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_pt(value: isize) -> Self {
            Self { inner: PixelValue::const_pt(value) }
        }

        #[inline]
        const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
            Self { inner: PixelValue::const_from_metric(metric, value) }
        }

        #[inline]
        pub fn px(value: f32) -> Self {
            Self { inner: PixelValue::px(value) }
        }

        #[inline]
        pub fn em(value: f32) -> Self {
            Self { inner: PixelValue::em(value) }
        }

        #[inline]
        pub fn pt(value: f32) -> Self {
            Self { inner: PixelValue::pt(value) }
        }

        #[inline]
        fn from_metric(metric: SizeMetric, value: f32) -> Self {
            Self { inner: PixelValue::from_metric(metric, value) }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl PercentageValue {

        /// Same as `PercentageValue::new()`, but only accepts whole numbers,
        /// since using `f32` in const fn is not yet stabilized.
        #[inline]
        pub const fn const_new(value: isize) -> Self {
            Self { number: FloatValue::const_new(value) }
        }

        #[inline]
        pub fn new(value: f32) -> Self {
            Self { number: value.into() }
        }

        #[inline]
        pub fn get(&self) -> f32 {
            self.number.get()
        }
    }

    /// Creates `pt`, `px` and `em` constructors for any struct that has a
    /// `PixelValue` as it's self.0 field.
    macro_rules! impl_pixel_value {($struct:ident) => (

        #[cfg(not(feature = "link_static"))]
        impl $struct {

            #[inline]
            pub const fn zero() -> Self {
                Self { inner: PixelValue::zero() }
            }

            /// Same as `PixelValue::px()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            #[inline]
            pub const fn const_px(value: isize) -> Self {
                Self { inner: PixelValue::const_px(value) }
            }

            /// Same as `PixelValue::em()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            #[inline]
            pub const fn const_em(value: isize) -> Self {
                Self { inner: PixelValue::const_em(value) }
            }

            /// Same as `PixelValue::pt()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            #[inline]
            pub const fn const_pt(value: isize) -> Self {
                Self { inner: PixelValue::const_pt(value) }
            }

            /// Same as `PixelValue::pt()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            #[inline]
            pub const fn const_percent(value: isize) -> Self {
                Self { inner: PixelValue::const_percent(value) }
            }

            #[inline]
            pub const fn const_from_metric(metric: SizeMetric, value: isize) -> Self {
                Self { inner: PixelValue::const_from_metric(metric, value) }
            }

            #[inline]
            pub fn px(value: f32) -> Self {
                Self { inner: PixelValue::px(value) }
            }

            #[inline]
            pub fn em(value: f32) -> Self {
                Self { inner: PixelValue::em(value) }
            }

            #[inline]
            pub fn pt(value: f32) -> Self {
                Self { inner: PixelValue::pt(value) }
            }

            #[inline]
            pub fn percent(value: f32) -> Self {
                Self { inner: PixelValue::percent(value) }
            }

            #[inline]
            pub fn from_metric(metric: SizeMetric, value: f32) -> Self {
                Self { inner: PixelValue::from_metric(metric, value) }
            }
        }
    )}

    impl_pixel_value!(StyleBorderTopLeftRadius);
    impl_pixel_value!(StyleBorderBottomLeftRadius);
    impl_pixel_value!(StyleBorderTopRightRadius);
    impl_pixel_value!(StyleBorderBottomRightRadius);
    impl_pixel_value!(LayoutBorderTopWidth);
    impl_pixel_value!(LayoutBorderLeftWidth);
    impl_pixel_value!(LayoutBorderRightWidth);
    impl_pixel_value!(LayoutBorderBottomWidth);
    impl_pixel_value!(LayoutWidth);
    impl_pixel_value!(LayoutHeight);
    impl_pixel_value!(LayoutMinHeight);
    impl_pixel_value!(LayoutMinWidth);
    impl_pixel_value!(LayoutMaxWidth);
    impl_pixel_value!(LayoutMaxHeight);
    impl_pixel_value!(LayoutTop);
    impl_pixel_value!(LayoutBottom);
    impl_pixel_value!(LayoutRight);
    impl_pixel_value!(LayoutLeft);
    impl_pixel_value!(LayoutPaddingTop);
    impl_pixel_value!(LayoutPaddingBottom);
    impl_pixel_value!(LayoutPaddingRight);
    impl_pixel_value!(LayoutPaddingLeft);
    impl_pixel_value!(LayoutMarginTop);
    impl_pixel_value!(LayoutMarginBottom);
    impl_pixel_value!(LayoutMarginRight);
    impl_pixel_value!(LayoutMarginLeft);
    impl_pixel_value!(StyleLetterSpacing);
    impl_pixel_value!(StyleWordSpacing);
    impl_pixel_value!(StyleFontSize);

    macro_rules! impl_float_value {($struct:ident) => (
        #[cfg(not(feature = "link_static"))]
        impl $struct {
            /// Same as `FloatValue::new()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            pub const fn const_new(value: isize)  -> Self {
                Self { inner: FloatValue::const_new(value) }
            }

            pub fn new(value: f32) -> Self {
                Self { inner: FloatValue::new(value) }
            }

            pub fn get(&self) -> f32 {
                self.inner.get()
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl From<f32> for $struct {
            fn from(val: f32) -> Self {
                Self { inner: FloatValue::from(val) }
            }
        }
    )}

    impl_float_value!(LayoutFlexGrow);
    impl_float_value!(LayoutFlexShrink);

    macro_rules! impl_percentage_value{($struct:ident) => (
        #[cfg(not(feature = "link_static"))]
        impl $struct {
            /// Same as `PercentageValue::new()`, but only accepts whole numbers,
            /// since using `f32` in const fn is not yet stabilized.
            #[inline]
            pub const fn const_new(value: isize) -> Self {
                Self { inner: PercentageValue::const_new(value) }
            }
        }
    )}

    impl_percentage_value!(StyleLineHeight);
    impl_percentage_value!(StyleTabWidth);
    impl_percentage_value!(StyleOpacity);
    use crate::str::String;
    /// `CssRuleBlock` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssRuleBlock as CssRuleBlock;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssRuleBlockCrossCrateImpl { pub _0: azul::AzCssRuleBlock }

    #[cfg(feature = "link_static")] pub use CssRuleBlockCrossCrateImpl as CssRuleBlock;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssRuleBlockCrossCrateImpl { type Target = AzCssRuleBlock; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssRuleBlockCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssDeclaration` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssDeclaration as CssDeclaration;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssDeclarationCrossCrateImpl { pub _0: azul::AzCssDeclaration }

    #[cfg(feature = "link_static")] pub use CssDeclarationCrossCrateImpl as CssDeclaration;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssDeclarationCrossCrateImpl { type Target = AzCssDeclaration; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssDeclarationCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DynamicCssProperty` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDynamicCssProperty as DynamicCssProperty;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DynamicCssPropertyCrossCrateImpl { pub _0: azul::AzDynamicCssProperty }

    #[cfg(feature = "link_static")] pub use DynamicCssPropertyCrossCrateImpl as DynamicCssProperty;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DynamicCssPropertyCrossCrateImpl { type Target = AzDynamicCssProperty; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DynamicCssPropertyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPath` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPath as CssPath;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathCrossCrateImpl { pub _0: azul::AzCssPath }

    #[cfg(feature = "link_static")] pub use CssPathCrossCrateImpl as CssPath;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathCrossCrateImpl { type Target = AzCssPath; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPathSelector` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPathSelector as CssPathSelector;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathSelectorCrossCrateImpl { pub _0: azul::AzCssPathSelector }

    #[cfg(feature = "link_static")] pub use CssPathSelectorCrossCrateImpl as CssPathSelector;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathSelectorCrossCrateImpl { type Target = AzCssPathSelector; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathSelectorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeKey` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeKey as NodeTypeKey;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeKeyCrossCrateImpl { pub _0: azul::AzNodeTypeKey }

    #[cfg(feature = "link_static")] pub use NodeTypeKeyCrossCrateImpl as NodeTypeKey;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeKeyCrossCrateImpl { type Target = AzNodeTypeKey; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeKeyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPathPseudoSelector` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPathPseudoSelector as CssPathPseudoSelector;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathPseudoSelectorCrossCrateImpl { pub _0: azul::AzCssPathPseudoSelector }

    #[cfg(feature = "link_static")] pub use CssPathPseudoSelectorCrossCrateImpl as CssPathPseudoSelector;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathPseudoSelectorCrossCrateImpl { type Target = AzCssPathPseudoSelector; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathPseudoSelectorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssNthChildSelector` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssNthChildSelector as CssNthChildSelector;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssNthChildSelectorCrossCrateImpl { pub _0: azul::AzCssNthChildSelector }

    #[cfg(feature = "link_static")] pub use CssNthChildSelectorCrossCrateImpl as CssNthChildSelector;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssNthChildSelectorCrossCrateImpl { type Target = AzCssNthChildSelector; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssNthChildSelectorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssNthChildPattern` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssNthChildPattern as CssNthChildPattern;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssNthChildPatternCrossCrateImpl { pub _0: azul::AzCssNthChildPattern }

    #[cfg(feature = "link_static")] pub use CssNthChildPatternCrossCrateImpl as CssNthChildPattern;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssNthChildPatternCrossCrateImpl { type Target = AzCssNthChildPattern; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssNthChildPatternCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Stylesheet` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylesheet as Stylesheet;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylesheetCrossCrateImpl { pub _0: azul::AzStylesheet }

    #[cfg(feature = "link_static")] pub use StylesheetCrossCrateImpl as Stylesheet;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylesheetCrossCrateImpl { type Target = AzStylesheet; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylesheetCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Css` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCss as Css;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssCrossCrateImpl { pub _0: azul::AzCss }

    #[cfg(feature = "link_static")] pub use CssCrossCrateImpl as Css;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssCrossCrateImpl { type Target = AzCss; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Css {

        /// Returns an empty CSS style
        pub fn empty() -> Self { unsafe { crate::dll::AzCss_empty() } }
        /// Returns a CSS style parsed from a `String`
        pub fn from_string(s: String) -> Self { unsafe { crate::dll::AzCss_fromString(s) } }
    }

    #[cfg(feature = "link_static")]
    impl CssCrossCrateImpl {

        /// Returns an empty CSS style
        pub fn empty() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzCss_empty() }) } }
        /// Returns a CSS style parsed from a `String`
        pub fn from_string(s: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzCss_fromString(s._0) }) } }
    }

    /// `CssPropertyType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertyType as CssPropertyType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyTypeCrossCrateImpl { pub _0: azul::AzCssPropertyType }

    #[cfg(feature = "link_static")] pub use CssPropertyTypeCrossCrateImpl as CssPropertyType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyTypeCrossCrateImpl { type Target = AzCssPropertyType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AnimationInterpolationFunction` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAnimationInterpolationFunction as AnimationInterpolationFunction;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AnimationInterpolationFunctionCrossCrateImpl { pub _0: azul::AzAnimationInterpolationFunction }

    #[cfg(feature = "link_static")] pub use AnimationInterpolationFunctionCrossCrateImpl as AnimationInterpolationFunction;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AnimationInterpolationFunctionCrossCrateImpl { type Target = AzAnimationInterpolationFunction; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AnimationInterpolationFunctionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InterpolateContext` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInterpolateContext as InterpolateContext;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InterpolateContextCrossCrateImpl { pub _0: azul::AzInterpolateContext }

    #[cfg(feature = "link_static")] pub use InterpolateContextCrossCrateImpl as InterpolateContext;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InterpolateContextCrossCrateImpl { type Target = AzInterpolateContext; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InterpolateContextCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorU` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorU as ColorU;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorUCrossCrateImpl { pub _0: azul::AzColorU }

    #[cfg(feature = "link_static")] pub use ColorUCrossCrateImpl as ColorU;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorUCrossCrateImpl { type Target = AzColorU; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorUCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ColorU {

        /// Creates a new `ColorU` instance.
        pub fn from_str(string: String) -> Self { unsafe { crate::dll::AzColorU_fromStr(string) } }
        /// Creates a new `ColorU` instance.
        pub fn transparent() -> Self { unsafe { crate::dll::AzColorU_transparent() } }
        /// Creates a new `ColorU` instance.
        pub fn white() -> Self { unsafe { crate::dll::AzColorU_white() } }
        /// Creates a new `ColorU` instance.
        pub fn black() -> Self { unsafe { crate::dll::AzColorU_black() } }
        /// Calls the `ColorU::to_hash` function.
        pub fn to_hash(&self)  -> crate::str::String { unsafe { crate::dll::AzColorU_toHash(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ColorUCrossCrateImpl {

        /// Creates a new `ColorU` instance.
        pub fn from_str(string: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzColorU_fromStr(string._0) }) } }
        /// Creates a new `ColorU` instance.
        pub fn transparent() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzColorU_transparent() }) } }
        /// Creates a new `ColorU` instance.
        pub fn white() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzColorU_white() }) } }
        /// Creates a new `ColorU` instance.
        pub fn black() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzColorU_black() }) } }
        /// Calls the `ColorU::to_hash` function.
        pub fn to_hash(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzColorU_toHash(&self._0) }) } }
    }

    /// `SizeMetric` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSizeMetric as SizeMetric;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SizeMetricCrossCrateImpl { pub _0: azul::AzSizeMetric }

    #[cfg(feature = "link_static")] pub use SizeMetricCrossCrateImpl as SizeMetric;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SizeMetricCrossCrateImpl { type Target = AzSizeMetric; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SizeMetricCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FloatValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFloatValue as FloatValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FloatValueCrossCrateImpl { pub _0: azul::AzFloatValue }

    #[cfg(feature = "link_static")] pub use FloatValueCrossCrateImpl as FloatValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FloatValueCrossCrateImpl { type Target = AzFloatValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FloatValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `PixelValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPixelValue as PixelValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PixelValueCrossCrateImpl { pub _0: azul::AzPixelValue }

    #[cfg(feature = "link_static")] pub use PixelValueCrossCrateImpl as PixelValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PixelValueCrossCrateImpl { type Target = AzPixelValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PixelValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `PixelValueNoPercent` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPixelValueNoPercent as PixelValueNoPercent;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PixelValueNoPercentCrossCrateImpl { pub _0: azul::AzPixelValueNoPercent }

    #[cfg(feature = "link_static")] pub use PixelValueNoPercentCrossCrateImpl as PixelValueNoPercent;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PixelValueNoPercentCrossCrateImpl { type Target = AzPixelValueNoPercent; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PixelValueNoPercentCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `BoxShadowClipMode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzBoxShadowClipMode as BoxShadowClipMode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct BoxShadowClipModeCrossCrateImpl { pub _0: azul::AzBoxShadowClipMode }

    #[cfg(feature = "link_static")] pub use BoxShadowClipModeCrossCrateImpl as BoxShadowClipMode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for BoxShadowClipModeCrossCrateImpl { type Target = AzBoxShadowClipMode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for BoxShadowClipModeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBoxShadow` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBoxShadow as StyleBoxShadow;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBoxShadowCrossCrateImpl { pub _0: azul::AzStyleBoxShadow }

    #[cfg(feature = "link_static")] pub use StyleBoxShadowCrossCrateImpl as StyleBoxShadow;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBoxShadowCrossCrateImpl { type Target = AzStyleBoxShadow; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBoxShadowCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleMixBlendMode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleMixBlendMode as StyleMixBlendMode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleMixBlendModeCrossCrateImpl { pub _0: azul::AzStyleMixBlendMode }

    #[cfg(feature = "link_static")] pub use StyleMixBlendModeCrossCrateImpl as StyleMixBlendMode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleMixBlendModeCrossCrateImpl { type Target = AzStyleMixBlendMode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleMixBlendModeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilter as StyleFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterCrossCrateImpl { pub _0: azul::AzStyleFilter }

    #[cfg(feature = "link_static")] pub use StyleFilterCrossCrateImpl as StyleFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterCrossCrateImpl { type Target = AzStyleFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBlur` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBlur as StyleBlur;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBlurCrossCrateImpl { pub _0: azul::AzStyleBlur }

    #[cfg(feature = "link_static")] pub use StyleBlurCrossCrateImpl as StyleBlur;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBlurCrossCrateImpl { type Target = AzStyleBlur; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBlurCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleColorMatrix` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleColorMatrix as StyleColorMatrix;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleColorMatrixCrossCrateImpl { pub _0: azul::AzStyleColorMatrix }

    #[cfg(feature = "link_static")] pub use StyleColorMatrixCrossCrateImpl as StyleColorMatrix;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleColorMatrixCrossCrateImpl { type Target = AzStyleColorMatrix; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleColorMatrixCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFilterOffset` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilterOffset as StyleFilterOffset;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterOffsetCrossCrateImpl { pub _0: azul::AzStyleFilterOffset }

    #[cfg(feature = "link_static")] pub use StyleFilterOffsetCrossCrateImpl as StyleFilterOffset;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterOffsetCrossCrateImpl { type Target = AzStyleFilterOffset; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterOffsetCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleCompositeFilter` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleCompositeFilter as StyleCompositeFilter;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleCompositeFilterCrossCrateImpl { pub _0: azul::AzStyleCompositeFilter }

    #[cfg(feature = "link_static")] pub use StyleCompositeFilterCrossCrateImpl as StyleCompositeFilter;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleCompositeFilterCrossCrateImpl { type Target = AzStyleCompositeFilter; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleCompositeFilterCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutAlignContent` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutAlignContent as LayoutAlignContent;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutAlignContentCrossCrateImpl { pub _0: azul::AzLayoutAlignContent }

    #[cfg(feature = "link_static")] pub use LayoutAlignContentCrossCrateImpl as LayoutAlignContent;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutAlignContentCrossCrateImpl { type Target = AzLayoutAlignContent; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutAlignContentCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutAlignItems` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutAlignItems as LayoutAlignItems;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutAlignItemsCrossCrateImpl { pub _0: azul::AzLayoutAlignItems }

    #[cfg(feature = "link_static")] pub use LayoutAlignItemsCrossCrateImpl as LayoutAlignItems;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutAlignItemsCrossCrateImpl { type Target = AzLayoutAlignItems; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutAlignItemsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBottom` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBottom as LayoutBottom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBottomCrossCrateImpl { pub _0: azul::AzLayoutBottom }

    #[cfg(feature = "link_static")] pub use LayoutBottomCrossCrateImpl as LayoutBottom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBottomCrossCrateImpl { type Target = AzLayoutBottom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBottomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBoxSizing` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBoxSizing as LayoutBoxSizing;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBoxSizingCrossCrateImpl { pub _0: azul::AzLayoutBoxSizing }

    #[cfg(feature = "link_static")] pub use LayoutBoxSizingCrossCrateImpl as LayoutBoxSizing;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBoxSizingCrossCrateImpl { type Target = AzLayoutBoxSizing; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBoxSizingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexDirection` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexDirection as LayoutFlexDirection;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexDirectionCrossCrateImpl { pub _0: azul::AzLayoutFlexDirection }

    #[cfg(feature = "link_static")] pub use LayoutFlexDirectionCrossCrateImpl as LayoutFlexDirection;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexDirectionCrossCrateImpl { type Target = AzLayoutFlexDirection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexDirectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutDisplay` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutDisplay as LayoutDisplay;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutDisplayCrossCrateImpl { pub _0: azul::AzLayoutDisplay }

    #[cfg(feature = "link_static")] pub use LayoutDisplayCrossCrateImpl as LayoutDisplay;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutDisplayCrossCrateImpl { type Target = AzLayoutDisplay; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutDisplayCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexGrow` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexGrow as LayoutFlexGrow;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexGrowCrossCrateImpl { pub _0: azul::AzLayoutFlexGrow }

    #[cfg(feature = "link_static")] pub use LayoutFlexGrowCrossCrateImpl as LayoutFlexGrow;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexGrowCrossCrateImpl { type Target = AzLayoutFlexGrow; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexGrowCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexShrink` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexShrink as LayoutFlexShrink;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexShrinkCrossCrateImpl { pub _0: azul::AzLayoutFlexShrink }

    #[cfg(feature = "link_static")] pub use LayoutFlexShrinkCrossCrateImpl as LayoutFlexShrink;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexShrinkCrossCrateImpl { type Target = AzLayoutFlexShrink; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexShrinkCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFloat` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFloat as LayoutFloat;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFloatCrossCrateImpl { pub _0: azul::AzLayoutFloat }

    #[cfg(feature = "link_static")] pub use LayoutFloatCrossCrateImpl as LayoutFloat;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFloatCrossCrateImpl { type Target = AzLayoutFloat; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFloatCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutHeight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutHeight as LayoutHeight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutHeightCrossCrateImpl { pub _0: azul::AzLayoutHeight }

    #[cfg(feature = "link_static")] pub use LayoutHeightCrossCrateImpl as LayoutHeight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutHeightCrossCrateImpl { type Target = AzLayoutHeight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutHeightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutJustifyContent` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutJustifyContent as LayoutJustifyContent;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutJustifyContentCrossCrateImpl { pub _0: azul::AzLayoutJustifyContent }

    #[cfg(feature = "link_static")] pub use LayoutJustifyContentCrossCrateImpl as LayoutJustifyContent;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutJustifyContentCrossCrateImpl { type Target = AzLayoutJustifyContent; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutJustifyContentCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutLeft` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutLeft as LayoutLeft;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutLeftCrossCrateImpl { pub _0: azul::AzLayoutLeft }

    #[cfg(feature = "link_static")] pub use LayoutLeftCrossCrateImpl as LayoutLeft;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutLeftCrossCrateImpl { type Target = AzLayoutLeft; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutLeftCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginBottom` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginBottom as LayoutMarginBottom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginBottomCrossCrateImpl { pub _0: azul::AzLayoutMarginBottom }

    #[cfg(feature = "link_static")] pub use LayoutMarginBottomCrossCrateImpl as LayoutMarginBottom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginBottomCrossCrateImpl { type Target = AzLayoutMarginBottom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginBottomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginLeft` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginLeft as LayoutMarginLeft;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginLeftCrossCrateImpl { pub _0: azul::AzLayoutMarginLeft }

    #[cfg(feature = "link_static")] pub use LayoutMarginLeftCrossCrateImpl as LayoutMarginLeft;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginLeftCrossCrateImpl { type Target = AzLayoutMarginLeft; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginLeftCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginRight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginRight as LayoutMarginRight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginRightCrossCrateImpl { pub _0: azul::AzLayoutMarginRight }

    #[cfg(feature = "link_static")] pub use LayoutMarginRightCrossCrateImpl as LayoutMarginRight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginRightCrossCrateImpl { type Target = AzLayoutMarginRight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginRightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginTop` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginTop as LayoutMarginTop;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginTopCrossCrateImpl { pub _0: azul::AzLayoutMarginTop }

    #[cfg(feature = "link_static")] pub use LayoutMarginTopCrossCrateImpl as LayoutMarginTop;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginTopCrossCrateImpl { type Target = AzLayoutMarginTop; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginTopCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMaxHeight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMaxHeight as LayoutMaxHeight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMaxHeightCrossCrateImpl { pub _0: azul::AzLayoutMaxHeight }

    #[cfg(feature = "link_static")] pub use LayoutMaxHeightCrossCrateImpl as LayoutMaxHeight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMaxHeightCrossCrateImpl { type Target = AzLayoutMaxHeight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMaxHeightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMaxWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMaxWidth as LayoutMaxWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMaxWidthCrossCrateImpl { pub _0: azul::AzLayoutMaxWidth }

    #[cfg(feature = "link_static")] pub use LayoutMaxWidthCrossCrateImpl as LayoutMaxWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMaxWidthCrossCrateImpl { type Target = AzLayoutMaxWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMaxWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMinHeight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMinHeight as LayoutMinHeight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMinHeightCrossCrateImpl { pub _0: azul::AzLayoutMinHeight }

    #[cfg(feature = "link_static")] pub use LayoutMinHeightCrossCrateImpl as LayoutMinHeight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMinHeightCrossCrateImpl { type Target = AzLayoutMinHeight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMinHeightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMinWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMinWidth as LayoutMinWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMinWidthCrossCrateImpl { pub _0: azul::AzLayoutMinWidth }

    #[cfg(feature = "link_static")] pub use LayoutMinWidthCrossCrateImpl as LayoutMinWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMinWidthCrossCrateImpl { type Target = AzLayoutMinWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMinWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingBottom` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingBottom as LayoutPaddingBottom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingBottomCrossCrateImpl { pub _0: azul::AzLayoutPaddingBottom }

    #[cfg(feature = "link_static")] pub use LayoutPaddingBottomCrossCrateImpl as LayoutPaddingBottom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingBottomCrossCrateImpl { type Target = AzLayoutPaddingBottom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingBottomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingLeft` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingLeft as LayoutPaddingLeft;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingLeftCrossCrateImpl { pub _0: azul::AzLayoutPaddingLeft }

    #[cfg(feature = "link_static")] pub use LayoutPaddingLeftCrossCrateImpl as LayoutPaddingLeft;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingLeftCrossCrateImpl { type Target = AzLayoutPaddingLeft; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingLeftCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingRight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingRight as LayoutPaddingRight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingRightCrossCrateImpl { pub _0: azul::AzLayoutPaddingRight }

    #[cfg(feature = "link_static")] pub use LayoutPaddingRightCrossCrateImpl as LayoutPaddingRight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingRightCrossCrateImpl { type Target = AzLayoutPaddingRight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingRightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingTop` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingTop as LayoutPaddingTop;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingTopCrossCrateImpl { pub _0: azul::AzLayoutPaddingTop }

    #[cfg(feature = "link_static")] pub use LayoutPaddingTopCrossCrateImpl as LayoutPaddingTop;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingTopCrossCrateImpl { type Target = AzLayoutPaddingTop; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingTopCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPosition` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPosition as LayoutPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPositionCrossCrateImpl { pub _0: azul::AzLayoutPosition }

    #[cfg(feature = "link_static")] pub use LayoutPositionCrossCrateImpl as LayoutPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPositionCrossCrateImpl { type Target = AzLayoutPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutRight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutRight as LayoutRight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutRightCrossCrateImpl { pub _0: azul::AzLayoutRight }

    #[cfg(feature = "link_static")] pub use LayoutRightCrossCrateImpl as LayoutRight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutRightCrossCrateImpl { type Target = AzLayoutRight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutRightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutTop` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutTop as LayoutTop;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutTopCrossCrateImpl { pub _0: azul::AzLayoutTop }

    #[cfg(feature = "link_static")] pub use LayoutTopCrossCrateImpl as LayoutTop;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutTopCrossCrateImpl { type Target = AzLayoutTop; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutTopCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutWidth as LayoutWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutWidthCrossCrateImpl { pub _0: azul::AzLayoutWidth }

    #[cfg(feature = "link_static")] pub use LayoutWidthCrossCrateImpl as LayoutWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutWidthCrossCrateImpl { type Target = AzLayoutWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexWrap` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexWrap as LayoutFlexWrap;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexWrapCrossCrateImpl { pub _0: azul::AzLayoutFlexWrap }

    #[cfg(feature = "link_static")] pub use LayoutFlexWrapCrossCrateImpl as LayoutFlexWrap;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexWrapCrossCrateImpl { type Target = AzLayoutFlexWrap; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexWrapCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutOverflow` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutOverflow as LayoutOverflow;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutOverflowCrossCrateImpl { pub _0: azul::AzLayoutOverflow }

    #[cfg(feature = "link_static")] pub use LayoutOverflowCrossCrateImpl as LayoutOverflow;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutOverflowCrossCrateImpl { type Target = AzLayoutOverflow; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutOverflowCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `PercentageValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzPercentageValue as PercentageValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct PercentageValueCrossCrateImpl { pub _0: azul::AzPercentageValue }

    #[cfg(feature = "link_static")] pub use PercentageValueCrossCrateImpl as PercentageValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for PercentageValueCrossCrateImpl { type Target = AzPercentageValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for PercentageValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AngleMetric` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAngleMetric as AngleMetric;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AngleMetricCrossCrateImpl { pub _0: azul::AzAngleMetric }

    #[cfg(feature = "link_static")] pub use AngleMetricCrossCrateImpl as AngleMetric;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AngleMetricCrossCrateImpl { type Target = AzAngleMetric; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AngleMetricCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AngleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAngleValue as AngleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AngleValueCrossCrateImpl { pub _0: azul::AzAngleValue }

    #[cfg(feature = "link_static")] pub use AngleValueCrossCrateImpl as AngleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AngleValueCrossCrateImpl { type Target = AzAngleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AngleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl AngleValue {

        /// Calls the `AngleValue::get_degrees` function.
        pub fn get_degrees(&self)  -> f32 { unsafe { crate::dll::AzAngleValue_getDegrees(self) } }
    }

    #[cfg(feature = "link_static")]
    impl AngleValueCrossCrateImpl {

        /// Calls the `AngleValue::get_degrees` function.
        pub fn get_degrees(&self)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzAngleValue_getDegrees(&self._0) }) } }
    }

    /// `NormalizedLinearColorStop` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedLinearColorStop as NormalizedLinearColorStop;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedLinearColorStopCrossCrateImpl { pub _0: azul::AzNormalizedLinearColorStop }

    #[cfg(feature = "link_static")] pub use NormalizedLinearColorStopCrossCrateImpl as NormalizedLinearColorStop;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedLinearColorStopCrossCrateImpl { type Target = AzNormalizedLinearColorStop; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedLinearColorStopCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NormalizedRadialColorStop` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedRadialColorStop as NormalizedRadialColorStop;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedRadialColorStopCrossCrateImpl { pub _0: azul::AzNormalizedRadialColorStop }

    #[cfg(feature = "link_static")] pub use NormalizedRadialColorStopCrossCrateImpl as NormalizedRadialColorStop;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedRadialColorStopCrossCrateImpl { type Target = AzNormalizedRadialColorStop; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedRadialColorStopCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DirectionCorner` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDirectionCorner as DirectionCorner;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DirectionCornerCrossCrateImpl { pub _0: azul::AzDirectionCorner }

    #[cfg(feature = "link_static")] pub use DirectionCornerCrossCrateImpl as DirectionCorner;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DirectionCornerCrossCrateImpl { type Target = AzDirectionCorner; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DirectionCornerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DirectionCorners` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDirectionCorners as DirectionCorners;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DirectionCornersCrossCrateImpl { pub _0: azul::AzDirectionCorners }

    #[cfg(feature = "link_static")] pub use DirectionCornersCrossCrateImpl as DirectionCorners;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DirectionCornersCrossCrateImpl { type Target = AzDirectionCorners; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DirectionCornersCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Direction` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDirection as Direction;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DirectionCrossCrateImpl { pub _0: azul::AzDirection }

    #[cfg(feature = "link_static")] pub use DirectionCrossCrateImpl as Direction;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DirectionCrossCrateImpl { type Target = AzDirection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DirectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ExtendMode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzExtendMode as ExtendMode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ExtendModeCrossCrateImpl { pub _0: azul::AzExtendMode }

    #[cfg(feature = "link_static")] pub use ExtendModeCrossCrateImpl as ExtendMode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ExtendModeCrossCrateImpl { type Target = AzExtendMode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ExtendModeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LinearGradient` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLinearGradient as LinearGradient;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LinearGradientCrossCrateImpl { pub _0: azul::AzLinearGradient }

    #[cfg(feature = "link_static")] pub use LinearGradientCrossCrateImpl as LinearGradient;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LinearGradientCrossCrateImpl { type Target = AzLinearGradient; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LinearGradientCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Shape` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzShape as Shape;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ShapeCrossCrateImpl { pub _0: azul::AzShape }

    #[cfg(feature = "link_static")] pub use ShapeCrossCrateImpl as Shape;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ShapeCrossCrateImpl { type Target = AzShape; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ShapeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RadialGradientSize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRadialGradientSize as RadialGradientSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RadialGradientSizeCrossCrateImpl { pub _0: azul::AzRadialGradientSize }

    #[cfg(feature = "link_static")] pub use RadialGradientSizeCrossCrateImpl as RadialGradientSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RadialGradientSizeCrossCrateImpl { type Target = AzRadialGradientSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RadialGradientSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RadialGradient` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRadialGradient as RadialGradient;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RadialGradientCrossCrateImpl { pub _0: azul::AzRadialGradient }

    #[cfg(feature = "link_static")] pub use RadialGradientCrossCrateImpl as RadialGradient;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RadialGradientCrossCrateImpl { type Target = AzRadialGradient; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RadialGradientCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ConicGradient` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzConicGradient as ConicGradient;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ConicGradientCrossCrateImpl { pub _0: azul::AzConicGradient }

    #[cfg(feature = "link_static")] pub use ConicGradientCrossCrateImpl as ConicGradient;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ConicGradientCrossCrateImpl { type Target = AzConicGradient; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ConicGradientCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundContent` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundContent as StyleBackgroundContent;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundContentCrossCrateImpl { pub _0: azul::AzStyleBackgroundContent }

    #[cfg(feature = "link_static")] pub use StyleBackgroundContentCrossCrateImpl as StyleBackgroundContent;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundContentCrossCrateImpl { type Target = AzStyleBackgroundContent; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundContentCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `BackgroundPositionHorizontal` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzBackgroundPositionHorizontal as BackgroundPositionHorizontal;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct BackgroundPositionHorizontalCrossCrateImpl { pub _0: azul::AzBackgroundPositionHorizontal }

    #[cfg(feature = "link_static")] pub use BackgroundPositionHorizontalCrossCrateImpl as BackgroundPositionHorizontal;

    #[cfg(feature = "link_static")] impl core::ops::Deref for BackgroundPositionHorizontalCrossCrateImpl { type Target = AzBackgroundPositionHorizontal; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for BackgroundPositionHorizontalCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `BackgroundPositionVertical` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzBackgroundPositionVertical as BackgroundPositionVertical;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct BackgroundPositionVerticalCrossCrateImpl { pub _0: azul::AzBackgroundPositionVertical }

    #[cfg(feature = "link_static")] pub use BackgroundPositionVerticalCrossCrateImpl as BackgroundPositionVertical;

    #[cfg(feature = "link_static")] impl core::ops::Deref for BackgroundPositionVerticalCrossCrateImpl { type Target = AzBackgroundPositionVertical; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for BackgroundPositionVerticalCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundPosition` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundPosition as StyleBackgroundPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundPositionCrossCrateImpl { pub _0: azul::AzStyleBackgroundPosition }

    #[cfg(feature = "link_static")] pub use StyleBackgroundPositionCrossCrateImpl as StyleBackgroundPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundPositionCrossCrateImpl { type Target = AzStyleBackgroundPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundRepeat` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundRepeat as StyleBackgroundRepeat;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundRepeatCrossCrateImpl { pub _0: azul::AzStyleBackgroundRepeat }

    #[cfg(feature = "link_static")] pub use StyleBackgroundRepeatCrossCrateImpl as StyleBackgroundRepeat;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundRepeatCrossCrateImpl { type Target = AzStyleBackgroundRepeat; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundRepeatCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundSize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundSize as StyleBackgroundSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundSizeCrossCrateImpl { pub _0: azul::AzStyleBackgroundSize }

    #[cfg(feature = "link_static")] pub use StyleBackgroundSizeCrossCrateImpl as StyleBackgroundSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundSizeCrossCrateImpl { type Target = AzStyleBackgroundSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomColor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomColor as StyleBorderBottomColor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomColorCrossCrateImpl { pub _0: azul::AzStyleBorderBottomColor }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomColorCrossCrateImpl as StyleBorderBottomColor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomColorCrossCrateImpl { type Target = AzStyleBorderBottomColor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomColorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomLeftRadius` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomLeftRadius as StyleBorderBottomLeftRadius;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomLeftRadiusCrossCrateImpl { pub _0: azul::AzStyleBorderBottomLeftRadius }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomLeftRadiusCrossCrateImpl as StyleBorderBottomLeftRadius;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomLeftRadiusCrossCrateImpl { type Target = AzStyleBorderBottomLeftRadius; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomLeftRadiusCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomRightRadius` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomRightRadius as StyleBorderBottomRightRadius;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomRightRadiusCrossCrateImpl { pub _0: azul::AzStyleBorderBottomRightRadius }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomRightRadiusCrossCrateImpl as StyleBorderBottomRightRadius;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomRightRadiusCrossCrateImpl { type Target = AzStyleBorderBottomRightRadius; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomRightRadiusCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `BorderStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzBorderStyle as BorderStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct BorderStyleCrossCrateImpl { pub _0: azul::AzBorderStyle }

    #[cfg(feature = "link_static")] pub use BorderStyleCrossCrateImpl as BorderStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for BorderStyleCrossCrateImpl { type Target = AzBorderStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for BorderStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomStyle as StyleBorderBottomStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomStyleCrossCrateImpl { pub _0: azul::AzStyleBorderBottomStyle }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomStyleCrossCrateImpl as StyleBorderBottomStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomStyleCrossCrateImpl { type Target = AzStyleBorderBottomStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderBottomWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderBottomWidth as LayoutBorderBottomWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderBottomWidthCrossCrateImpl { pub _0: azul::AzLayoutBorderBottomWidth }

    #[cfg(feature = "link_static")] pub use LayoutBorderBottomWidthCrossCrateImpl as LayoutBorderBottomWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderBottomWidthCrossCrateImpl { type Target = AzLayoutBorderBottomWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderBottomWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderLeftColor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderLeftColor as StyleBorderLeftColor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderLeftColorCrossCrateImpl { pub _0: azul::AzStyleBorderLeftColor }

    #[cfg(feature = "link_static")] pub use StyleBorderLeftColorCrossCrateImpl as StyleBorderLeftColor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderLeftColorCrossCrateImpl { type Target = AzStyleBorderLeftColor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderLeftColorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderLeftStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderLeftStyle as StyleBorderLeftStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderLeftStyleCrossCrateImpl { pub _0: azul::AzStyleBorderLeftStyle }

    #[cfg(feature = "link_static")] pub use StyleBorderLeftStyleCrossCrateImpl as StyleBorderLeftStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderLeftStyleCrossCrateImpl { type Target = AzStyleBorderLeftStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderLeftStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderLeftWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderLeftWidth as LayoutBorderLeftWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderLeftWidthCrossCrateImpl { pub _0: azul::AzLayoutBorderLeftWidth }

    #[cfg(feature = "link_static")] pub use LayoutBorderLeftWidthCrossCrateImpl as LayoutBorderLeftWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderLeftWidthCrossCrateImpl { type Target = AzLayoutBorderLeftWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderLeftWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderRightColor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderRightColor as StyleBorderRightColor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderRightColorCrossCrateImpl { pub _0: azul::AzStyleBorderRightColor }

    #[cfg(feature = "link_static")] pub use StyleBorderRightColorCrossCrateImpl as StyleBorderRightColor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderRightColorCrossCrateImpl { type Target = AzStyleBorderRightColor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderRightColorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderRightStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderRightStyle as StyleBorderRightStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderRightStyleCrossCrateImpl { pub _0: azul::AzStyleBorderRightStyle }

    #[cfg(feature = "link_static")] pub use StyleBorderRightStyleCrossCrateImpl as StyleBorderRightStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderRightStyleCrossCrateImpl { type Target = AzStyleBorderRightStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderRightStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderRightWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderRightWidth as LayoutBorderRightWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderRightWidthCrossCrateImpl { pub _0: azul::AzLayoutBorderRightWidth }

    #[cfg(feature = "link_static")] pub use LayoutBorderRightWidthCrossCrateImpl as LayoutBorderRightWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderRightWidthCrossCrateImpl { type Target = AzLayoutBorderRightWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderRightWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopColor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopColor as StyleBorderTopColor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopColorCrossCrateImpl { pub _0: azul::AzStyleBorderTopColor }

    #[cfg(feature = "link_static")] pub use StyleBorderTopColorCrossCrateImpl as StyleBorderTopColor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopColorCrossCrateImpl { type Target = AzStyleBorderTopColor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopColorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopLeftRadius` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopLeftRadius as StyleBorderTopLeftRadius;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopLeftRadiusCrossCrateImpl { pub _0: azul::AzStyleBorderTopLeftRadius }

    #[cfg(feature = "link_static")] pub use StyleBorderTopLeftRadiusCrossCrateImpl as StyleBorderTopLeftRadius;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopLeftRadiusCrossCrateImpl { type Target = AzStyleBorderTopLeftRadius; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopLeftRadiusCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopRightRadius` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopRightRadius as StyleBorderTopRightRadius;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopRightRadiusCrossCrateImpl { pub _0: azul::AzStyleBorderTopRightRadius }

    #[cfg(feature = "link_static")] pub use StyleBorderTopRightRadiusCrossCrateImpl as StyleBorderTopRightRadius;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopRightRadiusCrossCrateImpl { type Target = AzStyleBorderTopRightRadius; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopRightRadiusCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopStyle as StyleBorderTopStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopStyleCrossCrateImpl { pub _0: azul::AzStyleBorderTopStyle }

    #[cfg(feature = "link_static")] pub use StyleBorderTopStyleCrossCrateImpl as StyleBorderTopStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopStyleCrossCrateImpl { type Target = AzStyleBorderTopStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderTopWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderTopWidth as LayoutBorderTopWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderTopWidthCrossCrateImpl { pub _0: azul::AzLayoutBorderTopWidth }

    #[cfg(feature = "link_static")] pub use LayoutBorderTopWidthCrossCrateImpl as LayoutBorderTopWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderTopWidthCrossCrateImpl { type Target = AzLayoutBorderTopWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderTopWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ScrollbarInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScrollbarInfo as ScrollbarInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScrollbarInfoCrossCrateImpl { pub _0: azul::AzScrollbarInfo }

    #[cfg(feature = "link_static")] pub use ScrollbarInfoCrossCrateImpl as ScrollbarInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScrollbarInfoCrossCrateImpl { type Target = AzScrollbarInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScrollbarInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ScrollbarStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScrollbarStyle as ScrollbarStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScrollbarStyleCrossCrateImpl { pub _0: azul::AzScrollbarStyle }

    #[cfg(feature = "link_static")] pub use ScrollbarStyleCrossCrateImpl as ScrollbarStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScrollbarStyleCrossCrateImpl { type Target = AzScrollbarStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScrollbarStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleCursor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleCursor as StyleCursor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleCursorCrossCrateImpl { pub _0: azul::AzStyleCursor }

    #[cfg(feature = "link_static")] pub use StyleCursorCrossCrateImpl as StyleCursor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleCursorCrossCrateImpl { type Target = AzStyleCursor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleCursorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontFamily` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontFamily as StyleFontFamily;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontFamilyCrossCrateImpl { pub _0: azul::AzStyleFontFamily }

    #[cfg(feature = "link_static")] pub use StyleFontFamilyCrossCrateImpl as StyleFontFamily;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontFamilyCrossCrateImpl { type Target = AzStyleFontFamily; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontFamilyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontSize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontSize as StyleFontSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontSizeCrossCrateImpl { pub _0: azul::AzStyleFontSize }

    #[cfg(feature = "link_static")] pub use StyleFontSizeCrossCrateImpl as StyleFontSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontSizeCrossCrateImpl { type Target = AzStyleFontSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleLetterSpacing` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleLetterSpacing as StyleLetterSpacing;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleLetterSpacingCrossCrateImpl { pub _0: azul::AzStyleLetterSpacing }

    #[cfg(feature = "link_static")] pub use StyleLetterSpacingCrossCrateImpl as StyleLetterSpacing;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleLetterSpacingCrossCrateImpl { type Target = AzStyleLetterSpacing; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleLetterSpacingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleLineHeight` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleLineHeight as StyleLineHeight;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleLineHeightCrossCrateImpl { pub _0: azul::AzStyleLineHeight }

    #[cfg(feature = "link_static")] pub use StyleLineHeightCrossCrateImpl as StyleLineHeight;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleLineHeightCrossCrateImpl { type Target = AzStyleLineHeight; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleLineHeightCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTabWidth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTabWidth as StyleTabWidth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTabWidthCrossCrateImpl { pub _0: azul::AzStyleTabWidth }

    #[cfg(feature = "link_static")] pub use StyleTabWidthCrossCrateImpl as StyleTabWidth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTabWidthCrossCrateImpl { type Target = AzStyleTabWidth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTabWidthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleOpacity` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleOpacity as StyleOpacity;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleOpacityCrossCrateImpl { pub _0: azul::AzStyleOpacity }

    #[cfg(feature = "link_static")] pub use StyleOpacityCrossCrateImpl as StyleOpacity;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleOpacityCrossCrateImpl { type Target = AzStyleOpacity; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleOpacityCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformOrigin` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformOrigin as StyleTransformOrigin;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformOriginCrossCrateImpl { pub _0: azul::AzStyleTransformOrigin }

    #[cfg(feature = "link_static")] pub use StyleTransformOriginCrossCrateImpl as StyleTransformOrigin;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformOriginCrossCrateImpl { type Target = AzStyleTransformOrigin; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformOriginCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StylePerspectiveOrigin` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylePerspectiveOrigin as StylePerspectiveOrigin;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylePerspectiveOriginCrossCrateImpl { pub _0: azul::AzStylePerspectiveOrigin }

    #[cfg(feature = "link_static")] pub use StylePerspectiveOriginCrossCrateImpl as StylePerspectiveOrigin;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylePerspectiveOriginCrossCrateImpl { type Target = AzStylePerspectiveOrigin; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylePerspectiveOriginCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackfaceVisibility` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackfaceVisibility as StyleBackfaceVisibility;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackfaceVisibilityCrossCrateImpl { pub _0: azul::AzStyleBackfaceVisibility }

    #[cfg(feature = "link_static")] pub use StyleBackfaceVisibilityCrossCrateImpl as StyleBackfaceVisibility;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackfaceVisibilityCrossCrateImpl { type Target = AzStyleBackfaceVisibility; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackfaceVisibilityCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransform` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransform as StyleTransform;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformCrossCrateImpl { pub _0: azul::AzStyleTransform }

    #[cfg(feature = "link_static")] pub use StyleTransformCrossCrateImpl as StyleTransform;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformCrossCrateImpl { type Target = AzStyleTransform; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformMatrix2D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformMatrix2D as StyleTransformMatrix2D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformMatrix2DCrossCrateImpl { pub _0: azul::AzStyleTransformMatrix2D }

    #[cfg(feature = "link_static")] pub use StyleTransformMatrix2DCrossCrateImpl as StyleTransformMatrix2D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformMatrix2DCrossCrateImpl { type Target = AzStyleTransformMatrix2D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformMatrix2DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformMatrix3D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformMatrix3D as StyleTransformMatrix3D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformMatrix3DCrossCrateImpl { pub _0: azul::AzStyleTransformMatrix3D }

    #[cfg(feature = "link_static")] pub use StyleTransformMatrix3DCrossCrateImpl as StyleTransformMatrix3D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformMatrix3DCrossCrateImpl { type Target = AzStyleTransformMatrix3D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformMatrix3DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformTranslate2D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformTranslate2D as StyleTransformTranslate2D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformTranslate2DCrossCrateImpl { pub _0: azul::AzStyleTransformTranslate2D }

    #[cfg(feature = "link_static")] pub use StyleTransformTranslate2DCrossCrateImpl as StyleTransformTranslate2D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformTranslate2DCrossCrateImpl { type Target = AzStyleTransformTranslate2D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformTranslate2DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformTranslate3D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformTranslate3D as StyleTransformTranslate3D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformTranslate3DCrossCrateImpl { pub _0: azul::AzStyleTransformTranslate3D }

    #[cfg(feature = "link_static")] pub use StyleTransformTranslate3DCrossCrateImpl as StyleTransformTranslate3D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformTranslate3DCrossCrateImpl { type Target = AzStyleTransformTranslate3D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformTranslate3DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformRotate3D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformRotate3D as StyleTransformRotate3D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformRotate3DCrossCrateImpl { pub _0: azul::AzStyleTransformRotate3D }

    #[cfg(feature = "link_static")] pub use StyleTransformRotate3DCrossCrateImpl as StyleTransformRotate3D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformRotate3DCrossCrateImpl { type Target = AzStyleTransformRotate3D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformRotate3DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformScale2D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformScale2D as StyleTransformScale2D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformScale2DCrossCrateImpl { pub _0: azul::AzStyleTransformScale2D }

    #[cfg(feature = "link_static")] pub use StyleTransformScale2DCrossCrateImpl as StyleTransformScale2D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformScale2DCrossCrateImpl { type Target = AzStyleTransformScale2D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformScale2DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformScale3D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformScale3D as StyleTransformScale3D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformScale3DCrossCrateImpl { pub _0: azul::AzStyleTransformScale3D }

    #[cfg(feature = "link_static")] pub use StyleTransformScale3DCrossCrateImpl as StyleTransformScale3D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformScale3DCrossCrateImpl { type Target = AzStyleTransformScale3D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformScale3DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformSkew2D` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformSkew2D as StyleTransformSkew2D;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformSkew2DCrossCrateImpl { pub _0: azul::AzStyleTransformSkew2D }

    #[cfg(feature = "link_static")] pub use StyleTransformSkew2DCrossCrateImpl as StyleTransformSkew2D;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformSkew2DCrossCrateImpl { type Target = AzStyleTransformSkew2D; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformSkew2DCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTextAlign` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTextAlign as StyleTextAlign;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTextAlignCrossCrateImpl { pub _0: azul::AzStyleTextAlign }

    #[cfg(feature = "link_static")] pub use StyleTextAlignCrossCrateImpl as StyleTextAlign;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTextAlignCrossCrateImpl { type Target = AzStyleTextAlign; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTextAlignCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTextColor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTextColor as StyleTextColor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTextColorCrossCrateImpl { pub _0: azul::AzStyleTextColor }

    #[cfg(feature = "link_static")] pub use StyleTextColorCrossCrateImpl as StyleTextColor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTextColorCrossCrateImpl { type Target = AzStyleTextColor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTextColorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleWordSpacing` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleWordSpacing as StyleWordSpacing;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleWordSpacingCrossCrateImpl { pub _0: azul::AzStyleWordSpacing }

    #[cfg(feature = "link_static")] pub use StyleWordSpacingCrossCrateImpl as StyleWordSpacing;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleWordSpacingCrossCrateImpl { type Target = AzStyleWordSpacing; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleWordSpacingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBoxShadowValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBoxShadowValue as StyleBoxShadowValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBoxShadowValueCrossCrateImpl { pub _0: azul::AzStyleBoxShadowValue }

    #[cfg(feature = "link_static")] pub use StyleBoxShadowValueCrossCrateImpl as StyleBoxShadowValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBoxShadowValueCrossCrateImpl { type Target = AzStyleBoxShadowValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBoxShadowValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutAlignContentValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutAlignContentValue as LayoutAlignContentValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutAlignContentValueCrossCrateImpl { pub _0: azul::AzLayoutAlignContentValue }

    #[cfg(feature = "link_static")] pub use LayoutAlignContentValueCrossCrateImpl as LayoutAlignContentValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutAlignContentValueCrossCrateImpl { type Target = AzLayoutAlignContentValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutAlignContentValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutAlignItemsValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutAlignItemsValue as LayoutAlignItemsValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutAlignItemsValueCrossCrateImpl { pub _0: azul::AzLayoutAlignItemsValue }

    #[cfg(feature = "link_static")] pub use LayoutAlignItemsValueCrossCrateImpl as LayoutAlignItemsValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutAlignItemsValueCrossCrateImpl { type Target = AzLayoutAlignItemsValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutAlignItemsValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBottomValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBottomValue as LayoutBottomValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBottomValueCrossCrateImpl { pub _0: azul::AzLayoutBottomValue }

    #[cfg(feature = "link_static")] pub use LayoutBottomValueCrossCrateImpl as LayoutBottomValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBottomValueCrossCrateImpl { type Target = AzLayoutBottomValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBottomValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBoxSizingValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBoxSizingValue as LayoutBoxSizingValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBoxSizingValueCrossCrateImpl { pub _0: azul::AzLayoutBoxSizingValue }

    #[cfg(feature = "link_static")] pub use LayoutBoxSizingValueCrossCrateImpl as LayoutBoxSizingValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBoxSizingValueCrossCrateImpl { type Target = AzLayoutBoxSizingValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBoxSizingValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexDirectionValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexDirectionValue as LayoutFlexDirectionValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexDirectionValueCrossCrateImpl { pub _0: azul::AzLayoutFlexDirectionValue }

    #[cfg(feature = "link_static")] pub use LayoutFlexDirectionValueCrossCrateImpl as LayoutFlexDirectionValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexDirectionValueCrossCrateImpl { type Target = AzLayoutFlexDirectionValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexDirectionValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutDisplayValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutDisplayValue as LayoutDisplayValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutDisplayValueCrossCrateImpl { pub _0: azul::AzLayoutDisplayValue }

    #[cfg(feature = "link_static")] pub use LayoutDisplayValueCrossCrateImpl as LayoutDisplayValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutDisplayValueCrossCrateImpl { type Target = AzLayoutDisplayValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutDisplayValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexGrowValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexGrowValue as LayoutFlexGrowValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexGrowValueCrossCrateImpl { pub _0: azul::AzLayoutFlexGrowValue }

    #[cfg(feature = "link_static")] pub use LayoutFlexGrowValueCrossCrateImpl as LayoutFlexGrowValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexGrowValueCrossCrateImpl { type Target = AzLayoutFlexGrowValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexGrowValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexShrinkValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexShrinkValue as LayoutFlexShrinkValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexShrinkValueCrossCrateImpl { pub _0: azul::AzLayoutFlexShrinkValue }

    #[cfg(feature = "link_static")] pub use LayoutFlexShrinkValueCrossCrateImpl as LayoutFlexShrinkValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexShrinkValueCrossCrateImpl { type Target = AzLayoutFlexShrinkValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexShrinkValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFloatValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFloatValue as LayoutFloatValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFloatValueCrossCrateImpl { pub _0: azul::AzLayoutFloatValue }

    #[cfg(feature = "link_static")] pub use LayoutFloatValueCrossCrateImpl as LayoutFloatValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFloatValueCrossCrateImpl { type Target = AzLayoutFloatValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFloatValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutHeightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutHeightValue as LayoutHeightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutHeightValueCrossCrateImpl { pub _0: azul::AzLayoutHeightValue }

    #[cfg(feature = "link_static")] pub use LayoutHeightValueCrossCrateImpl as LayoutHeightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutHeightValueCrossCrateImpl { type Target = AzLayoutHeightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutHeightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutJustifyContentValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutJustifyContentValue as LayoutJustifyContentValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutJustifyContentValueCrossCrateImpl { pub _0: azul::AzLayoutJustifyContentValue }

    #[cfg(feature = "link_static")] pub use LayoutJustifyContentValueCrossCrateImpl as LayoutJustifyContentValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutJustifyContentValueCrossCrateImpl { type Target = AzLayoutJustifyContentValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutJustifyContentValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutLeftValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutLeftValue as LayoutLeftValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutLeftValueCrossCrateImpl { pub _0: azul::AzLayoutLeftValue }

    #[cfg(feature = "link_static")] pub use LayoutLeftValueCrossCrateImpl as LayoutLeftValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutLeftValueCrossCrateImpl { type Target = AzLayoutLeftValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutLeftValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginBottomValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginBottomValue as LayoutMarginBottomValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginBottomValueCrossCrateImpl { pub _0: azul::AzLayoutMarginBottomValue }

    #[cfg(feature = "link_static")] pub use LayoutMarginBottomValueCrossCrateImpl as LayoutMarginBottomValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginBottomValueCrossCrateImpl { type Target = AzLayoutMarginBottomValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginBottomValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginLeftValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginLeftValue as LayoutMarginLeftValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginLeftValueCrossCrateImpl { pub _0: azul::AzLayoutMarginLeftValue }

    #[cfg(feature = "link_static")] pub use LayoutMarginLeftValueCrossCrateImpl as LayoutMarginLeftValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginLeftValueCrossCrateImpl { type Target = AzLayoutMarginLeftValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginLeftValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginRightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginRightValue as LayoutMarginRightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginRightValueCrossCrateImpl { pub _0: azul::AzLayoutMarginRightValue }

    #[cfg(feature = "link_static")] pub use LayoutMarginRightValueCrossCrateImpl as LayoutMarginRightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginRightValueCrossCrateImpl { type Target = AzLayoutMarginRightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginRightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMarginTopValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMarginTopValue as LayoutMarginTopValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMarginTopValueCrossCrateImpl { pub _0: azul::AzLayoutMarginTopValue }

    #[cfg(feature = "link_static")] pub use LayoutMarginTopValueCrossCrateImpl as LayoutMarginTopValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMarginTopValueCrossCrateImpl { type Target = AzLayoutMarginTopValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMarginTopValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMaxHeightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMaxHeightValue as LayoutMaxHeightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMaxHeightValueCrossCrateImpl { pub _0: azul::AzLayoutMaxHeightValue }

    #[cfg(feature = "link_static")] pub use LayoutMaxHeightValueCrossCrateImpl as LayoutMaxHeightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMaxHeightValueCrossCrateImpl { type Target = AzLayoutMaxHeightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMaxHeightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMaxWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMaxWidthValue as LayoutMaxWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMaxWidthValueCrossCrateImpl { pub _0: azul::AzLayoutMaxWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutMaxWidthValueCrossCrateImpl as LayoutMaxWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMaxWidthValueCrossCrateImpl { type Target = AzLayoutMaxWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMaxWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMinHeightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMinHeightValue as LayoutMinHeightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMinHeightValueCrossCrateImpl { pub _0: azul::AzLayoutMinHeightValue }

    #[cfg(feature = "link_static")] pub use LayoutMinHeightValueCrossCrateImpl as LayoutMinHeightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMinHeightValueCrossCrateImpl { type Target = AzLayoutMinHeightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMinHeightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutMinWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutMinWidthValue as LayoutMinWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutMinWidthValueCrossCrateImpl { pub _0: azul::AzLayoutMinWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutMinWidthValueCrossCrateImpl as LayoutMinWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutMinWidthValueCrossCrateImpl { type Target = AzLayoutMinWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutMinWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingBottomValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingBottomValue as LayoutPaddingBottomValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingBottomValueCrossCrateImpl { pub _0: azul::AzLayoutPaddingBottomValue }

    #[cfg(feature = "link_static")] pub use LayoutPaddingBottomValueCrossCrateImpl as LayoutPaddingBottomValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingBottomValueCrossCrateImpl { type Target = AzLayoutPaddingBottomValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingBottomValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingLeftValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingLeftValue as LayoutPaddingLeftValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingLeftValueCrossCrateImpl { pub _0: azul::AzLayoutPaddingLeftValue }

    #[cfg(feature = "link_static")] pub use LayoutPaddingLeftValueCrossCrateImpl as LayoutPaddingLeftValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingLeftValueCrossCrateImpl { type Target = AzLayoutPaddingLeftValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingLeftValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingRightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingRightValue as LayoutPaddingRightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingRightValueCrossCrateImpl { pub _0: azul::AzLayoutPaddingRightValue }

    #[cfg(feature = "link_static")] pub use LayoutPaddingRightValueCrossCrateImpl as LayoutPaddingRightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingRightValueCrossCrateImpl { type Target = AzLayoutPaddingRightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingRightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPaddingTopValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPaddingTopValue as LayoutPaddingTopValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPaddingTopValueCrossCrateImpl { pub _0: azul::AzLayoutPaddingTopValue }

    #[cfg(feature = "link_static")] pub use LayoutPaddingTopValueCrossCrateImpl as LayoutPaddingTopValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPaddingTopValueCrossCrateImpl { type Target = AzLayoutPaddingTopValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPaddingTopValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutPositionValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutPositionValue as LayoutPositionValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutPositionValueCrossCrateImpl { pub _0: azul::AzLayoutPositionValue }

    #[cfg(feature = "link_static")] pub use LayoutPositionValueCrossCrateImpl as LayoutPositionValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutPositionValueCrossCrateImpl { type Target = AzLayoutPositionValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutPositionValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutRightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutRightValue as LayoutRightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutRightValueCrossCrateImpl { pub _0: azul::AzLayoutRightValue }

    #[cfg(feature = "link_static")] pub use LayoutRightValueCrossCrateImpl as LayoutRightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutRightValueCrossCrateImpl { type Target = AzLayoutRightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutRightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutTopValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutTopValue as LayoutTopValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutTopValueCrossCrateImpl { pub _0: azul::AzLayoutTopValue }

    #[cfg(feature = "link_static")] pub use LayoutTopValueCrossCrateImpl as LayoutTopValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutTopValueCrossCrateImpl { type Target = AzLayoutTopValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutTopValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutWidthValue as LayoutWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutWidthValueCrossCrateImpl { pub _0: azul::AzLayoutWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutWidthValueCrossCrateImpl as LayoutWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutWidthValueCrossCrateImpl { type Target = AzLayoutWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutFlexWrapValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutFlexWrapValue as LayoutFlexWrapValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutFlexWrapValueCrossCrateImpl { pub _0: azul::AzLayoutFlexWrapValue }

    #[cfg(feature = "link_static")] pub use LayoutFlexWrapValueCrossCrateImpl as LayoutFlexWrapValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutFlexWrapValueCrossCrateImpl { type Target = AzLayoutFlexWrapValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutFlexWrapValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutOverflowValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutOverflowValue as LayoutOverflowValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutOverflowValueCrossCrateImpl { pub _0: azul::AzLayoutOverflowValue }

    #[cfg(feature = "link_static")] pub use LayoutOverflowValueCrossCrateImpl as LayoutOverflowValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutOverflowValueCrossCrateImpl { type Target = AzLayoutOverflowValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutOverflowValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ScrollbarStyleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScrollbarStyleValue as ScrollbarStyleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScrollbarStyleValueCrossCrateImpl { pub _0: azul::AzScrollbarStyleValue }

    #[cfg(feature = "link_static")] pub use ScrollbarStyleValueCrossCrateImpl as ScrollbarStyleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScrollbarStyleValueCrossCrateImpl { type Target = AzScrollbarStyleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScrollbarStyleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundContentVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundContentVecValue as StyleBackgroundContentVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundContentVecValueCrossCrateImpl { pub _0: azul::AzStyleBackgroundContentVecValue }

    #[cfg(feature = "link_static")] pub use StyleBackgroundContentVecValueCrossCrateImpl as StyleBackgroundContentVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundContentVecValueCrossCrateImpl { type Target = AzStyleBackgroundContentVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundContentVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundPositionVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundPositionVecValue as StyleBackgroundPositionVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundPositionVecValueCrossCrateImpl { pub _0: azul::AzStyleBackgroundPositionVecValue }

    #[cfg(feature = "link_static")] pub use StyleBackgroundPositionVecValueCrossCrateImpl as StyleBackgroundPositionVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundPositionVecValueCrossCrateImpl { type Target = AzStyleBackgroundPositionVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundPositionVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundRepeatVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundRepeatVecValue as StyleBackgroundRepeatVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundRepeatVecValueCrossCrateImpl { pub _0: azul::AzStyleBackgroundRepeatVecValue }

    #[cfg(feature = "link_static")] pub use StyleBackgroundRepeatVecValueCrossCrateImpl as StyleBackgroundRepeatVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundRepeatVecValueCrossCrateImpl { type Target = AzStyleBackgroundRepeatVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundRepeatVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundSizeVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundSizeVecValue as StyleBackgroundSizeVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundSizeVecValueCrossCrateImpl { pub _0: azul::AzStyleBackgroundSizeVecValue }

    #[cfg(feature = "link_static")] pub use StyleBackgroundSizeVecValueCrossCrateImpl as StyleBackgroundSizeVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundSizeVecValueCrossCrateImpl { type Target = AzStyleBackgroundSizeVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundSizeVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomColorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomColorValue as StyleBorderBottomColorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomColorValueCrossCrateImpl { pub _0: azul::AzStyleBorderBottomColorValue }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomColorValueCrossCrateImpl as StyleBorderBottomColorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomColorValueCrossCrateImpl { type Target = AzStyleBorderBottomColorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomColorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomLeftRadiusValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomLeftRadiusValue as StyleBorderBottomLeftRadiusValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomLeftRadiusValueCrossCrateImpl { pub _0: azul::AzStyleBorderBottomLeftRadiusValue }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomLeftRadiusValueCrossCrateImpl as StyleBorderBottomLeftRadiusValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomLeftRadiusValueCrossCrateImpl { type Target = AzStyleBorderBottomLeftRadiusValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomLeftRadiusValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomRightRadiusValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomRightRadiusValue as StyleBorderBottomRightRadiusValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomRightRadiusValueCrossCrateImpl { pub _0: azul::AzStyleBorderBottomRightRadiusValue }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomRightRadiusValueCrossCrateImpl as StyleBorderBottomRightRadiusValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomRightRadiusValueCrossCrateImpl { type Target = AzStyleBorderBottomRightRadiusValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomRightRadiusValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderBottomStyleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderBottomStyleValue as StyleBorderBottomStyleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderBottomStyleValueCrossCrateImpl { pub _0: azul::AzStyleBorderBottomStyleValue }

    #[cfg(feature = "link_static")] pub use StyleBorderBottomStyleValueCrossCrateImpl as StyleBorderBottomStyleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderBottomStyleValueCrossCrateImpl { type Target = AzStyleBorderBottomStyleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderBottomStyleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderBottomWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderBottomWidthValue as LayoutBorderBottomWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderBottomWidthValueCrossCrateImpl { pub _0: azul::AzLayoutBorderBottomWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutBorderBottomWidthValueCrossCrateImpl as LayoutBorderBottomWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderBottomWidthValueCrossCrateImpl { type Target = AzLayoutBorderBottomWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderBottomWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderLeftColorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderLeftColorValue as StyleBorderLeftColorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderLeftColorValueCrossCrateImpl { pub _0: azul::AzStyleBorderLeftColorValue }

    #[cfg(feature = "link_static")] pub use StyleBorderLeftColorValueCrossCrateImpl as StyleBorderLeftColorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderLeftColorValueCrossCrateImpl { type Target = AzStyleBorderLeftColorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderLeftColorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderLeftStyleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderLeftStyleValue as StyleBorderLeftStyleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderLeftStyleValueCrossCrateImpl { pub _0: azul::AzStyleBorderLeftStyleValue }

    #[cfg(feature = "link_static")] pub use StyleBorderLeftStyleValueCrossCrateImpl as StyleBorderLeftStyleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderLeftStyleValueCrossCrateImpl { type Target = AzStyleBorderLeftStyleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderLeftStyleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderLeftWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderLeftWidthValue as LayoutBorderLeftWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderLeftWidthValueCrossCrateImpl { pub _0: azul::AzLayoutBorderLeftWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutBorderLeftWidthValueCrossCrateImpl as LayoutBorderLeftWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderLeftWidthValueCrossCrateImpl { type Target = AzLayoutBorderLeftWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderLeftWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderRightColorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderRightColorValue as StyleBorderRightColorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderRightColorValueCrossCrateImpl { pub _0: azul::AzStyleBorderRightColorValue }

    #[cfg(feature = "link_static")] pub use StyleBorderRightColorValueCrossCrateImpl as StyleBorderRightColorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderRightColorValueCrossCrateImpl { type Target = AzStyleBorderRightColorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderRightColorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderRightStyleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderRightStyleValue as StyleBorderRightStyleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderRightStyleValueCrossCrateImpl { pub _0: azul::AzStyleBorderRightStyleValue }

    #[cfg(feature = "link_static")] pub use StyleBorderRightStyleValueCrossCrateImpl as StyleBorderRightStyleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderRightStyleValueCrossCrateImpl { type Target = AzStyleBorderRightStyleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderRightStyleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderRightWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderRightWidthValue as LayoutBorderRightWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderRightWidthValueCrossCrateImpl { pub _0: azul::AzLayoutBorderRightWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutBorderRightWidthValueCrossCrateImpl as LayoutBorderRightWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderRightWidthValueCrossCrateImpl { type Target = AzLayoutBorderRightWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderRightWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopColorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopColorValue as StyleBorderTopColorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopColorValueCrossCrateImpl { pub _0: azul::AzStyleBorderTopColorValue }

    #[cfg(feature = "link_static")] pub use StyleBorderTopColorValueCrossCrateImpl as StyleBorderTopColorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopColorValueCrossCrateImpl { type Target = AzStyleBorderTopColorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopColorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopLeftRadiusValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopLeftRadiusValue as StyleBorderTopLeftRadiusValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopLeftRadiusValueCrossCrateImpl { pub _0: azul::AzStyleBorderTopLeftRadiusValue }

    #[cfg(feature = "link_static")] pub use StyleBorderTopLeftRadiusValueCrossCrateImpl as StyleBorderTopLeftRadiusValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopLeftRadiusValueCrossCrateImpl { type Target = AzStyleBorderTopLeftRadiusValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopLeftRadiusValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopRightRadiusValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopRightRadiusValue as StyleBorderTopRightRadiusValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopRightRadiusValueCrossCrateImpl { pub _0: azul::AzStyleBorderTopRightRadiusValue }

    #[cfg(feature = "link_static")] pub use StyleBorderTopRightRadiusValueCrossCrateImpl as StyleBorderTopRightRadiusValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopRightRadiusValueCrossCrateImpl { type Target = AzStyleBorderTopRightRadiusValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopRightRadiusValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBorderTopStyleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBorderTopStyleValue as StyleBorderTopStyleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBorderTopStyleValueCrossCrateImpl { pub _0: azul::AzStyleBorderTopStyleValue }

    #[cfg(feature = "link_static")] pub use StyleBorderTopStyleValueCrossCrateImpl as StyleBorderTopStyleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBorderTopStyleValueCrossCrateImpl { type Target = AzStyleBorderTopStyleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBorderTopStyleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LayoutBorderTopWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLayoutBorderTopWidthValue as LayoutBorderTopWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LayoutBorderTopWidthValueCrossCrateImpl { pub _0: azul::AzLayoutBorderTopWidthValue }

    #[cfg(feature = "link_static")] pub use LayoutBorderTopWidthValueCrossCrateImpl as LayoutBorderTopWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LayoutBorderTopWidthValueCrossCrateImpl { type Target = AzLayoutBorderTopWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LayoutBorderTopWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleCursorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleCursorValue as StyleCursorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleCursorValueCrossCrateImpl { pub _0: azul::AzStyleCursorValue }

    #[cfg(feature = "link_static")] pub use StyleCursorValueCrossCrateImpl as StyleCursorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleCursorValueCrossCrateImpl { type Target = AzStyleCursorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleCursorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontFamilyVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontFamilyVecValue as StyleFontFamilyVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontFamilyVecValueCrossCrateImpl { pub _0: azul::AzStyleFontFamilyVecValue }

    #[cfg(feature = "link_static")] pub use StyleFontFamilyVecValueCrossCrateImpl as StyleFontFamilyVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontFamilyVecValueCrossCrateImpl { type Target = AzStyleFontFamilyVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontFamilyVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontSizeValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontSizeValue as StyleFontSizeValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontSizeValueCrossCrateImpl { pub _0: azul::AzStyleFontSizeValue }

    #[cfg(feature = "link_static")] pub use StyleFontSizeValueCrossCrateImpl as StyleFontSizeValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontSizeValueCrossCrateImpl { type Target = AzStyleFontSizeValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontSizeValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleLetterSpacingValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleLetterSpacingValue as StyleLetterSpacingValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleLetterSpacingValueCrossCrateImpl { pub _0: azul::AzStyleLetterSpacingValue }

    #[cfg(feature = "link_static")] pub use StyleLetterSpacingValueCrossCrateImpl as StyleLetterSpacingValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleLetterSpacingValueCrossCrateImpl { type Target = AzStyleLetterSpacingValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleLetterSpacingValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleLineHeightValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleLineHeightValue as StyleLineHeightValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleLineHeightValueCrossCrateImpl { pub _0: azul::AzStyleLineHeightValue }

    #[cfg(feature = "link_static")] pub use StyleLineHeightValueCrossCrateImpl as StyleLineHeightValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleLineHeightValueCrossCrateImpl { type Target = AzStyleLineHeightValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleLineHeightValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTabWidthValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTabWidthValue as StyleTabWidthValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTabWidthValueCrossCrateImpl { pub _0: azul::AzStyleTabWidthValue }

    #[cfg(feature = "link_static")] pub use StyleTabWidthValueCrossCrateImpl as StyleTabWidthValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTabWidthValueCrossCrateImpl { type Target = AzStyleTabWidthValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTabWidthValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTextAlignValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTextAlignValue as StyleTextAlignValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTextAlignValueCrossCrateImpl { pub _0: azul::AzStyleTextAlignValue }

    #[cfg(feature = "link_static")] pub use StyleTextAlignValueCrossCrateImpl as StyleTextAlignValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTextAlignValueCrossCrateImpl { type Target = AzStyleTextAlignValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTextAlignValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTextColorValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTextColorValue as StyleTextColorValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTextColorValueCrossCrateImpl { pub _0: azul::AzStyleTextColorValue }

    #[cfg(feature = "link_static")] pub use StyleTextColorValueCrossCrateImpl as StyleTextColorValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTextColorValueCrossCrateImpl { type Target = AzStyleTextColorValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTextColorValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleWordSpacingValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleWordSpacingValue as StyleWordSpacingValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleWordSpacingValueCrossCrateImpl { pub _0: azul::AzStyleWordSpacingValue }

    #[cfg(feature = "link_static")] pub use StyleWordSpacingValueCrossCrateImpl as StyleWordSpacingValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleWordSpacingValueCrossCrateImpl { type Target = AzStyleWordSpacingValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleWordSpacingValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleOpacityValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleOpacityValue as StyleOpacityValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleOpacityValueCrossCrateImpl { pub _0: azul::AzStyleOpacityValue }

    #[cfg(feature = "link_static")] pub use StyleOpacityValueCrossCrateImpl as StyleOpacityValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleOpacityValueCrossCrateImpl { type Target = AzStyleOpacityValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleOpacityValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformVecValue as StyleTransformVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformVecValueCrossCrateImpl { pub _0: azul::AzStyleTransformVecValue }

    #[cfg(feature = "link_static")] pub use StyleTransformVecValueCrossCrateImpl as StyleTransformVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformVecValueCrossCrateImpl { type Target = AzStyleTransformVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformOriginValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformOriginValue as StyleTransformOriginValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformOriginValueCrossCrateImpl { pub _0: azul::AzStyleTransformOriginValue }

    #[cfg(feature = "link_static")] pub use StyleTransformOriginValueCrossCrateImpl as StyleTransformOriginValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformOriginValueCrossCrateImpl { type Target = AzStyleTransformOriginValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformOriginValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StylePerspectiveOriginValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylePerspectiveOriginValue as StylePerspectiveOriginValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylePerspectiveOriginValueCrossCrateImpl { pub _0: azul::AzStylePerspectiveOriginValue }

    #[cfg(feature = "link_static")] pub use StylePerspectiveOriginValueCrossCrateImpl as StylePerspectiveOriginValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylePerspectiveOriginValueCrossCrateImpl { type Target = AzStylePerspectiveOriginValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylePerspectiveOriginValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackfaceVisibilityValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackfaceVisibilityValue as StyleBackfaceVisibilityValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackfaceVisibilityValueCrossCrateImpl { pub _0: azul::AzStyleBackfaceVisibilityValue }

    #[cfg(feature = "link_static")] pub use StyleBackfaceVisibilityValueCrossCrateImpl as StyleBackfaceVisibilityValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackfaceVisibilityValueCrossCrateImpl { type Target = AzStyleBackfaceVisibilityValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackfaceVisibilityValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleMixBlendModeValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleMixBlendModeValue as StyleMixBlendModeValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleMixBlendModeValueCrossCrateImpl { pub _0: azul::AzStyleMixBlendModeValue }

    #[cfg(feature = "link_static")] pub use StyleMixBlendModeValueCrossCrateImpl as StyleMixBlendModeValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleMixBlendModeValueCrossCrateImpl { type Target = AzStyleMixBlendModeValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleMixBlendModeValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFilterVecValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilterVecValue as StyleFilterVecValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterVecValueCrossCrateImpl { pub _0: azul::AzStyleFilterVecValue }

    #[cfg(feature = "link_static")] pub use StyleFilterVecValueCrossCrateImpl as StyleFilterVecValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterVecValueCrossCrateImpl { type Target = AzStyleFilterVecValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterVecValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Parsed CSS key-value pair
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssProperty as CssProperty;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyCrossCrateImpl { pub _0: azul::AzCssProperty }

    #[cfg(feature = "link_static")] pub use CssPropertyCrossCrateImpl as CssProperty;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyCrossCrateImpl { type Target = AzCssProperty; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl CssProperty {

        /// Returns the key of the CSS property as a string, i.e. `background`
        pub fn get_key_string(&self)  -> crate::str::String { unsafe { crate::dll::AzCssProperty_getKeyString(self) } }
        /// Returns the value of the CSS property as a string, i.e. `linear-gradient(red, blue)`
        pub fn get_value_string(&self)  -> crate::str::String { unsafe { crate::dll::AzCssProperty_getValueString(self) } }
        /// Returns the CSS key-value pair as a string, i.e. `background: linear-gradient(red, blue)`
        pub fn get_key_value_string(&self)  -> crate::str::String { unsafe { crate::dll::AzCssProperty_getKeyValueString(self) } }
        /// Interpolates two CSS properties given a value `t` ranging from 0.0 to 1.0. The interpolation function can be set on the `context` (`Ease`, `Linear`, etc.).
        pub fn interpolate(&self, other: CssProperty, t: f32, context: InterpolateContext)  -> crate::css::CssProperty { unsafe { crate::dll::AzCssProperty_interpolate(self, other, t, context) } }
    }

    #[cfg(feature = "link_static")]
    impl CssPropertyCrossCrateImpl {

        /// Returns the key of the CSS property as a string, i.e. `background`
        pub fn get_key_string(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzCssProperty_getKeyString(&self._0) }) } }
        /// Returns the value of the CSS property as a string, i.e. `linear-gradient(red, blue)`
        pub fn get_value_string(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzCssProperty_getValueString(&self._0) }) } }
        /// Returns the CSS key-value pair as a string, i.e. `background: linear-gradient(red, blue)`
        pub fn get_key_value_string(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzCssProperty_getKeyValueString(&self._0) }) } }
        /// Interpolates two CSS properties given a value `t` ranging from 0.0 to 1.0. The interpolation function can be set on the `context` (`Ease`, `Linear`, etc.).
        pub fn interpolate(&self, other: CssProperty, t: f32, context: InterpolateContext)  -> crate::css::CssProperty {  unsafe { core::mem::transmute(unsafe { azul::AzCssProperty_interpolate(&self._0, other._0, t, context._0) }) } }
    }

}

pub mod widgets {
    #![allow(dead_code, unused_imports)]
    //! Default, built-in widgets (button, label, textinput, etc.)
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::str::String;
    use crate::callbacks::{CallbackType, RefAny};
    use crate::option::OptionString;
    use crate::css::{ColorU, PixelValue};
    use crate::vec::{NodeDataInlineCssPropertyVec, StringVec, StyleBackgroundContentVec, TabVec};
    use crate::dom::Dom;
    /// `Button` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzButton as Button;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ButtonCrossCrateImpl { pub _0: azul::AzButton }

    #[cfg(feature = "link_static")] pub use ButtonCrossCrateImpl as Button;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ButtonCrossCrateImpl { type Target = AzButton; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ButtonCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Button {

        /// Creates a new labeled button
        pub fn new(label: String) -> Self { unsafe { crate::dll::AzButton_new(label) } }
        /// Calls the `Button::set_on_click` function.
        pub fn set_on_click(&mut self, data: RefAny, callback: CallbackType)  { unsafe { crate::dll::AzButton_setOnClick(self, data, callback) } }
        /// Calls the `Button::with_on_click` function.
        pub fn with_on_click(&mut self, data: RefAny, callback: CallbackType)  -> crate::widgets::Button { unsafe { crate::dll::AzButton_withOnClick(self, data, callback) } }
        /// Calls the `Button::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzButton_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ButtonCrossCrateImpl {

        /// Creates a new labeled button
        pub fn new(label: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzButton_new(label._0) }) } }
        /// Calls the `Button::set_on_click` function.
        pub fn set_on_click(&mut self, data: RefAny, callback: CallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzButton_setOnClick(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `Button::with_on_click` function.
        pub fn with_on_click(&mut self, data: RefAny, callback: CallbackType)  -> crate::widgets::Button {  unsafe { core::mem::transmute(unsafe { azul::AzButton_withOnClick(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `Button::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzButton_dom(&mut self._0) }) } }
    }

    /// `ButtonOnClick` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzButtonOnClick as ButtonOnClick;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ButtonOnClickCrossCrateImpl { pub _0: azul::AzButtonOnClick }

    #[cfg(feature = "link_static")] pub use ButtonOnClickCrossCrateImpl as ButtonOnClick;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ButtonOnClickCrossCrateImpl { type Target = AzButtonOnClick; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ButtonOnClickCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FileInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInput as FileInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputCrossCrateImpl { pub _0: azul::AzFileInput }

    #[cfg(feature = "link_static")] pub use FileInputCrossCrateImpl as FileInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputCrossCrateImpl { type Target = AzFileInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl FileInput {

        /// Creates a new file input button
        pub fn new(path: OptionString) -> Self { unsafe { crate::dll::AzFileInput_new(path) } }
        /// Calls the `FileInput::set_on_path_change` function.
        pub fn set_on_path_change(&mut self, data: RefAny, callback: FileInputOnPathChangeCallbackType)  { unsafe { crate::dll::AzFileInput_setOnPathChange(self, data, callback) } }
        /// Calls the `FileInput::with_on_path_change` function.
        pub fn with_on_path_change(&mut self, data: RefAny, callback: FileInputOnPathChangeCallbackType)  -> crate::widgets::FileInput { unsafe { crate::dll::AzFileInput_withOnPathChange(self, data, callback) } }
        /// Calls the `FileInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzFileInput_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl FileInputCrossCrateImpl {

        /// Creates a new file input button
        pub fn new(path: OptionString) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzFileInput_new(path._0) }) } }
        /// Calls the `FileInput::set_on_path_change` function.
        pub fn set_on_path_change(&mut self, data: RefAny, callback: FileInputOnPathChangeCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzFileInput_setOnPathChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `FileInput::with_on_path_change` function.
        pub fn with_on_path_change(&mut self, data: RefAny, callback: FileInputOnPathChangeCallbackType)  -> crate::widgets::FileInput {  unsafe { core::mem::transmute(unsafe { azul::AzFileInput_withOnPathChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `FileInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzFileInput_dom(&mut self._0) }) } }
    }

    /// `FileInputStateWrapper` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInputStateWrapper as FileInputStateWrapper;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputStateWrapperCrossCrateImpl { pub _0: azul::AzFileInputStateWrapper }

    #[cfg(feature = "link_static")] pub use FileInputStateWrapperCrossCrateImpl as FileInputStateWrapper;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputStateWrapperCrossCrateImpl { type Target = AzFileInputStateWrapper; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputStateWrapperCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FileInputState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInputState as FileInputState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputStateCrossCrateImpl { pub _0: azul::AzFileInputState }

    #[cfg(feature = "link_static")] pub use FileInputStateCrossCrateImpl as FileInputState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputStateCrossCrateImpl { type Target = AzFileInputState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FileInputOnPathChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInputOnPathChange as FileInputOnPathChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputOnPathChangeCrossCrateImpl { pub _0: azul::AzFileInputOnPathChange }

    #[cfg(feature = "link_static")] pub use FileInputOnPathChangeCrossCrateImpl as FileInputOnPathChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputOnPathChangeCrossCrateImpl { type Target = AzFileInputOnPathChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputOnPathChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FileInputOnPathChangeCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInputOnPathChangeCallback as FileInputOnPathChangeCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputOnPathChangeCallbackCrossCrateImpl { pub _0: azul::AzFileInputOnPathChangeCallback }

    #[cfg(feature = "link_static")] pub use FileInputOnPathChangeCallbackCrossCrateImpl as FileInputOnPathChangeCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputOnPathChangeCallbackCrossCrateImpl { type Target = AzFileInputOnPathChangeCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputOnPathChangeCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FileInputOnPathChangeCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileInputOnPathChangeCallbackType as FileInputOnPathChangeCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileInputOnPathChangeCallbackTypeCrossCrateImpl { pub _0: azul::AzFileInputOnPathChangeCallbackType }

    #[cfg(feature = "link_static")] pub use FileInputOnPathChangeCallbackTypeCrossCrateImpl as FileInputOnPathChangeCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileInputOnPathChangeCallbackTypeCrossCrateImpl { type Target = AzFileInputOnPathChangeCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileInputOnPathChangeCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CheckBox` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBox as CheckBox;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxCrossCrateImpl { pub _0: azul::AzCheckBox }

    #[cfg(feature = "link_static")] pub use CheckBoxCrossCrateImpl as CheckBox;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxCrossCrateImpl { type Target = AzCheckBox; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl CheckBox {

        /// Creates a new checkbox, disabled or enabled
        pub fn new(checked: bool) -> Self { unsafe { crate::dll::AzCheckBox_new(checked) } }
        /// Calls the `CheckBox::set_on_toggle` function.
        pub fn set_on_toggle(&mut self, data: RefAny, callback: CheckBoxOnToggleCallbackType)  { unsafe { crate::dll::AzCheckBox_setOnToggle(self, data, callback) } }
        /// Calls the `CheckBox::with_on_toggle` function.
        pub fn with_on_toggle(&mut self, data: RefAny, callback: CheckBoxOnToggleCallbackType)  -> crate::widgets::CheckBox { unsafe { crate::dll::AzCheckBox_withOnToggle(self, data, callback) } }
        /// Calls the `CheckBox::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzCheckBox_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl CheckBoxCrossCrateImpl {

        /// Creates a new checkbox, disabled or enabled
        pub fn new(checked: bool) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzCheckBox_new(checked) }) } }
        /// Calls the `CheckBox::set_on_toggle` function.
        pub fn set_on_toggle(&mut self, data: RefAny, callback: CheckBoxOnToggleCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzCheckBox_setOnToggle(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `CheckBox::with_on_toggle` function.
        pub fn with_on_toggle(&mut self, data: RefAny, callback: CheckBoxOnToggleCallbackType)  -> crate::widgets::CheckBox {  unsafe { core::mem::transmute(unsafe { azul::AzCheckBox_withOnToggle(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `CheckBox::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzCheckBox_dom(&mut self._0) }) } }
    }

    /// `CheckBoxStateWrapper` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBoxStateWrapper as CheckBoxStateWrapper;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxStateWrapperCrossCrateImpl { pub _0: azul::AzCheckBoxStateWrapper }

    #[cfg(feature = "link_static")] pub use CheckBoxStateWrapperCrossCrateImpl as CheckBoxStateWrapper;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxStateWrapperCrossCrateImpl { type Target = AzCheckBoxStateWrapper; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxStateWrapperCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CheckBoxOnToggle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBoxOnToggle as CheckBoxOnToggle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxOnToggleCrossCrateImpl { pub _0: azul::AzCheckBoxOnToggle }

    #[cfg(feature = "link_static")] pub use CheckBoxOnToggleCrossCrateImpl as CheckBoxOnToggle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxOnToggleCrossCrateImpl { type Target = AzCheckBoxOnToggle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxOnToggleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CheckBoxOnToggleCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBoxOnToggleCallback as CheckBoxOnToggleCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxOnToggleCallbackCrossCrateImpl { pub _0: azul::AzCheckBoxOnToggleCallback }

    #[cfg(feature = "link_static")] pub use CheckBoxOnToggleCallbackCrossCrateImpl as CheckBoxOnToggleCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxOnToggleCallbackCrossCrateImpl { type Target = AzCheckBoxOnToggleCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxOnToggleCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CheckBoxOnToggleCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBoxOnToggleCallbackType as CheckBoxOnToggleCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxOnToggleCallbackTypeCrossCrateImpl { pub _0: azul::AzCheckBoxOnToggleCallbackType }

    #[cfg(feature = "link_static")] pub use CheckBoxOnToggleCallbackTypeCrossCrateImpl as CheckBoxOnToggleCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxOnToggleCallbackTypeCrossCrateImpl { type Target = AzCheckBoxOnToggleCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxOnToggleCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CheckBoxState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckBoxState as CheckBoxState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckBoxStateCrossCrateImpl { pub _0: azul::AzCheckBoxState }

    #[cfg(feature = "link_static")] pub use CheckBoxStateCrossCrateImpl as CheckBoxState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckBoxStateCrossCrateImpl { type Target = AzCheckBoxState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckBoxStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Label` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLabel as Label;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LabelCrossCrateImpl { pub _0: azul::AzLabel }

    #[cfg(feature = "link_static")] pub use LabelCrossCrateImpl as Label;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LabelCrossCrateImpl { type Target = AzLabel; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LabelCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Label {

        /// Creates a new `Label` instance.
        pub fn new(text: String) -> Self { unsafe { crate::dll::AzLabel_new(text) } }
        /// Calls the `Label::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzLabel_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl LabelCrossCrateImpl {

        /// Creates a new `Label` instance.
        pub fn new(text: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzLabel_new(text._0) }) } }
        /// Calls the `Label::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzLabel_dom(&mut self._0) }) } }
    }

    /// `ColorInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInput as ColorInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputCrossCrateImpl { pub _0: azul::AzColorInput }

    #[cfg(feature = "link_static")] pub use ColorInputCrossCrateImpl as ColorInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputCrossCrateImpl { type Target = AzColorInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ColorInput {

        /// Creates a new `ColorInput` instance.
        pub fn new(color: ColorU) -> Self { unsafe { crate::dll::AzColorInput_new(color) } }
        /// Calls the `ColorInput::set_on_value_change` function.
        pub fn set_on_value_change(&mut self, data: RefAny, callback: ColorInputOnValueChangeCallbackType)  { unsafe { crate::dll::AzColorInput_setOnValueChange(self, data, callback) } }
        /// Calls the `ColorInput::with_on_value_change` function.
        pub fn with_on_value_change(&mut self, data: RefAny, callback: ColorInputOnValueChangeCallbackType)  -> crate::widgets::ColorInput { unsafe { crate::dll::AzColorInput_withOnValueChange(self, data, callback) } }
        /// Calls the `ColorInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzColorInput_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ColorInputCrossCrateImpl {

        /// Creates a new `ColorInput` instance.
        pub fn new(color: ColorU) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzColorInput_new(color._0) }) } }
        /// Calls the `ColorInput::set_on_value_change` function.
        pub fn set_on_value_change(&mut self, data: RefAny, callback: ColorInputOnValueChangeCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzColorInput_setOnValueChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `ColorInput::with_on_value_change` function.
        pub fn with_on_value_change(&mut self, data: RefAny, callback: ColorInputOnValueChangeCallbackType)  -> crate::widgets::ColorInput {  unsafe { core::mem::transmute(unsafe { azul::AzColorInput_withOnValueChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `ColorInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzColorInput_dom(&mut self._0) }) } }
    }

    /// `ColorInputStateWrapper` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInputStateWrapper as ColorInputStateWrapper;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputStateWrapperCrossCrateImpl { pub _0: azul::AzColorInputStateWrapper }

    #[cfg(feature = "link_static")] pub use ColorInputStateWrapperCrossCrateImpl as ColorInputStateWrapper;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputStateWrapperCrossCrateImpl { type Target = AzColorInputStateWrapper; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputStateWrapperCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorInputState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInputState as ColorInputState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputStateCrossCrateImpl { pub _0: azul::AzColorInputState }

    #[cfg(feature = "link_static")] pub use ColorInputStateCrossCrateImpl as ColorInputState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputStateCrossCrateImpl { type Target = AzColorInputState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorInputOnValueChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInputOnValueChange as ColorInputOnValueChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputOnValueChangeCrossCrateImpl { pub _0: azul::AzColorInputOnValueChange }

    #[cfg(feature = "link_static")] pub use ColorInputOnValueChangeCrossCrateImpl as ColorInputOnValueChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputOnValueChangeCrossCrateImpl { type Target = AzColorInputOnValueChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputOnValueChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorInputOnValueChangeCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInputOnValueChangeCallback as ColorInputOnValueChangeCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputOnValueChangeCallbackCrossCrateImpl { pub _0: azul::AzColorInputOnValueChangeCallback }

    #[cfg(feature = "link_static")] pub use ColorInputOnValueChangeCallbackCrossCrateImpl as ColorInputOnValueChangeCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputOnValueChangeCallbackCrossCrateImpl { type Target = AzColorInputOnValueChangeCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputOnValueChangeCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorInputOnValueChangeCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorInputOnValueChangeCallbackType as ColorInputOnValueChangeCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorInputOnValueChangeCallbackTypeCrossCrateImpl { pub _0: azul::AzColorInputOnValueChangeCallbackType }

    #[cfg(feature = "link_static")] pub use ColorInputOnValueChangeCallbackTypeCrossCrateImpl as ColorInputOnValueChangeCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorInputOnValueChangeCallbackTypeCrossCrateImpl { type Target = AzColorInputOnValueChangeCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorInputOnValueChangeCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInput as TextInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputCrossCrateImpl { pub _0: azul::AzTextInput }

    #[cfg(feature = "link_static")] pub use TextInputCrossCrateImpl as TextInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputCrossCrateImpl { type Target = AzTextInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TextInput {

        /// Creates a new `TextInput` instance.
        pub fn new(initial_text: String) -> Self { unsafe { crate::dll::AzTextInput_new(initial_text) } }
        /// Calls the `TextInput::set_on_text_input` function.
        pub fn set_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  { unsafe { crate::dll::AzTextInput_setOnTextInput(self, data, callback) } }
        /// Calls the `TextInput::with_on_text_input` function.
        pub fn with_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withOnTextInput(self, data, callback) } }
        /// Calls the `TextInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  { unsafe { crate::dll::AzTextInput_setOnVirtualKeyDown(self, data, callback) } }
        /// Calls the `TextInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withOnVirtualKeyDown(self, data, callback) } }
        /// Calls the `TextInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost(&mut self, data: RefAny, callback: TextInputOnFocusLostCallbackType)  { unsafe { crate::dll::AzTextInput_setOnFocusLost(self, data, callback) } }
        /// Calls the `TextInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost(&mut self, data: RefAny, callback: TextInputOnFocusLostCallbackType)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withOnFocusLost(self, data, callback) } }
        /// Calls the `TextInput::set_placeholder_style` function.
        pub fn set_placeholder_style(&mut self, placeholder_style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzTextInput_setPlaceholderStyle(self, placeholder_style) } }
        /// Calls the `TextInput::with_placeholder_style` function.
        pub fn with_placeholder_style(&mut self, placeholder_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withPlaceholderStyle(self, placeholder_style) } }
        /// Calls the `TextInput::set_container_style` function.
        pub fn set_container_style(&mut self, container_style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzTextInput_setContainerStyle(self, container_style) } }
        /// Calls the `TextInput::with_container_style` function.
        pub fn with_container_style(&mut self, container_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withContainerStyle(self, container_style) } }
        /// Calls the `TextInput::set_label_style` function.
        pub fn set_label_style(&mut self, label_style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzTextInput_setLabelStyle(self, label_style) } }
        /// Calls the `TextInput::with_label_style` function.
        pub fn with_label_style(&mut self, label_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput { unsafe { crate::dll::AzTextInput_withLabelStyle(self, label_style) } }
        /// Calls the `TextInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzTextInput_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TextInputCrossCrateImpl {

        /// Creates a new `TextInput` instance.
        pub fn new(initial_text: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTextInput_new(initial_text._0) }) } }
        /// Calls the `TextInput::set_on_text_input` function.
        pub fn set_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setOnTextInput(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::with_on_text_input` function.
        pub fn with_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withOnTextInput(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setOnVirtualKeyDown(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withOnVirtualKeyDown(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost(&mut self, data: RefAny, callback: TextInputOnFocusLostCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setOnFocusLost(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost(&mut self, data: RefAny, callback: TextInputOnFocusLostCallbackType)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withOnFocusLost(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `TextInput::set_placeholder_style` function.
        pub fn set_placeholder_style(&mut self, placeholder_style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setPlaceholderStyle(&mut self._0, placeholder_style._0) }) } }
        /// Calls the `TextInput::with_placeholder_style` function.
        pub fn with_placeholder_style(&mut self, placeholder_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withPlaceholderStyle(&mut self._0, placeholder_style._0) }) } }
        /// Calls the `TextInput::set_container_style` function.
        pub fn set_container_style(&mut self, container_style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setContainerStyle(&mut self._0, container_style._0) }) } }
        /// Calls the `TextInput::with_container_style` function.
        pub fn with_container_style(&mut self, container_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withContainerStyle(&mut self._0, container_style._0) }) } }
        /// Calls the `TextInput::set_label_style` function.
        pub fn set_label_style(&mut self, label_style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_setLabelStyle(&mut self._0, label_style._0) }) } }
        /// Calls the `TextInput::with_label_style` function.
        pub fn with_label_style(&mut self, label_style: NodeDataInlineCssPropertyVec)  -> crate::widgets::TextInput {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_withLabelStyle(&mut self._0, label_style._0) }) } }
        /// Calls the `TextInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzTextInput_dom(&mut self._0) }) } }
    }

    /// `TextInputStateWrapper` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputStateWrapper as TextInputStateWrapper;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputStateWrapperCrossCrateImpl { pub _0: azul::AzTextInputStateWrapper }

    #[cfg(feature = "link_static")] pub use TextInputStateWrapperCrossCrateImpl as TextInputStateWrapper;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputStateWrapperCrossCrateImpl { type Target = AzTextInputStateWrapper; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputStateWrapperCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputState as TextInputState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputStateCrossCrateImpl { pub _0: azul::AzTextInputState }

    #[cfg(feature = "link_static")] pub use TextInputStateCrossCrateImpl as TextInputState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputStateCrossCrateImpl { type Target = AzTextInputState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TextInputState {

        /// Calls the `TextInputState::get_text` function.
        pub fn get_text(&self)  -> crate::str::String { unsafe { crate::dll::AzTextInputState_getText(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TextInputStateCrossCrateImpl {

        /// Calls the `TextInputState::get_text` function.
        pub fn get_text(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzTextInputState_getText(&self._0) }) } }
    }

    /// `TextInputSelection` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputSelection as TextInputSelection;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputSelectionCrossCrateImpl { pub _0: azul::AzTextInputSelection }

    #[cfg(feature = "link_static")] pub use TextInputSelectionCrossCrateImpl as TextInputSelection;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputSelectionCrossCrateImpl { type Target = AzTextInputSelection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputSelectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputSelectionRange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputSelectionRange as TextInputSelectionRange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputSelectionRangeCrossCrateImpl { pub _0: azul::AzTextInputSelectionRange }

    #[cfg(feature = "link_static")] pub use TextInputSelectionRangeCrossCrateImpl as TextInputSelectionRange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputSelectionRangeCrossCrateImpl { type Target = AzTextInputSelectionRange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputSelectionRangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnTextInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnTextInput as TextInputOnTextInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnTextInputCrossCrateImpl { pub _0: azul::AzTextInputOnTextInput }

    #[cfg(feature = "link_static")] pub use TextInputOnTextInputCrossCrateImpl as TextInputOnTextInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnTextInputCrossCrateImpl { type Target = AzTextInputOnTextInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnTextInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnTextInputCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnTextInputCallback as TextInputOnTextInputCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnTextInputCallbackCrossCrateImpl { pub _0: azul::AzTextInputOnTextInputCallback }

    #[cfg(feature = "link_static")] pub use TextInputOnTextInputCallbackCrossCrateImpl as TextInputOnTextInputCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnTextInputCallbackCrossCrateImpl { type Target = AzTextInputOnTextInputCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnTextInputCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnTextInputCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnTextInputCallbackType as TextInputOnTextInputCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnTextInputCallbackTypeCrossCrateImpl { pub _0: azul::AzTextInputOnTextInputCallbackType }

    #[cfg(feature = "link_static")] pub use TextInputOnTextInputCallbackTypeCrossCrateImpl as TextInputOnTextInputCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnTextInputCallbackTypeCrossCrateImpl { type Target = AzTextInputOnTextInputCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnTextInputCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnVirtualKeyDown` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnVirtualKeyDown as TextInputOnVirtualKeyDown;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnVirtualKeyDownCrossCrateImpl { pub _0: azul::AzTextInputOnVirtualKeyDown }

    #[cfg(feature = "link_static")] pub use TextInputOnVirtualKeyDownCrossCrateImpl as TextInputOnVirtualKeyDown;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnVirtualKeyDownCrossCrateImpl { type Target = AzTextInputOnVirtualKeyDown; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnVirtualKeyDownCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnVirtualKeyDownCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnVirtualKeyDownCallback as TextInputOnVirtualKeyDownCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnVirtualKeyDownCallbackCrossCrateImpl { pub _0: azul::AzTextInputOnVirtualKeyDownCallback }

    #[cfg(feature = "link_static")] pub use TextInputOnVirtualKeyDownCallbackCrossCrateImpl as TextInputOnVirtualKeyDownCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnVirtualKeyDownCallbackCrossCrateImpl { type Target = AzTextInputOnVirtualKeyDownCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnVirtualKeyDownCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnVirtualKeyDownCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnVirtualKeyDownCallbackType as TextInputOnVirtualKeyDownCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnVirtualKeyDownCallbackTypeCrossCrateImpl { pub _0: azul::AzTextInputOnVirtualKeyDownCallbackType }

    #[cfg(feature = "link_static")] pub use TextInputOnVirtualKeyDownCallbackTypeCrossCrateImpl as TextInputOnVirtualKeyDownCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnVirtualKeyDownCallbackTypeCrossCrateImpl { type Target = AzTextInputOnVirtualKeyDownCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnVirtualKeyDownCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnFocusLost` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnFocusLost as TextInputOnFocusLost;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnFocusLostCrossCrateImpl { pub _0: azul::AzTextInputOnFocusLost }

    #[cfg(feature = "link_static")] pub use TextInputOnFocusLostCrossCrateImpl as TextInputOnFocusLost;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnFocusLostCrossCrateImpl { type Target = AzTextInputOnFocusLost; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnFocusLostCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnFocusLostCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnFocusLostCallback as TextInputOnFocusLostCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnFocusLostCallbackCrossCrateImpl { pub _0: azul::AzTextInputOnFocusLostCallback }

    #[cfg(feature = "link_static")] pub use TextInputOnFocusLostCallbackCrossCrateImpl as TextInputOnFocusLostCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnFocusLostCallbackCrossCrateImpl { type Target = AzTextInputOnFocusLostCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnFocusLostCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputOnFocusLostCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputOnFocusLostCallbackType as TextInputOnFocusLostCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputOnFocusLostCallbackTypeCrossCrateImpl { pub _0: azul::AzTextInputOnFocusLostCallbackType }

    #[cfg(feature = "link_static")] pub use TextInputOnFocusLostCallbackTypeCrossCrateImpl as TextInputOnFocusLostCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputOnFocusLostCallbackTypeCrossCrateImpl { type Target = AzTextInputOnFocusLostCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputOnFocusLostCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OnTextInputReturn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOnTextInputReturn as OnTextInputReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OnTextInputReturnCrossCrateImpl { pub _0: azul::AzOnTextInputReturn }

    #[cfg(feature = "link_static")] pub use OnTextInputReturnCrossCrateImpl as OnTextInputReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OnTextInputReturnCrossCrateImpl { type Target = AzOnTextInputReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OnTextInputReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextInputValid` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextInputValid as TextInputValid;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextInputValidCrossCrateImpl { pub _0: azul::AzTextInputValid }

    #[cfg(feature = "link_static")] pub use TextInputValidCrossCrateImpl as TextInputValid;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextInputValidCrossCrateImpl { type Target = AzTextInputValid; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextInputValidCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInput as NumberInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputCrossCrateImpl { pub _0: azul::AzNumberInput }

    #[cfg(feature = "link_static")] pub use NumberInputCrossCrateImpl as NumberInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputCrossCrateImpl { type Target = AzNumberInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl NumberInput {

        /// Creates a new `NumberInput` instance.
        pub fn new(number: f32) -> Self { unsafe { crate::dll::AzNumberInput_new(number) } }
        /// Calls the `NumberInput::set_on_text_input` function.
        pub fn set_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  { unsafe { crate::dll::AzNumberInput_setOnTextInput(self, data, callback) } }
        /// Calls the `NumberInput::with_on_text_input` function.
        pub fn with_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withOnTextInput(self, data, callback) } }
        /// Calls the `NumberInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  { unsafe { crate::dll::AzNumberInput_setOnVirtualKeyDown(self, data, callback) } }
        /// Calls the `NumberInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withOnVirtualKeyDown(self, data, callback) } }
        /// Calls the `NumberInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost(&mut self, data: RefAny, callback: NumberInputOnFocusLostCallbackType)  { unsafe { crate::dll::AzNumberInput_setOnFocusLost(self, data, callback) } }
        /// Calls the `NumberInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost(&mut self, data: RefAny, callback: NumberInputOnFocusLostCallbackType)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withOnFocusLost(self, data, callback) } }
        /// Calls the `NumberInput::set_placeholder_style` function.
        pub fn set_placeholder_style(&mut self, style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzNumberInput_setPlaceholderStyle(self, style) } }
        /// Calls the `NumberInput::with_placeholder_style` function.
        pub fn with_placeholder_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withPlaceholderStyle(self, style) } }
        /// Calls the `NumberInput::set_container_style` function.
        pub fn set_container_style(&mut self, style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzNumberInput_setContainerStyle(self, style) } }
        /// Calls the `NumberInput::with_container_style` function.
        pub fn with_container_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withContainerStyle(self, style) } }
        /// Calls the `NumberInput::set_label_style` function.
        pub fn set_label_style(&mut self, style: NodeDataInlineCssPropertyVec)  { unsafe { crate::dll::AzNumberInput_setLabelStyle(self, style) } }
        /// Calls the `NumberInput::with_label_style` function.
        pub fn with_label_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withLabelStyle(self, style) } }
        /// Calls the `NumberInput::set_on_value_change` function.
        pub fn set_on_value_change(&mut self, data: RefAny, callback: NumberInputOnValueChangeCallbackType)  { unsafe { crate::dll::AzNumberInput_setOnValueChange(self, data, callback) } }
        /// Calls the `NumberInput::with_on_value_change` function.
        pub fn with_on_value_change(&mut self, data: RefAny, callback: NumberInputOnValueChangeCallbackType)  -> crate::widgets::NumberInput { unsafe { crate::dll::AzNumberInput_withOnValueChange(self, data, callback) } }
        /// Calls the `NumberInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzNumberInput_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl NumberInputCrossCrateImpl {

        /// Creates a new `NumberInput` instance.
        pub fn new(number: f32) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_new(number) }) } }
        /// Calls the `NumberInput::set_on_text_input` function.
        pub fn set_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setOnTextInput(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::with_on_text_input` function.
        pub fn with_on_text_input(&mut self, data: RefAny, callback: TextInputOnTextInputCallbackType)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withOnTextInput(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::set_on_virtual_key_down` function.
        pub fn set_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setOnVirtualKeyDown(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::with_on_virtual_key_down` function.
        pub fn with_on_virtual_key_down(&mut self, data: RefAny, callback: TextInputOnVirtualKeyDownCallbackType)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withOnVirtualKeyDown(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::set_on_focus_lost` function.
        pub fn set_on_focus_lost(&mut self, data: RefAny, callback: NumberInputOnFocusLostCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setOnFocusLost(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::with_on_focus_lost` function.
        pub fn with_on_focus_lost(&mut self, data: RefAny, callback: NumberInputOnFocusLostCallbackType)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withOnFocusLost(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::set_placeholder_style` function.
        pub fn set_placeholder_style(&mut self, style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setPlaceholderStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::with_placeholder_style` function.
        pub fn with_placeholder_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withPlaceholderStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::set_container_style` function.
        pub fn set_container_style(&mut self, style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setContainerStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::with_container_style` function.
        pub fn with_container_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withContainerStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::set_label_style` function.
        pub fn set_label_style(&mut self, style: NodeDataInlineCssPropertyVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setLabelStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::with_label_style` function.
        pub fn with_label_style(&mut self, style: NodeDataInlineCssPropertyVec)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withLabelStyle(&mut self._0, style._0) }) } }
        /// Calls the `NumberInput::set_on_value_change` function.
        pub fn set_on_value_change(&mut self, data: RefAny, callback: NumberInputOnValueChangeCallbackType)  {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_setOnValueChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::with_on_value_change` function.
        pub fn with_on_value_change(&mut self, data: RefAny, callback: NumberInputOnValueChangeCallbackType)  -> crate::widgets::NumberInput {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_withOnValueChange(&mut self._0, data._0, callback._0) }) } }
        /// Calls the `NumberInput::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzNumberInput_dom(&mut self._0) }) } }
    }

    /// `NumberInputStateWrapper` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputStateWrapper as NumberInputStateWrapper;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputStateWrapperCrossCrateImpl { pub _0: azul::AzNumberInputStateWrapper }

    #[cfg(feature = "link_static")] pub use NumberInputStateWrapperCrossCrateImpl as NumberInputStateWrapper;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputStateWrapperCrossCrateImpl { type Target = AzNumberInputStateWrapper; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputStateWrapperCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputState as NumberInputState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputStateCrossCrateImpl { pub _0: azul::AzNumberInputState }

    #[cfg(feature = "link_static")] pub use NumberInputStateCrossCrateImpl as NumberInputState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputStateCrossCrateImpl { type Target = AzNumberInputState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnValueChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnValueChange as NumberInputOnValueChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnValueChangeCrossCrateImpl { pub _0: azul::AzNumberInputOnValueChange }

    #[cfg(feature = "link_static")] pub use NumberInputOnValueChangeCrossCrateImpl as NumberInputOnValueChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnValueChangeCrossCrateImpl { type Target = AzNumberInputOnValueChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnValueChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnValueChangeCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnValueChangeCallback as NumberInputOnValueChangeCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnValueChangeCallbackCrossCrateImpl { pub _0: azul::AzNumberInputOnValueChangeCallback }

    #[cfg(feature = "link_static")] pub use NumberInputOnValueChangeCallbackCrossCrateImpl as NumberInputOnValueChangeCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnValueChangeCallbackCrossCrateImpl { type Target = AzNumberInputOnValueChangeCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnValueChangeCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnValueChangeCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnValueChangeCallbackType as NumberInputOnValueChangeCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnValueChangeCallbackTypeCrossCrateImpl { pub _0: azul::AzNumberInputOnValueChangeCallbackType }

    #[cfg(feature = "link_static")] pub use NumberInputOnValueChangeCallbackTypeCrossCrateImpl as NumberInputOnValueChangeCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnValueChangeCallbackTypeCrossCrateImpl { type Target = AzNumberInputOnValueChangeCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnValueChangeCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnFocusLost` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnFocusLost as NumberInputOnFocusLost;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnFocusLostCrossCrateImpl { pub _0: azul::AzNumberInputOnFocusLost }

    #[cfg(feature = "link_static")] pub use NumberInputOnFocusLostCrossCrateImpl as NumberInputOnFocusLost;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnFocusLostCrossCrateImpl { type Target = AzNumberInputOnFocusLost; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnFocusLostCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnFocusLostCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnFocusLostCallback as NumberInputOnFocusLostCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnFocusLostCallbackCrossCrateImpl { pub _0: azul::AzNumberInputOnFocusLostCallback }

    #[cfg(feature = "link_static")] pub use NumberInputOnFocusLostCallbackCrossCrateImpl as NumberInputOnFocusLostCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnFocusLostCallbackCrossCrateImpl { type Target = AzNumberInputOnFocusLostCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnFocusLostCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NumberInputOnFocusLostCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNumberInputOnFocusLostCallbackType as NumberInputOnFocusLostCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NumberInputOnFocusLostCallbackTypeCrossCrateImpl { pub _0: azul::AzNumberInputOnFocusLostCallbackType }

    #[cfg(feature = "link_static")] pub use NumberInputOnFocusLostCallbackTypeCrossCrateImpl as NumberInputOnFocusLostCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NumberInputOnFocusLostCallbackTypeCrossCrateImpl { type Target = AzNumberInputOnFocusLostCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NumberInputOnFocusLostCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ProgressBar` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzProgressBar as ProgressBar;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ProgressBarCrossCrateImpl { pub _0: azul::AzProgressBar }

    #[cfg(feature = "link_static")] pub use ProgressBarCrossCrateImpl as ProgressBar;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ProgressBarCrossCrateImpl { type Target = AzProgressBar; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ProgressBarCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ProgressBar {

        /// Creates a new `ProgressBar` instance.
        pub fn new(percent_done: f32) -> Self { unsafe { crate::dll::AzProgressBar_new(percent_done) } }
        /// Calls the `ProgressBar::set_height` function.
        pub fn set_height(&mut self, height: PixelValue)  { unsafe { crate::dll::AzProgressBar_setHeight(self, height) } }
        /// Calls the `ProgressBar::with_height` function.
        pub fn with_height(&mut self, height: PixelValue)  -> crate::widgets::ProgressBar { unsafe { crate::dll::AzProgressBar_withHeight(self, height) } }
        /// Calls the `ProgressBar::set_container_background` function.
        pub fn set_container_background(&mut self, background: StyleBackgroundContentVec)  { unsafe { crate::dll::AzProgressBar_setContainerBackground(self, background) } }
        /// Calls the `ProgressBar::with_container_style` function.
        pub fn with_container_style(&mut self, background: StyleBackgroundContentVec)  -> crate::widgets::ProgressBar { unsafe { crate::dll::AzProgressBar_withContainerStyle(self, background) } }
        /// Calls the `ProgressBar::set_bar_background` function.
        pub fn set_bar_background(&mut self, background: StyleBackgroundContentVec)  { unsafe { crate::dll::AzProgressBar_setBarBackground(self, background) } }
        /// Calls the `ProgressBar::with_bar_background` function.
        pub fn with_bar_background(&mut self, background: StyleBackgroundContentVec)  -> crate::widgets::ProgressBar { unsafe { crate::dll::AzProgressBar_withBarBackground(self, background) } }
        /// Calls the `ProgressBar::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzProgressBar_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ProgressBarCrossCrateImpl {

        /// Creates a new `ProgressBar` instance.
        pub fn new(percent_done: f32) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_new(percent_done) }) } }
        /// Calls the `ProgressBar::set_height` function.
        pub fn set_height(&mut self, height: PixelValue)  {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_setHeight(&mut self._0, height._0) }) } }
        /// Calls the `ProgressBar::with_height` function.
        pub fn with_height(&mut self, height: PixelValue)  -> crate::widgets::ProgressBar {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_withHeight(&mut self._0, height._0) }) } }
        /// Calls the `ProgressBar::set_container_background` function.
        pub fn set_container_background(&mut self, background: StyleBackgroundContentVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_setContainerBackground(&mut self._0, background._0) }) } }
        /// Calls the `ProgressBar::with_container_style` function.
        pub fn with_container_style(&mut self, background: StyleBackgroundContentVec)  -> crate::widgets::ProgressBar {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_withContainerStyle(&mut self._0, background._0) }) } }
        /// Calls the `ProgressBar::set_bar_background` function.
        pub fn set_bar_background(&mut self, background: StyleBackgroundContentVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_setBarBackground(&mut self._0, background._0) }) } }
        /// Calls the `ProgressBar::with_bar_background` function.
        pub fn with_bar_background(&mut self, background: StyleBackgroundContentVec)  -> crate::widgets::ProgressBar {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_withBarBackground(&mut self._0, background._0) }) } }
        /// Calls the `ProgressBar::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzProgressBar_dom(&mut self._0) }) } }
    }

    /// `ProgressBarState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzProgressBarState as ProgressBarState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ProgressBarStateCrossCrateImpl { pub _0: azul::AzProgressBarState }

    #[cfg(feature = "link_static")] pub use ProgressBarStateCrossCrateImpl as ProgressBarState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ProgressBarStateCrossCrateImpl { type Target = AzProgressBarState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ProgressBarStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TabContainer` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTabContainer as TabContainer;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabContainerCrossCrateImpl { pub _0: azul::AzTabContainer }

    #[cfg(feature = "link_static")] pub use TabContainerCrossCrateImpl as TabContainer;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabContainerCrossCrateImpl { type Target = AzTabContainer; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabContainerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TabContainer {

        /// Creates a new `TabContainer` instance.
        pub fn new(tabs: TabVec) -> Self { unsafe { crate::dll::AzTabContainer_new(tabs) } }
        /// Calls the `TabContainer::set_active_tab` function.
        pub fn set_active_tab(&mut self, active_tab: usize)  { unsafe { crate::dll::AzTabContainer_setActiveTab(self, active_tab) } }
        /// Calls the `TabContainer::with_active_tab` function.
        pub fn with_active_tab(&mut self, active_tab: usize)  -> crate::widgets::TabContainer { unsafe { crate::dll::AzTabContainer_withActiveTab(self, active_tab) } }
        /// Calls the `TabContainer::set_padding` function.
        pub fn set_padding(&mut self, has_padding: bool)  { unsafe { crate::dll::AzTabContainer_setPadding(self, has_padding) } }
        /// Calls the `TabContainer::with_padding` function.
        pub fn with_padding(&mut self, has_padding: bool)  -> crate::widgets::TabContainer { unsafe { crate::dll::AzTabContainer_withPadding(self, has_padding) } }
        /// Calls the `TabContainer::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzTabContainer_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TabContainerCrossCrateImpl {

        /// Creates a new `TabContainer` instance.
        pub fn new(tabs: TabVec) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_new(tabs._0) }) } }
        /// Calls the `TabContainer::set_active_tab` function.
        pub fn set_active_tab(&mut self, active_tab: usize)  {  unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_setActiveTab(&mut self._0, active_tab) }) } }
        /// Calls the `TabContainer::with_active_tab` function.
        pub fn with_active_tab(&mut self, active_tab: usize)  -> crate::widgets::TabContainer {  unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_withActiveTab(&mut self._0, active_tab) }) } }
        /// Calls the `TabContainer::set_padding` function.
        pub fn set_padding(&mut self, has_padding: bool)  {  unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_setPadding(&mut self._0, has_padding) }) } }
        /// Calls the `TabContainer::with_padding` function.
        pub fn with_padding(&mut self, has_padding: bool)  -> crate::widgets::TabContainer {  unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_withPadding(&mut self._0, has_padding) }) } }
        /// Calls the `TabContainer::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzTabContainer_dom(&mut self._0) }) } }
    }

    /// `Tab` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTab as Tab;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabCrossCrateImpl { pub _0: azul::AzTab }

    #[cfg(feature = "link_static")] pub use TabCrossCrateImpl as Tab;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabCrossCrateImpl { type Target = AzTab; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Frame` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFrame as Frame;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FrameCrossCrateImpl { pub _0: azul::AzFrame }

    #[cfg(feature = "link_static")] pub use FrameCrossCrateImpl as Frame;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FrameCrossCrateImpl { type Target = AzFrame; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FrameCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Frame {

        /// Creates a new `Frame` instance.
        pub fn new(title: String, dom: Dom) -> Self { unsafe { crate::dll::AzFrame_new(title, dom) } }
        /// Calls the `Frame::set_flex_grow` function.
        pub fn set_flex_grow(&mut self, flex_grow: f32)  { unsafe { crate::dll::AzFrame_setFlexGrow(self, flex_grow) } }
        /// Calls the `Frame::with_flex_grow` function.
        pub fn with_flex_grow(&mut self, flex_grow: f32)  -> crate::widgets::Frame { unsafe { crate::dll::AzFrame_withFlexGrow(self, flex_grow) } }
        /// Calls the `Frame::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzFrame_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl FrameCrossCrateImpl {

        /// Creates a new `Frame` instance.
        pub fn new(title: String, dom: Dom) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzFrame_new(title._0, dom._0) }) } }
        /// Calls the `Frame::set_flex_grow` function.
        pub fn set_flex_grow(&mut self, flex_grow: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzFrame_setFlexGrow(&mut self._0, flex_grow) }) } }
        /// Calls the `Frame::with_flex_grow` function.
        pub fn with_flex_grow(&mut self, flex_grow: f32)  -> crate::widgets::Frame {  unsafe { core::mem::transmute(unsafe { azul::AzFrame_withFlexGrow(&mut self._0, flex_grow) }) } }
        /// Calls the `Frame::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzFrame_dom(&mut self._0) }) } }
    }

    /// `NodeGraph` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraph as NodeGraph;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphCrossCrateImpl { pub _0: azul::AzNodeGraph }

    #[cfg(feature = "link_static")] pub use NodeGraphCrossCrateImpl as NodeGraph;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphCrossCrateImpl { type Target = AzNodeGraph; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl NodeGraph {

        /// Calls the `NodeGraph::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzNodeGraph_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl NodeGraphCrossCrateImpl {

        /// Calls the `NodeGraph::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzNodeGraph_dom(&mut self._0) }) } }
    }

    /// `NodeTypeIdInfoMap` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeIdInfoMap as NodeTypeIdInfoMap;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeIdInfoMapCrossCrateImpl { pub _0: azul::AzNodeTypeIdInfoMap }

    #[cfg(feature = "link_static")] pub use NodeTypeIdInfoMapCrossCrateImpl as NodeTypeIdInfoMap;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeIdInfoMapCrossCrateImpl { type Target = AzNodeTypeIdInfoMap; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeIdInfoMapCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeIdInfoMap` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdInfoMap as InputOutputTypeIdInfoMap;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdInfoMapCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdInfoMap }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdInfoMapCrossCrateImpl as InputOutputTypeIdInfoMap;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdInfoMapCrossCrateImpl { type Target = AzInputOutputTypeIdInfoMap; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdInfoMapCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeIdNodeMap` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdNodeMap as NodeIdNodeMap;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdNodeMapCrossCrateImpl { pub _0: azul::AzNodeIdNodeMap }

    #[cfg(feature = "link_static")] pub use NodeIdNodeMapCrossCrateImpl as NodeIdNodeMap;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdNodeMapCrossCrateImpl { type Target = AzNodeIdNodeMap; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdNodeMapCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphStyle as NodeGraphStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphStyleCrossCrateImpl { pub _0: azul::AzNodeGraphStyle }

    #[cfg(feature = "link_static")] pub use NodeGraphStyleCrossCrateImpl as NodeGraphStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphStyleCrossCrateImpl { type Target = AzNodeGraphStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphCallbacks` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphCallbacks as NodeGraphCallbacks;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphCallbacksCrossCrateImpl { pub _0: azul::AzNodeGraphCallbacks }

    #[cfg(feature = "link_static")] pub use NodeGraphCallbacksCrossCrateImpl as NodeGraphCallbacks;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphCallbacksCrossCrateImpl { type Target = AzNodeGraphCallbacks; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphCallbacksCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeAddedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeAddedCallbackType as NodeGraphOnNodeAddedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeAddedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeAddedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeAddedCallbackTypeCrossCrateImpl as NodeGraphOnNodeAddedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeAddedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeAddedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeAddedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeAddedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeAddedCallback as NodeGraphOnNodeAddedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeAddedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeAddedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeAddedCallbackCrossCrateImpl as NodeGraphOnNodeAddedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeAddedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeAddedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeAddedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeAdded` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeAdded as NodeGraphOnNodeAdded;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeAddedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeAdded }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeAddedCrossCrateImpl as NodeGraphOnNodeAdded;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeAddedCrossCrateImpl { type Target = AzNodeGraphOnNodeAdded; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeAddedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeRemovedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeRemovedCallbackType as NodeGraphOnNodeRemovedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeRemovedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeRemovedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeRemovedCallbackTypeCrossCrateImpl as NodeGraphOnNodeRemovedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeRemovedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeRemovedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeRemovedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeRemovedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeRemovedCallback as NodeGraphOnNodeRemovedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeRemovedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeRemovedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeRemovedCallbackCrossCrateImpl as NodeGraphOnNodeRemovedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeRemovedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeRemovedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeRemovedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeRemoved` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeRemoved as NodeGraphOnNodeRemoved;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeRemovedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeRemoved }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeRemovedCrossCrateImpl as NodeGraphOnNodeRemoved;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeRemovedCrossCrateImpl { type Target = AzNodeGraphOnNodeRemoved; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeRemovedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeGraphDraggedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeGraphDraggedCallbackType as NodeGraphOnNodeGraphDraggedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeGraphDraggedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeGraphDraggedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeGraphDraggedCallbackTypeCrossCrateImpl as NodeGraphOnNodeGraphDraggedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeGraphDraggedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeGraphDraggedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeGraphDraggedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeGraphDraggedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeGraphDraggedCallback as NodeGraphOnNodeGraphDraggedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeGraphDraggedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeGraphDraggedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeGraphDraggedCallbackCrossCrateImpl as NodeGraphOnNodeGraphDraggedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeGraphDraggedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeGraphDraggedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeGraphDraggedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeGraphDragged` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeGraphDragged as NodeGraphOnNodeGraphDragged;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeGraphDraggedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeGraphDragged }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeGraphDraggedCrossCrateImpl as NodeGraphOnNodeGraphDragged;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeGraphDraggedCrossCrateImpl { type Target = AzNodeGraphOnNodeGraphDragged; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeGraphDraggedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeDraggedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeDraggedCallbackType as NodeGraphOnNodeDraggedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeDraggedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeDraggedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeDraggedCallbackTypeCrossCrateImpl as NodeGraphOnNodeDraggedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeDraggedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeDraggedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeDraggedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeDraggedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeDraggedCallback as NodeGraphOnNodeDraggedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeDraggedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeDraggedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeDraggedCallbackCrossCrateImpl as NodeGraphOnNodeDraggedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeDraggedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeDraggedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeDraggedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeDragged` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeDragged as NodeGraphOnNodeDragged;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeDraggedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeDragged }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeDraggedCrossCrateImpl as NodeGraphOnNodeDragged;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeDraggedCrossCrateImpl { type Target = AzNodeGraphOnNodeDragged; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeDraggedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeConnectedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeConnectedCallbackType as NodeGraphOnNodeConnectedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeConnectedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeConnectedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeConnectedCallbackTypeCrossCrateImpl as NodeGraphOnNodeConnectedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeConnectedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeConnectedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeConnectedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeConnectedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeConnectedCallback as NodeGraphOnNodeConnectedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeConnectedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeConnectedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeConnectedCallbackCrossCrateImpl as NodeGraphOnNodeConnectedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeConnectedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeConnectedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeConnectedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeConnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeConnected as NodeGraphOnNodeConnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeConnectedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeConnected }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeConnectedCrossCrateImpl as NodeGraphOnNodeConnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeConnectedCrossCrateImpl { type Target = AzNodeGraphOnNodeConnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeConnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeInputDisconnectedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeInputDisconnectedCallbackType as NodeGraphOnNodeInputDisconnectedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeInputDisconnectedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeInputDisconnectedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeInputDisconnectedCallbackTypeCrossCrateImpl as NodeGraphOnNodeInputDisconnectedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeInputDisconnectedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeInputDisconnectedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeInputDisconnectedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeInputDisconnectedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeInputDisconnectedCallback as NodeGraphOnNodeInputDisconnectedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeInputDisconnectedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeInputDisconnectedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeInputDisconnectedCallbackCrossCrateImpl as NodeGraphOnNodeInputDisconnectedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeInputDisconnectedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeInputDisconnectedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeInputDisconnectedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeInputDisconnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeInputDisconnected as NodeGraphOnNodeInputDisconnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeInputDisconnectedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeInputDisconnected }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeInputDisconnectedCrossCrateImpl as NodeGraphOnNodeInputDisconnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeInputDisconnectedCrossCrateImpl { type Target = AzNodeGraphOnNodeInputDisconnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeInputDisconnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeOutputDisconnectedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeOutputDisconnectedCallbackType as NodeGraphOnNodeOutputDisconnectedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeOutputDisconnectedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeOutputDisconnectedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeOutputDisconnectedCallbackTypeCrossCrateImpl as NodeGraphOnNodeOutputDisconnectedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeOutputDisconnectedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeOutputDisconnectedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeOutputDisconnectedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeOutputDisconnectedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeOutputDisconnectedCallback as NodeGraphOnNodeOutputDisconnectedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeOutputDisconnectedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeOutputDisconnectedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeOutputDisconnectedCallbackCrossCrateImpl as NodeGraphOnNodeOutputDisconnectedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeOutputDisconnectedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeOutputDisconnectedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeOutputDisconnectedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeOutputDisconnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeOutputDisconnected as NodeGraphOnNodeOutputDisconnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeOutputDisconnectedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeOutputDisconnected }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeOutputDisconnectedCrossCrateImpl as NodeGraphOnNodeOutputDisconnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeOutputDisconnectedCrossCrateImpl { type Target = AzNodeGraphOnNodeOutputDisconnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeOutputDisconnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeFieldEditedCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeFieldEditedCallbackType as NodeGraphOnNodeFieldEditedCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeFieldEditedCallbackTypeCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeFieldEditedCallbackType }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeFieldEditedCallbackTypeCrossCrateImpl as NodeGraphOnNodeFieldEditedCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeFieldEditedCallbackTypeCrossCrateImpl { type Target = AzNodeGraphOnNodeFieldEditedCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeFieldEditedCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeFieldEditedCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeFieldEditedCallback as NodeGraphOnNodeFieldEditedCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeFieldEditedCallbackCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeFieldEditedCallback }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeFieldEditedCallbackCrossCrateImpl as NodeGraphOnNodeFieldEditedCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeFieldEditedCallbackCrossCrateImpl { type Target = AzNodeGraphOnNodeFieldEditedCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeFieldEditedCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphOnNodeFieldEdited` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphOnNodeFieldEdited as NodeGraphOnNodeFieldEdited;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphOnNodeFieldEditedCrossCrateImpl { pub _0: azul::AzNodeGraphOnNodeFieldEdited }

    #[cfg(feature = "link_static")] pub use NodeGraphOnNodeFieldEditedCrossCrateImpl as NodeGraphOnNodeFieldEdited;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphOnNodeFieldEditedCrossCrateImpl { type Target = AzNodeGraphOnNodeFieldEdited; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphOnNodeFieldEditedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeId as InputOutputTypeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdCrossCrateImpl { pub _0: azul::AzInputOutputTypeId }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdCrossCrateImpl as InputOutputTypeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdCrossCrateImpl { type Target = AzInputOutputTypeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeId as NodeTypeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeIdCrossCrateImpl { pub _0: azul::AzNodeTypeId }

    #[cfg(feature = "link_static")] pub use NodeTypeIdCrossCrateImpl as NodeTypeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeIdCrossCrateImpl { type Target = AzNodeTypeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeGraphNodeId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeGraphNodeId as NodeGraphNodeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeGraphNodeIdCrossCrateImpl { pub _0: azul::AzNodeGraphNodeId }

    #[cfg(feature = "link_static")] pub use NodeGraphNodeIdCrossCrateImpl as NodeGraphNodeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeGraphNodeIdCrossCrateImpl { type Target = AzNodeGraphNodeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeGraphNodeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Node` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNode as Node;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeCrossCrateImpl { pub _0: azul::AzNode }

    #[cfg(feature = "link_static")] pub use NodeCrossCrateImpl as Node;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeCrossCrateImpl { type Target = AzNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeField` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeField as NodeTypeField;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeFieldCrossCrateImpl { pub _0: azul::AzNodeTypeField }

    #[cfg(feature = "link_static")] pub use NodeTypeFieldCrossCrateImpl as NodeTypeField;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeFieldCrossCrateImpl { type Target = AzNodeTypeField; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeFieldCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeFieldValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeFieldValue as NodeTypeFieldValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeFieldValueCrossCrateImpl { pub _0: azul::AzNodeTypeFieldValue }

    #[cfg(feature = "link_static")] pub use NodeTypeFieldValueCrossCrateImpl as NodeTypeFieldValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeFieldValueCrossCrateImpl { type Target = AzNodeTypeFieldValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeFieldValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputConnection` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputConnection as InputConnection;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputConnectionCrossCrateImpl { pub _0: azul::AzInputConnection }

    #[cfg(feature = "link_static")] pub use InputConnectionCrossCrateImpl as InputConnection;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputConnectionCrossCrateImpl { type Target = AzInputConnection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputConnectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputNodeAndIndex` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputNodeAndIndex as OutputNodeAndIndex;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputNodeAndIndexCrossCrateImpl { pub _0: azul::AzOutputNodeAndIndex }

    #[cfg(feature = "link_static")] pub use OutputNodeAndIndexCrossCrateImpl as OutputNodeAndIndex;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputNodeAndIndexCrossCrateImpl { type Target = AzOutputNodeAndIndex; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputNodeAndIndexCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputConnection` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputConnection as OutputConnection;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputConnectionCrossCrateImpl { pub _0: azul::AzOutputConnection }

    #[cfg(feature = "link_static")] pub use OutputConnectionCrossCrateImpl as OutputConnection;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputConnectionCrossCrateImpl { type Target = AzOutputConnection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputConnectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputNodeAndIndex` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputNodeAndIndex as InputNodeAndIndex;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputNodeAndIndexCrossCrateImpl { pub _0: azul::AzInputNodeAndIndex }

    #[cfg(feature = "link_static")] pub use InputNodeAndIndexCrossCrateImpl as InputNodeAndIndex;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputNodeAndIndexCrossCrateImpl { type Target = AzInputNodeAndIndex; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputNodeAndIndexCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeInfo as NodeTypeInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeInfoCrossCrateImpl { pub _0: azul::AzNodeTypeInfo }

    #[cfg(feature = "link_static")] pub use NodeTypeInfoCrossCrateImpl as NodeTypeInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeInfoCrossCrateImpl { type Target = AzNodeTypeInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputInfo as InputOutputInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputInfoCrossCrateImpl { pub _0: azul::AzInputOutputInfo }

    #[cfg(feature = "link_static")] pub use InputOutputInfoCrossCrateImpl as InputOutputInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputInfoCrossCrateImpl { type Target = AzInputOutputInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodePosition` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodePosition as NodePosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodePositionCrossCrateImpl { pub _0: azul::AzNodePosition }

    #[cfg(feature = "link_static")] pub use NodePositionCrossCrateImpl as NodePosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodePositionCrossCrateImpl { type Target = AzNodePosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodePositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GraphDragAmount` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGraphDragAmount as GraphDragAmount;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GraphDragAmountCrossCrateImpl { pub _0: azul::AzGraphDragAmount }

    #[cfg(feature = "link_static")] pub use GraphDragAmountCrossCrateImpl as GraphDragAmount;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GraphDragAmountCrossCrateImpl { type Target = AzGraphDragAmount; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GraphDragAmountCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDragAmount` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDragAmount as NodeDragAmount;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDragAmountCrossCrateImpl { pub _0: azul::AzNodeDragAmount }

    #[cfg(feature = "link_static")] pub use NodeDragAmountCrossCrateImpl as NodeDragAmount;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDragAmountCrossCrateImpl { type Target = AzNodeDragAmount; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDragAmountCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ListView` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzListView as ListView;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ListViewCrossCrateImpl { pub _0: azul::AzListView }

    #[cfg(feature = "link_static")] pub use ListViewCrossCrateImpl as ListView;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ListViewCrossCrateImpl { type Target = AzListView; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ListViewCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ListView {

        /// Creates a new `ListView` instance.
        pub fn new(columns: StringVec) -> Self { unsafe { crate::dll::AzListView_new(columns) } }
        /// Calls the `ListView::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzListView_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ListViewCrossCrateImpl {

        /// Creates a new `ListView` instance.
        pub fn new(columns: StringVec) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzListView_new(columns._0) }) } }
        /// Calls the `ListView::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzListView_dom(&mut self._0) }) } }
    }

    /// `TreeView` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTreeView as TreeView;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TreeViewCrossCrateImpl { pub _0: azul::AzTreeView }

    #[cfg(feature = "link_static")] pub use TreeViewCrossCrateImpl as TreeView;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TreeViewCrossCrateImpl { type Target = AzTreeView; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TreeViewCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TreeView {

        /// Creates a new `TreeView` instance.
        pub fn new(root: String) -> Self { unsafe { crate::dll::AzTreeView_new(root) } }
        /// Calls the `TreeView::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzTreeView_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TreeViewCrossCrateImpl {

        /// Creates a new `TreeView` instance.
        pub fn new(root: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTreeView_new(root._0) }) } }
        /// Calls the `TreeView::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzTreeView_dom(&mut self._0) }) } }
    }

    /// `DropDown` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDropDown as DropDown;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DropDownCrossCrateImpl { pub _0: azul::AzDropDown }

    #[cfg(feature = "link_static")] pub use DropDownCrossCrateImpl as DropDown;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DropDownCrossCrateImpl { type Target = AzDropDown; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DropDownCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl DropDown {

        /// Creates a new `DropDown` instance.
        pub fn new(choices: StringVec) -> Self { unsafe { crate::dll::AzDropDown_new(choices) } }
        /// Calls the `DropDown::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom { unsafe { crate::dll::AzDropDown_dom(self) } }
    }

    #[cfg(feature = "link_static")]
    impl DropDownCrossCrateImpl {

        /// Creates a new `DropDown` instance.
        pub fn new(choices: StringVec) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzDropDown_new(choices._0) }) } }
        /// Calls the `DropDown::dom` function.
        pub fn dom(&mut self)  -> crate::dom::Dom {  unsafe { core::mem::transmute(unsafe { azul::AzDropDown_dom(&mut self._0) }) } }
    }

    /// `DropDownOnChoiceChangeCallbackType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDropDownOnChoiceChangeCallbackType as DropDownOnChoiceChangeCallbackType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DropDownOnChoiceChangeCallbackTypeCrossCrateImpl { pub _0: azul::AzDropDownOnChoiceChangeCallbackType }

    #[cfg(feature = "link_static")] pub use DropDownOnChoiceChangeCallbackTypeCrossCrateImpl as DropDownOnChoiceChangeCallbackType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DropDownOnChoiceChangeCallbackTypeCrossCrateImpl { type Target = AzDropDownOnChoiceChangeCallbackType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DropDownOnChoiceChangeCallbackTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DropDownOnChoiceChangeCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDropDownOnChoiceChangeCallback as DropDownOnChoiceChangeCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DropDownOnChoiceChangeCallbackCrossCrateImpl { pub _0: azul::AzDropDownOnChoiceChangeCallback }

    #[cfg(feature = "link_static")] pub use DropDownOnChoiceChangeCallbackCrossCrateImpl as DropDownOnChoiceChangeCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DropDownOnChoiceChangeCallbackCrossCrateImpl { type Target = AzDropDownOnChoiceChangeCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DropDownOnChoiceChangeCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DropDownOnChoiceChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDropDownOnChoiceChange as DropDownOnChoiceChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DropDownOnChoiceChangeCrossCrateImpl { pub _0: azul::AzDropDownOnChoiceChange }

    #[cfg(feature = "link_static")] pub use DropDownOnChoiceChangeCrossCrateImpl as DropDownOnChoiceChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DropDownOnChoiceChangeCrossCrateImpl { type Target = AzDropDownOnChoiceChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DropDownOnChoiceChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod style {
    #![allow(dead_code, unused_imports)]
    //! DOM to CSS cascading and styling module
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::dom::Dom;
    use crate::css::Css;
    use crate::str::String;
    use crate::menu::Menu;
    /// `NodeHierarchyItem` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeHierarchyItem as NodeHierarchyItem;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeHierarchyItemCrossCrateImpl { pub _0: azul::AzNodeHierarchyItem }

    #[cfg(feature = "link_static")] pub use NodeHierarchyItemCrossCrateImpl as NodeHierarchyItem;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeHierarchyItemCrossCrateImpl { type Target = AzNodeHierarchyItem; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeHierarchyItemCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CascadeInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCascadeInfo as CascadeInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CascadeInfoCrossCrateImpl { pub _0: azul::AzCascadeInfo }

    #[cfg(feature = "link_static")] pub use CascadeInfoCrossCrateImpl as CascadeInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CascadeInfoCrossCrateImpl { type Target = AzCascadeInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CascadeInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPropertySource` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertySource as CssPropertySource;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertySourceCrossCrateImpl { pub _0: azul::AzCssPropertySource }

    #[cfg(feature = "link_static")] pub use CssPropertySourceCrossCrateImpl as CssPropertySource;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertySourceCrossCrateImpl { type Target = AzCssPropertySource; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertySourceCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyledNodeState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledNodeState as StyledNodeState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledNodeStateCrossCrateImpl { pub _0: azul::AzStyledNodeState }

    #[cfg(feature = "link_static")] pub use StyledNodeStateCrossCrateImpl as StyledNodeState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledNodeStateCrossCrateImpl { type Target = AzStyledNodeState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledNodeStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyledNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledNode as StyledNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledNodeCrossCrateImpl { pub _0: azul::AzStyledNode }

    #[cfg(feature = "link_static")] pub use StyledNodeCrossCrateImpl as StyledNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledNodeCrossCrateImpl { type Target = AzStyledNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TagId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTagId as TagId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TagIdCrossCrateImpl { pub _0: azul::AzTagId }

    #[cfg(feature = "link_static")] pub use TagIdCrossCrateImpl as TagId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TagIdCrossCrateImpl { type Target = AzTagId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TagIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TagIdToNodeIdMapping` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTagIdToNodeIdMapping as TagIdToNodeIdMapping;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TagIdToNodeIdMappingCrossCrateImpl { pub _0: azul::AzTagIdToNodeIdMapping }

    #[cfg(feature = "link_static")] pub use TagIdToNodeIdMappingCrossCrateImpl as TagIdToNodeIdMapping;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TagIdToNodeIdMappingCrossCrateImpl { type Target = AzTagIdToNodeIdMapping; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TagIdToNodeIdMappingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ParentWithNodeDepth` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzParentWithNodeDepth as ParentWithNodeDepth;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ParentWithNodeDepthCrossCrateImpl { pub _0: azul::AzParentWithNodeDepth }

    #[cfg(feature = "link_static")] pub use ParentWithNodeDepthCrossCrateImpl as ParentWithNodeDepth;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ParentWithNodeDepthCrossCrateImpl { type Target = AzParentWithNodeDepth; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ParentWithNodeDepthCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPropertyCache` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertyCache as CssPropertyCache;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyCacheCrossCrateImpl { pub _0: azul::AzCssPropertyCache }

    #[cfg(feature = "link_static")] pub use CssPropertyCacheCrossCrateImpl as CssPropertyCache;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyCacheCrossCrateImpl { type Target = AzCssPropertyCache; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyCacheCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))] impl Clone for CssPropertyCache { fn clone(&self) -> Self { unsafe { crate::dll::AzCssPropertyCache_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for CssPropertyCache { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzCssPropertyCache_delete(self) } } } }
    /// `StyledDom` struct

    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledDom as StyledDom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledDomCrossCrateImpl { pub _0: azul::AzStyledDom }

    #[cfg(feature = "link_static")] pub use StyledDomCrossCrateImpl as StyledDom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledDomCrossCrateImpl { type Target = AzStyledDom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledDomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl StyledDom {

        /// Styles a `Dom` with the given `Css`, returning the `StyledDom` - complexity `O(count(dom_nodes) * count(css_blocks))`: make sure that the `Dom` and the `Css` are as small as possible, use inline CSS if the performance isn't good enough
        pub fn new(dom: Dom, css: Css) -> Self { unsafe { crate::dll::AzStyledDom_new(dom, css) } }
        /// Returns a default, empty `Dom`, usually returned if you don't want to crash in an error case.
        pub fn default() -> Self { unsafe { crate::dll::AzStyledDom_default() } }
        /// Returns a DOM loaded from an XML file
        pub fn from_xml(xml_string: String) -> Self { unsafe { crate::dll::AzStyledDom_fromXml(xml_string) } }
        /// Same as `from_xml`, but loads the file relative to the current directory
        pub fn from_file(xml_file_path: String) -> Self { unsafe { crate::dll::AzStyledDom_fromFile(xml_file_path) } }
        /// Appends an already styled list of DOM nodes to the current `dom.root` - complexity `O(count(dom.dom_nodes))`
        pub fn append_child(&mut self, dom: StyledDom)  { unsafe { crate::dll::AzStyledDom_appendChild(self, dom) } }
        /// Restyles an already styled DOM with a new CSS - overwrites old styles, but does not replace them, useful for implementing user styles that are applied on top of the existing application style
        pub fn restyle(&mut self, css: Css)  { unsafe { crate::dll::AzStyledDom_restyle(self, css) } }
        /// Returns the number of nodes in the styled DOM
        pub fn node_count(&self)  -> usize { unsafe { crate::dll::AzStyledDom_nodeCount(self) } }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
        pub fn get_html_string(&self)  -> crate::str::String { unsafe { crate::dll::AzStyledDom_getHtmlString(self) } }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&self)  -> crate::str::String { unsafe { crate::dll::AzStyledDom_getHtmlStringTest(self) } }
        /// Adds a menu to the root node
        pub fn set_menu_bar(&mut self, menu: Menu)  { unsafe { crate::dll::AzStyledDom_setMenuBar(self, menu) } }
        /// Adds a menu to the root node (builder method)
        pub fn with_menu_bar(&mut self, menu: Menu)  -> crate::style::StyledDom { unsafe { crate::dll::AzStyledDom_withMenuBar(self, menu) } }
        /// Adds a context menu to the root node
        pub fn set_context_menu(&mut self, menu: Menu)  { unsafe { crate::dll::AzStyledDom_setContextMenu(self, menu) } }
        /// Adds a context menu to the root node (builder method)
        pub fn with_context_menu(&mut self, menu: Menu)  -> crate::style::StyledDom { unsafe { crate::dll::AzStyledDom_withContextMenu(self, menu) } }
    }

    #[cfg(feature = "link_static")]
    impl StyledDomCrossCrateImpl {

        /// Styles a `Dom` with the given `Css`, returning the `StyledDom` - complexity `O(count(dom_nodes) * count(css_blocks))`: make sure that the `Dom` and the `Css` are as small as possible, use inline CSS if the performance isn't good enough
        pub fn new(dom: Dom, css: Css) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_new(dom._0, css._0) }) } }
        /// Returns a default, empty `Dom`, usually returned if you don't want to crash in an error case.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_default() }) } }
        /// Returns a DOM loaded from an XML file
        pub fn from_xml(xml_string: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_fromXml(xml_string._0) }) } }
        /// Same as `from_xml`, but loads the file relative to the current directory
        pub fn from_file(xml_file_path: String) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_fromFile(xml_file_path._0) }) } }
        /// Appends an already styled list of DOM nodes to the current `dom.root` - complexity `O(count(dom.dom_nodes))`
        pub fn append_child(&mut self, dom: StyledDom)  {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_appendChild(&mut self._0, dom._0) }) } }
        /// Restyles an already styled DOM with a new CSS - overwrites old styles, but does not replace them, useful for implementing user styles that are applied on top of the existing application style
        pub fn restyle(&mut self, css: Css)  {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_restyle(&mut self._0, css._0) }) } }
        /// Returns the number of nodes in the styled DOM
        pub fn node_count(&self)  -> usize {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_nodeCount(&self._0) }) } }
        /// Returns a HTML string that you can write to a file in order to debug the UI structure and debug potential cascading issues
        pub fn get_html_string(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_getHtmlString(&self._0) }) } }
        /// Returns a HTML for unit testing
        pub fn get_html_string_test(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_getHtmlStringTest(&self._0) }) } }
        /// Adds a menu to the root node
        pub fn set_menu_bar(&mut self, menu: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_setMenuBar(&mut self._0, menu._0) }) } }
        /// Adds a menu to the root node (builder method)
        pub fn with_menu_bar(&mut self, menu: Menu)  -> crate::style::StyledDom {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_withMenuBar(&mut self._0, menu._0) }) } }
        /// Adds a context menu to the root node
        pub fn set_context_menu(&mut self, menu: Menu)  {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_setContextMenu(&mut self._0, menu._0) }) } }
        /// Adds a context menu to the root node (builder method)
        pub fn with_context_menu(&mut self, menu: Menu)  -> crate::style::StyledDom {  unsafe { core::mem::transmute(unsafe { azul::AzStyledDom_withContextMenu(&mut self._0, menu._0) }) } }
    }

}

pub mod gl {
    #![allow(dead_code, unused_imports)]
    //! OpenGl helper types (`Texture`, `Gl`, etc.)
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    #[cfg(not(feature = "link_static"))]
    impl Refstr {
        fn as_str(&self) -> &str { unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(self.ptr, self.len)) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&str> for Refstr {
        fn from(s: &str) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl RefstrVecRef {
        fn as_slice(&self) -> &[Refstr] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[Refstr]> for RefstrVecRef {
        fn from(s: &[Refstr]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&mut [GLint64]> for GLint64VecRefMut {
        fn from(s: &mut [GLint64]) -> Self {
            Self { ptr: s.as_mut_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLint64VecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLint64] { unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&mut [GLfloat]> for GLfloatVecRefMut {
        fn from(s: &mut [GLfloat]) -> Self {
            Self { ptr: s.as_mut_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLfloatVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLfloat] { unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&mut [GLint]> for GLintVecRefMut {
        fn from(s: &mut [GLint]) -> Self {
            Self { ptr: s.as_mut_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLintVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLint] { unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[GLuint]> for GLuintVecRef {
        fn from(s: &[GLuint]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLuintVecRef {
        fn as_slice(&self) -> &[GLuint] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[GLenum]> for GLenumVecRef {
        fn from(s: &[GLenum]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLenumVecRef {
        fn as_slice(&self) -> &[GLenum] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[u8]> for U8VecRef {
        fn from(s: &[u8]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl U8VecRef {
        fn as_slice(&self) -> &[u8] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl ::core::fmt::Debug for U8VecRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            self.as_slice().fmt(f)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Clone for U8VecRef {
        fn clone(&self) -> Self {
            U8VecRef::from(self.as_slice())
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl PartialOrd for U8VecRef {
        fn partial_cmp(&self, rhs: &Self) -> Option<core::cmp::Ordering> {
            self.as_slice().partial_cmp(rhs.as_slice())
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Ord for U8VecRef {
        fn cmp(&self, rhs: &Self) -> core::cmp::Ordering {
            self.as_slice().cmp(rhs.as_slice())
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl PartialEq for U8VecRef {
        fn eq(&self, rhs: &Self) -> bool {
            self.as_slice().eq(rhs.as_slice())
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl Eq for U8VecRef { }

    #[cfg(not(feature = "link_static"))]
    impl core::hash::Hash for U8VecRef {
        fn hash<H>(&self, state: &mut H) where H: core::hash::Hasher {
            self.as_slice().hash(state)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[f32]> for F32VecRef {
        fn from(s: &[f32]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl F32VecRef {
        fn as_slice(&self) -> &[f32] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&[i32]> for I32VecRef {
        fn from(s: &[i32]) -> Self {
            Self { ptr: s.as_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl I32VecRef {
        fn as_slice(&self) -> &[i32] { unsafe { core::slice::from_raw_parts(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&mut [GLboolean]> for GLbooleanVecRefMut {
        fn from(s: &mut [GLboolean]) -> Self {
            Self { ptr: s.as_mut_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl GLbooleanVecRefMut {
        fn as_mut_slice(&mut self) -> &mut [GLboolean] { unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) } }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<&mut [u8]> for U8VecRefMut {
        fn from(s: &mut [u8]) -> Self {
            Self { ptr: s.as_mut_ptr(), len: s.len() }
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl U8VecRefMut {
        fn as_mut_slice(&mut self) -> &mut [u8] { unsafe { core::slice::from_raw_parts_mut(self.ptr, self.len) } }
    }

    /// Built in primitive types provided by the C language
    #[allow(non_camel_case_types)]
    pub mod ctypes {
        pub enum c_void {}
        pub type c_char = i8;
        pub type c_schar = i8;
        pub type c_uchar = u8;
        pub type c_short = i16;
        pub type c_ushort = u16;
        pub type c_int = i32;
        pub type c_uint = u32;
        pub type c_long = i32;
        pub type c_ulong = u32;
        pub type c_longlong = i64;
        pub type c_ulonglong = u64;
        pub type c_float = f32;
        pub type c_double = f64;
        pub type __int8 = i8;
        pub type __uint8 = u8;
        pub type __int16 = i16;
        pub type __uint16 = u16;
        pub type __int32 = i32;
        pub type __uint32 = u32;
        pub type __int64 = i64;
        pub type __uint64 = u64;
        pub type wchar_t = u16;
    }

    pub use self::ctypes::*;

    pub type GLenum = c_uint;
    pub type GLboolean = c_uchar;
    pub type GLbitfield = c_uint;
    pub type GLvoid = c_void;
    pub type GLbyte = c_char;
    pub type GLshort = c_short;
    pub type GLint = c_int;
    pub type GLclampx = c_int;
    pub type GLubyte = c_uchar;
    pub type GLushort = c_ushort;
    pub type GLuint = c_uint;
    pub type GLsizei = c_int;
    pub type GLfloat = c_float;
    pub type GLclampf = c_float;
    pub type GLdouble = c_double;
    pub type GLclampd = c_double;
    pub type GLeglImageOES = *const c_void;
    pub type GLchar = c_char;
    pub type GLcharARB = c_char;

    #[cfg(target_os = "macos")]
    pub type GLhandleARB = *const c_void;
    #[cfg(not(target_os = "macos"))]
    pub type GLhandleARB = c_uint;

    pub type GLhalfARB = c_ushort;
    pub type GLhalf = c_ushort;

    // Must be 32 bits
    pub type GLfixed = GLint;
    pub type GLintptr = isize;
    pub type GLsizeiptr = isize;
    pub type GLint64 = i64;
    pub type GLuint64 = u64;
    pub type GLintptrARB = isize;
    pub type GLsizeiptrARB = isize;
    pub type GLint64EXT = i64;
    pub type GLuint64EXT = u64;

    pub type GLDEBUGPROC = Option<extern "system" fn(source: GLenum, gltype: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: *const GLchar, userParam: *mut c_void)>;
    pub type GLDEBUGPROCARB = Option<extern "system" fn(source: GLenum, gltype: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: *const GLchar, userParam: *mut c_void)>;
    pub type GLDEBUGPROCKHR = Option<extern "system" fn(source: GLenum, gltype: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: *const GLchar, userParam: *mut c_void)>;

    // Vendor extension types
    pub type GLDEBUGPROCAMD = Option<extern "system" fn(id: GLuint, category: GLenum, severity: GLenum, length: GLsizei, message: *const GLchar, userParam: *mut c_void)>;
    pub type GLhalfNV = c_ushort;
    pub type GLvdpauSurfaceNV = GLintptr;



    use crate::window::PhysicalSizeU32;
    use crate::css::ColorU;
    use crate::image::RawImageFormat;
    use crate::svg::{TessellatedGPUSvgNode, TessellatedSvgNode};
    use crate::vec::{GLuintVec, StringVec, StyleTransformVec};
    use crate::option::OptionU8VecRef;
    /// `Texture` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTexture as Texture;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextureCrossCrateImpl { pub _0: azul::AzTexture }

    #[cfg(feature = "link_static")] pub use TextureCrossCrateImpl as Texture;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextureCrossCrateImpl { type Target = AzTexture; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextureCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Texture {

        /// Creates a new `Texture` instance.
        pub fn new(texture_id: u32, flags: TextureFlags, size: PhysicalSizeU32, background_color: ColorU, gl_context: Gl, format: RawImageFormat) -> Self { unsafe { crate::dll::AzTexture_new(texture_id, flags, size, background_color, gl_context, format) } }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
        pub fn allocate_rgba8(gl: Gl, size: PhysicalSizeU32, background: ColorU) -> Self { unsafe { crate::dll::AzTexture_allocateRgba8(gl, size, background) } }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
        pub fn allocate_clip_mask(gl: Gl, size: PhysicalSizeU32, background: ColorU) -> Self { unsafe { crate::dll::AzTexture_allocateClipMask(gl, size, background) } }
        /// Clears the texture with the currently set background color
        pub fn clear(&mut self)  { unsafe { crate::dll::AzTexture_clear(self) } }
        /// Draws a vertex / index buffer (aka. `&TessellatedSvgNode`) to the texture
        pub fn draw_clip_mask(&mut self, node: TessellatedSvgNode)  -> bool { unsafe { crate::dll::AzTexture_drawClipMask(self, node) } }
        /// Draws a `&TessellatedGPUSvgNode` with the given color to the texture
        pub fn draw_tesselated_svg_gpu_node(&mut self, node: *const AzTessellatedGPUSvgNode, size: PhysicalSizeU32, color: ColorU, transforms: StyleTransformVec)  -> bool { unsafe { crate::dll::AzTexture_drawTesselatedSvgGpuNode(self, node, size, color, transforms) } }
        /// Applies an FXAA filter to the texture
        pub fn apply_fxaa(&mut self)  -> bool { unsafe { crate::dll::AzTexture_applyFxaa(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TextureCrossCrateImpl {

        /// Creates a new `Texture` instance.
        pub fn new(texture_id: u32, flags: TextureFlags, size: PhysicalSizeU32, background_color: ColorU, gl_context: Gl, format: RawImageFormat) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTexture_new(texture_id, flags._0, size._0, background_color._0, gl_context._0, format._0) }) } }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
        pub fn allocate_rgba8(gl: Gl, size: PhysicalSizeU32, background: ColorU) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTexture_allocateRgba8(gl._0, size._0, background._0) }) } }
        /// Allocates an OpenGL texture of a given size with a single red channel (used for image masks)
        pub fn allocate_clip_mask(gl: Gl, size: PhysicalSizeU32, background: ColorU) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTexture_allocateClipMask(gl._0, size._0, background._0) }) } }
        /// Clears the texture with the currently set background color
        pub fn clear(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzTexture_clear(&mut self._0) }) } }
        /// Draws a vertex / index buffer (aka. `&TessellatedSvgNode`) to the texture
        pub fn draw_clip_mask(&mut self, node: TessellatedSvgNode)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzTexture_drawClipMask(&mut self._0, node._0) }) } }
        /// Draws a `&TessellatedGPUSvgNode` with the given color to the texture
        pub fn draw_tesselated_svg_gpu_node(&mut self, node: *const AzTessellatedGPUSvgNode, size: PhysicalSizeU32, color: ColorU, transforms: StyleTransformVec)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzTexture_drawTesselatedSvgGpuNode(&mut self._0, unsafe { core::mem::transmute(node) }, size._0, color._0, transforms._0) }) } }
        /// Applies an FXAA filter to the texture
        pub fn apply_fxaa(&mut self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzTexture_applyFxaa(&mut self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for Texture { fn clone(&self) -> Self { unsafe { crate::dll::AzTexture_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for Texture { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzTexture_delete(self) } } } }
    /// `GlVoidPtrConst` struct

    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGlVoidPtrConst as GlVoidPtrConst;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GlVoidPtrConstCrossCrateImpl { pub _0: azul::AzGlVoidPtrConst }

    #[cfg(feature = "link_static")] pub use GlVoidPtrConstCrossCrateImpl as GlVoidPtrConst;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GlVoidPtrConstCrossCrateImpl { type Target = AzGlVoidPtrConst; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GlVoidPtrConstCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))] impl Clone for GlVoidPtrConst { fn clone(&self) -> Self { unsafe { crate::dll::AzGlVoidPtrConst_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for GlVoidPtrConst { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzGlVoidPtrConst_delete(self) } } } }
    /// `GlVoidPtrMut` struct

    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGlVoidPtrMut as GlVoidPtrMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GlVoidPtrMutCrossCrateImpl { pub _0: azul::AzGlVoidPtrMut }

    #[cfg(feature = "link_static")] pub use GlVoidPtrMutCrossCrateImpl as GlVoidPtrMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GlVoidPtrMutCrossCrateImpl { type Target = AzGlVoidPtrMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GlVoidPtrMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Gl` struct

    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGl as Gl;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GlCrossCrateImpl { pub _0: azul::AzGl }

    #[cfg(feature = "link_static")] pub use GlCrossCrateImpl as Gl;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GlCrossCrateImpl { type Target = AzGl; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GlCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Gl {

        pub const ACCUM: u32 = 0x0100;
        pub const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
        pub const ACCUM_BLUE_BITS: u32 = 0x0D5A;
        pub const ACCUM_BUFFER_BIT: u32 = 0x00000200;
        pub const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
        pub const ACCUM_GREEN_BITS: u32 = 0x0D59;
        pub const ACCUM_RED_BITS: u32 = 0x0D58;
        pub const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
        pub const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
        pub const ACTIVE_TEXTURE: u32 = 0x84E0;
        pub const ACTIVE_UNIFORMS: u32 = 0x8B86;
        pub const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
        pub const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
        pub const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
        pub const ADD: u32 = 0x0104;
        pub const ADD_SIGNED: u32 = 0x8574;
        pub const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
        pub const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
        pub const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const ALPHA: u32 = 0x1906;
        pub const ALPHA12: u32 = 0x803D;
        pub const ALPHA16: u32 = 0x803E;
        pub const ALPHA16F_EXT: u32 = 0x881C;
        pub const ALPHA32F_EXT: u32 = 0x8816;
        pub const ALPHA4: u32 = 0x803B;
        pub const ALPHA8: u32 = 0x803C;
        pub const ALPHA8_EXT: u32 = 0x803C;
        pub const ALPHA_BIAS: u32 = 0x0D1D;
        pub const ALPHA_BITS: u32 = 0x0D55;
        pub const ALPHA_INTEGER: u32 = 0x8D97;
        pub const ALPHA_SCALE: u32 = 0x0D1C;
        pub const ALPHA_TEST: u32 = 0x0BC0;
        pub const ALPHA_TEST_FUNC: u32 = 0x0BC1;
        pub const ALPHA_TEST_REF: u32 = 0x0BC2;
        pub const ALREADY_SIGNALED: u32 = 0x911A;
        pub const ALWAYS: u32 = 0x0207;
        pub const AMBIENT: u32 = 0x1200;
        pub const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
        pub const AND: u32 = 0x1501;
        pub const AND_INVERTED: u32 = 0x1504;
        pub const AND_REVERSE: u32 = 0x1502;
        pub const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
        pub const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
        pub const ARRAY_BUFFER: u32 = 0x8892;
        pub const ARRAY_BUFFER_BINDING: u32 = 0x8894;
        pub const ATTACHED_SHADERS: u32 = 0x8B85;
        pub const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
        pub const AUTO_NORMAL: u32 = 0x0D80;
        pub const AUX0: u32 = 0x0409;
        pub const AUX1: u32 = 0x040A;
        pub const AUX2: u32 = 0x040B;
        pub const AUX3: u32 = 0x040C;
        pub const AUX_BUFFERS: u32 = 0x0C00;
        pub const BACK: u32 = 0x0405;
        pub const BACK_LEFT: u32 = 0x0402;
        pub const BACK_RIGHT: u32 = 0x0403;
        pub const BGR: u32 = 0x80E0;
        pub const BGRA: u32 = 0x80E1;
        pub const BGRA8_EXT: u32 = 0x93A1;
        pub const BGRA_EXT: u32 = 0x80E1;
        pub const BGRA_INTEGER: u32 = 0x8D9B;
        pub const BGR_INTEGER: u32 = 0x8D9A;
        pub const BITMAP: u32 = 0x1A00;
        pub const BITMAP_TOKEN: u32 = 0x0704;
        pub const BLEND: u32 = 0x0BE2;
        pub const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
        pub const BLEND_COLOR: u32 = 0x8005;
        pub const BLEND_DST: u32 = 0x0BE0;
        pub const BLEND_DST_ALPHA: u32 = 0x80CA;
        pub const BLEND_DST_RGB: u32 = 0x80C8;
        pub const BLEND_EQUATION: u32 = 0x8009;
        pub const BLEND_EQUATION_ALPHA: u32 = 0x883D;
        pub const BLEND_EQUATION_RGB: u32 = 0x8009;
        pub const BLEND_SRC: u32 = 0x0BE1;
        pub const BLEND_SRC_ALPHA: u32 = 0x80CB;
        pub const BLEND_SRC_RGB: u32 = 0x80C9;
        pub const BLUE: u32 = 0x1905;
        pub const BLUE_BIAS: u32 = 0x0D1B;
        pub const BLUE_BITS: u32 = 0x0D54;
        pub const BLUE_INTEGER: u32 = 0x8D96;
        pub const BLUE_SCALE: u32 = 0x0D1A;
        pub const BOOL: u32 = 0x8B56;
        pub const BOOL_VEC2: u32 = 0x8B57;
        pub const BOOL_VEC3: u32 = 0x8B58;
        pub const BOOL_VEC4: u32 = 0x8B59;
        pub const BUFFER: u32 = 0x82E0;
        pub const BUFFER_ACCESS: u32 = 0x88BB;
        pub const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
        pub const BUFFER_KHR: u32 = 0x82E0;
        pub const BUFFER_MAPPED: u32 = 0x88BC;
        pub const BUFFER_MAP_LENGTH: u32 = 0x9120;
        pub const BUFFER_MAP_OFFSET: u32 = 0x9121;
        pub const BUFFER_MAP_POINTER: u32 = 0x88BD;
        pub const BUFFER_SIZE: u32 = 0x8764;
        pub const BUFFER_USAGE: u32 = 0x8765;
        pub const BYTE: u32 = 0x1400;
        pub const C3F_V3F: u32 = 0x2A24;
        pub const C4F_N3F_V3F: u32 = 0x2A26;
        pub const C4UB_V2F: u32 = 0x2A22;
        pub const C4UB_V3F: u32 = 0x2A23;
        pub const CCW: u32 = 0x0901;
        pub const CLAMP: u32 = 0x2900;
        pub const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
        pub const CLAMP_READ_COLOR: u32 = 0x891C;
        pub const CLAMP_TO_BORDER: u32 = 0x812D;
        pub const CLAMP_TO_EDGE: u32 = 0x812F;
        pub const CLAMP_VERTEX_COLOR: u32 = 0x891A;
        pub const CLEAR: u32 = 0x1500;
        pub const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
        pub const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
        pub const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
        pub const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
        pub const CLIP_DISTANCE0: u32 = 0x3000;
        pub const CLIP_DISTANCE1: u32 = 0x3001;
        pub const CLIP_DISTANCE2: u32 = 0x3002;
        pub const CLIP_DISTANCE3: u32 = 0x3003;
        pub const CLIP_DISTANCE4: u32 = 0x3004;
        pub const CLIP_DISTANCE5: u32 = 0x3005;
        pub const CLIP_DISTANCE6: u32 = 0x3006;
        pub const CLIP_DISTANCE7: u32 = 0x3007;
        pub const CLIP_PLANE0: u32 = 0x3000;
        pub const CLIP_PLANE1: u32 = 0x3001;
        pub const CLIP_PLANE2: u32 = 0x3002;
        pub const CLIP_PLANE3: u32 = 0x3003;
        pub const CLIP_PLANE4: u32 = 0x3004;
        pub const CLIP_PLANE5: u32 = 0x3005;
        pub const COEFF: u32 = 0x0A00;
        pub const COLOR: u32 = 0x1800;
        pub const COLORBURN_KHR: u32 = 0x929A;
        pub const COLORDODGE_KHR: u32 = 0x9299;
        pub const COLOR_ARRAY: u32 = 0x8076;
        pub const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
        pub const COLOR_ARRAY_POINTER: u32 = 0x8090;
        pub const COLOR_ARRAY_SIZE: u32 = 0x8081;
        pub const COLOR_ARRAY_STRIDE: u32 = 0x8083;
        pub const COLOR_ARRAY_TYPE: u32 = 0x8082;
        pub const COLOR_ATTACHMENT0: u32 = 0x8CE0;
        pub const COLOR_ATTACHMENT1: u32 = 0x8CE1;
        pub const COLOR_ATTACHMENT10: u32 = 0x8CEA;
        pub const COLOR_ATTACHMENT11: u32 = 0x8CEB;
        pub const COLOR_ATTACHMENT12: u32 = 0x8CEC;
        pub const COLOR_ATTACHMENT13: u32 = 0x8CED;
        pub const COLOR_ATTACHMENT14: u32 = 0x8CEE;
        pub const COLOR_ATTACHMENT15: u32 = 0x8CEF;
        pub const COLOR_ATTACHMENT16: u32 = 0x8CF0;
        pub const COLOR_ATTACHMENT17: u32 = 0x8CF1;
        pub const COLOR_ATTACHMENT18: u32 = 0x8CF2;
        pub const COLOR_ATTACHMENT19: u32 = 0x8CF3;
        pub const COLOR_ATTACHMENT2: u32 = 0x8CE2;
        pub const COLOR_ATTACHMENT20: u32 = 0x8CF4;
        pub const COLOR_ATTACHMENT21: u32 = 0x8CF5;
        pub const COLOR_ATTACHMENT22: u32 = 0x8CF6;
        pub const COLOR_ATTACHMENT23: u32 = 0x8CF7;
        pub const COLOR_ATTACHMENT24: u32 = 0x8CF8;
        pub const COLOR_ATTACHMENT25: u32 = 0x8CF9;
        pub const COLOR_ATTACHMENT26: u32 = 0x8CFA;
        pub const COLOR_ATTACHMENT27: u32 = 0x8CFB;
        pub const COLOR_ATTACHMENT28: u32 = 0x8CFC;
        pub const COLOR_ATTACHMENT29: u32 = 0x8CFD;
        pub const COLOR_ATTACHMENT3: u32 = 0x8CE3;
        pub const COLOR_ATTACHMENT30: u32 = 0x8CFE;
        pub const COLOR_ATTACHMENT31: u32 = 0x8CFF;
        pub const COLOR_ATTACHMENT4: u32 = 0x8CE4;
        pub const COLOR_ATTACHMENT5: u32 = 0x8CE5;
        pub const COLOR_ATTACHMENT6: u32 = 0x8CE6;
        pub const COLOR_ATTACHMENT7: u32 = 0x8CE7;
        pub const COLOR_ATTACHMENT8: u32 = 0x8CE8;
        pub const COLOR_ATTACHMENT9: u32 = 0x8CE9;
        pub const COLOR_BUFFER_BIT: u32 = 0x00004000;
        pub const COLOR_CLEAR_VALUE: u32 = 0x0C22;
        pub const COLOR_INDEX: u32 = 0x1900;
        pub const COLOR_INDEXES: u32 = 0x1603;
        pub const COLOR_LOGIC_OP: u32 = 0x0BF2;
        pub const COLOR_MATERIAL: u32 = 0x0B57;
        pub const COLOR_MATERIAL_FACE: u32 = 0x0B55;
        pub const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
        pub const COLOR_SUM: u32 = 0x8458;
        pub const COLOR_WRITEMASK: u32 = 0x0C23;
        pub const COMBINE: u32 = 0x8570;
        pub const COMBINE_ALPHA: u32 = 0x8572;
        pub const COMBINE_RGB: u32 = 0x8571;
        pub const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
        pub const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
        pub const COMPILE: u32 = 0x1300;
        pub const COMPILE_AND_EXECUTE: u32 = 0x1301;
        pub const COMPILE_STATUS: u32 = 0x8B81;
        pub const COMPRESSED_ALPHA: u32 = 0x84E9;
        pub const COMPRESSED_INTENSITY: u32 = 0x84EC;
        pub const COMPRESSED_LUMINANCE: u32 = 0x84EA;
        pub const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
        pub const COMPRESSED_R11_EAC: u32 = 0x9270;
        pub const COMPRESSED_RED: u32 = 0x8225;
        pub const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
        pub const COMPRESSED_RG: u32 = 0x8226;
        pub const COMPRESSED_RG11_EAC: u32 = 0x9272;
        pub const COMPRESSED_RGB: u32 = 0x84ED;
        pub const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
        pub const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
        pub const COMPRESSED_RGBA: u32 = 0x84EE;
        pub const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
        pub const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
        pub const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
        pub const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
        pub const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
        pub const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
        pub const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
        pub const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
        pub const COMPRESSED_SRGB: u32 = 0x8C48;
        pub const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
        pub const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
        pub const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
        pub const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
        pub const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
        pub const CONDITION_SATISFIED: u32 = 0x911C;
        pub const CONSTANT: u32 = 0x8576;
        pub const CONSTANT_ALPHA: u32 = 0x8003;
        pub const CONSTANT_ATTENUATION: u32 = 0x1207;
        pub const CONSTANT_COLOR: u32 = 0x8001;
        pub const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
        pub const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
        pub const CONTEXT_FLAGS: u32 = 0x821E;
        pub const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
        pub const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
        pub const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
        pub const CONTEXT_PROFILE_MASK: u32 = 0x9126;
        pub const COORD_REPLACE: u32 = 0x8862;
        pub const COPY: u32 = 0x1503;
        pub const COPY_INVERTED: u32 = 0x150C;
        pub const COPY_PIXEL_TOKEN: u32 = 0x0706;
        pub const COPY_READ_BUFFER: u32 = 0x8F36;
        pub const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
        pub const COPY_WRITE_BUFFER: u32 = 0x8F37;
        pub const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
        pub const CULL_FACE: u32 = 0x0B44;
        pub const CULL_FACE_MODE: u32 = 0x0B45;
        pub const CURRENT_BIT: u32 = 0x00000001;
        pub const CURRENT_COLOR: u32 = 0x0B00;
        pub const CURRENT_FOG_COORD: u32 = 0x8453;
        pub const CURRENT_FOG_COORDINATE: u32 = 0x8453;
        pub const CURRENT_INDEX: u32 = 0x0B01;
        pub const CURRENT_NORMAL: u32 = 0x0B02;
        pub const CURRENT_PROGRAM: u32 = 0x8B8D;
        pub const CURRENT_QUERY: u32 = 0x8865;
        pub const CURRENT_QUERY_EXT: u32 = 0x8865;
        pub const CURRENT_RASTER_COLOR: u32 = 0x0B04;
        pub const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
        pub const CURRENT_RASTER_INDEX: u32 = 0x0B05;
        pub const CURRENT_RASTER_POSITION: u32 = 0x0B07;
        pub const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
        pub const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
        pub const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
        pub const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
        pub const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
        pub const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
        pub const CW: u32 = 0x0900;
        pub const DARKEN_KHR: u32 = 0x9297;
        pub const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
        pub const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
        pub const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
        pub const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
        pub const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
        pub const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
        pub const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
        pub const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
        pub const DEBUG_OUTPUT: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
        pub const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
        pub const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
        pub const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
        pub const DEBUG_SEVERITY_LOW: u32 = 0x9148;
        pub const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
        pub const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
        pub const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
        pub const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
        pub const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
        pub const DEBUG_SOURCE_API: u32 = 0x8246;
        pub const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
        pub const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
        pub const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
        pub const DEBUG_SOURCE_OTHER: u32 = 0x824B;
        pub const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
        pub const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
        pub const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
        pub const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
        pub const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
        pub const DEBUG_TYPE_ERROR: u32 = 0x824C;
        pub const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
        pub const DEBUG_TYPE_MARKER: u32 = 0x8268;
        pub const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
        pub const DEBUG_TYPE_OTHER: u32 = 0x8251;
        pub const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
        pub const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
        pub const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
        pub const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
        pub const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
        pub const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
        pub const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
        pub const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
        pub const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
        pub const DECAL: u32 = 0x2101;
        pub const DECR: u32 = 0x1E03;
        pub const DECR_WRAP: u32 = 0x8508;
        pub const DELETE_STATUS: u32 = 0x8B80;
        pub const DEPTH: u32 = 0x1801;
        pub const DEPTH24_STENCIL8: u32 = 0x88F0;
        pub const DEPTH32F_STENCIL8: u32 = 0x8CAD;
        pub const DEPTH_ATTACHMENT: u32 = 0x8D00;
        pub const DEPTH_BIAS: u32 = 0x0D1F;
        pub const DEPTH_BITS: u32 = 0x0D56;
        pub const DEPTH_BUFFER_BIT: u32 = 0x00000100;
        pub const DEPTH_CLAMP: u32 = 0x864F;
        pub const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
        pub const DEPTH_COMPONENT: u32 = 0x1902;
        pub const DEPTH_COMPONENT16: u32 = 0x81A5;
        pub const DEPTH_COMPONENT24: u32 = 0x81A6;
        pub const DEPTH_COMPONENT32: u32 = 0x81A7;
        pub const DEPTH_COMPONENT32F: u32 = 0x8CAC;
        pub const DEPTH_FUNC: u32 = 0x0B74;
        pub const DEPTH_RANGE: u32 = 0x0B70;
        pub const DEPTH_SCALE: u32 = 0x0D1E;
        pub const DEPTH_STENCIL: u32 = 0x84F9;
        pub const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
        pub const DEPTH_TEST: u32 = 0x0B71;
        pub const DEPTH_TEXTURE_MODE: u32 = 0x884B;
        pub const DEPTH_WRITEMASK: u32 = 0x0B72;
        pub const DIFFERENCE_KHR: u32 = 0x929E;
        pub const DIFFUSE: u32 = 0x1201;
        pub const DISPLAY_LIST: u32 = 0x82E7;
        pub const DITHER: u32 = 0x0BD0;
        pub const DOMAIN: u32 = 0x0A02;
        pub const DONT_CARE: u32 = 0x1100;
        pub const DOT3_RGB: u32 = 0x86AE;
        pub const DOT3_RGBA: u32 = 0x86AF;
        pub const DOUBLE: u32 = 0x140A;
        pub const DOUBLEBUFFER: u32 = 0x0C32;
        pub const DRAW_BUFFER: u32 = 0x0C01;
        pub const DRAW_BUFFER0: u32 = 0x8825;
        pub const DRAW_BUFFER1: u32 = 0x8826;
        pub const DRAW_BUFFER10: u32 = 0x882F;
        pub const DRAW_BUFFER11: u32 = 0x8830;
        pub const DRAW_BUFFER12: u32 = 0x8831;
        pub const DRAW_BUFFER13: u32 = 0x8832;
        pub const DRAW_BUFFER14: u32 = 0x8833;
        pub const DRAW_BUFFER15: u32 = 0x8834;
        pub const DRAW_BUFFER2: u32 = 0x8827;
        pub const DRAW_BUFFER3: u32 = 0x8828;
        pub const DRAW_BUFFER4: u32 = 0x8829;
        pub const DRAW_BUFFER5: u32 = 0x882A;
        pub const DRAW_BUFFER6: u32 = 0x882B;
        pub const DRAW_BUFFER7: u32 = 0x882C;
        pub const DRAW_BUFFER8: u32 = 0x882D;
        pub const DRAW_BUFFER9: u32 = 0x882E;
        pub const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
        pub const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
        pub const DRAW_PIXEL_TOKEN: u32 = 0x0705;
        pub const DST_ALPHA: u32 = 0x0304;
        pub const DST_COLOR: u32 = 0x0306;
        pub const DYNAMIC_COPY: u32 = 0x88EA;
        pub const DYNAMIC_DRAW: u32 = 0x88E8;
        pub const DYNAMIC_READ: u32 = 0x88E9;
        pub const EDGE_FLAG: u32 = 0x0B43;
        pub const EDGE_FLAG_ARRAY: u32 = 0x8079;
        pub const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
        pub const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
        pub const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
        pub const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
        pub const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
        pub const EMISSION: u32 = 0x1600;
        pub const ENABLE_BIT: u32 = 0x00002000;
        pub const EQUAL: u32 = 0x0202;
        pub const EQUIV: u32 = 0x1509;
        pub const EVAL_BIT: u32 = 0x00010000;
        pub const EXCLUSION_KHR: u32 = 0x92A0;
        pub const EXP: u32 = 0x0800;
        pub const EXP2: u32 = 0x0801;
        pub const EXTENSIONS: u32 = 0x1F03;
        pub const EYE_LINEAR: u32 = 0x2400;
        pub const EYE_PLANE: u32 = 0x2502;
        pub const FALSE: u8 = 0;
        pub const FASTEST: u32 = 0x1101;
        pub const FEEDBACK: u32 = 0x1C01;
        pub const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
        pub const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
        pub const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
        pub const FENCE_APPLE: u32 = 0x8A0B;
        pub const FILL: u32 = 0x1B02;
        pub const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
        pub const FIXED: u32 = 0x140C;
        pub const FIXED_ONLY: u32 = 0x891D;
        pub const FLAT: u32 = 0x1D00;
        pub const FLOAT: u32 = 0x1406;
        pub const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
        pub const FLOAT_MAT2: u32 = 0x8B5A;
        pub const FLOAT_MAT2x3: u32 = 0x8B65;
        pub const FLOAT_MAT2x4: u32 = 0x8B66;
        pub const FLOAT_MAT3: u32 = 0x8B5B;
        pub const FLOAT_MAT3x2: u32 = 0x8B67;
        pub const FLOAT_MAT3x4: u32 = 0x8B68;
        pub const FLOAT_MAT4: u32 = 0x8B5C;
        pub const FLOAT_MAT4x2: u32 = 0x8B69;
        pub const FLOAT_MAT4x3: u32 = 0x8B6A;
        pub const FLOAT_VEC2: u32 = 0x8B50;
        pub const FLOAT_VEC3: u32 = 0x8B51;
        pub const FLOAT_VEC4: u32 = 0x8B52;
        pub const FOG: u32 = 0x0B60;
        pub const FOG_BIT: u32 = 0x00000080;
        pub const FOG_COLOR: u32 = 0x0B66;
        pub const FOG_COORD: u32 = 0x8451;
        pub const FOG_COORDINATE: u32 = 0x8451;
        pub const FOG_COORDINATE_ARRAY: u32 = 0x8457;
        pub const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORDINATE_SOURCE: u32 = 0x8450;
        pub const FOG_COORD_ARRAY: u32 = 0x8457;
        pub const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORD_SRC: u32 = 0x8450;
        pub const FOG_DENSITY: u32 = 0x0B62;
        pub const FOG_END: u32 = 0x0B64;
        pub const FOG_HINT: u32 = 0x0C54;
        pub const FOG_INDEX: u32 = 0x0B61;
        pub const FOG_MODE: u32 = 0x0B65;
        pub const FOG_START: u32 = 0x0B63;
        pub const FRAGMENT_DEPTH: u32 = 0x8452;
        pub const FRAGMENT_SHADER: u32 = 0x8B30;
        pub const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
        pub const FRAMEBUFFER: u32 = 0x8D40;
        pub const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
        pub const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
        pub const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
        pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
        pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
        pub const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
        pub const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
        pub const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
        pub const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
        pub const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
        pub const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
        pub const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
        pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
        pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
        pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
        pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
        pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
        pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
        pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
        pub const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
        pub const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
        pub const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
        pub const FRONT: u32 = 0x0404;
        pub const FRONT_AND_BACK: u32 = 0x0408;
        pub const FRONT_FACE: u32 = 0x0B46;
        pub const FRONT_LEFT: u32 = 0x0400;
        pub const FRONT_RIGHT: u32 = 0x0401;
        pub const FUNC_ADD: u32 = 0x8006;
        pub const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
        pub const FUNC_SUBTRACT: u32 = 0x800A;
        pub const GENERATE_MIPMAP: u32 = 0x8191;
        pub const GENERATE_MIPMAP_HINT: u32 = 0x8192;
        pub const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
        pub const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
        pub const GEOMETRY_SHADER: u32 = 0x8DD9;
        pub const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
        pub const GEQUAL: u32 = 0x0206;
        pub const GPU_DISJOINT_EXT: u32 = 0x8FBB;
        pub const GREATER: u32 = 0x0204;
        pub const GREEN: u32 = 0x1904;
        pub const GREEN_BIAS: u32 = 0x0D19;
        pub const GREEN_BITS: u32 = 0x0D53;
        pub const GREEN_INTEGER: u32 = 0x8D95;
        pub const GREEN_SCALE: u32 = 0x0D18;
        pub const HALF_FLOAT: u32 = 0x140B;
        pub const HALF_FLOAT_OES: u32 = 0x8D61;
        pub const HARDLIGHT_KHR: u32 = 0x929B;
        pub const HIGH_FLOAT: u32 = 0x8DF2;
        pub const HIGH_INT: u32 = 0x8DF5;
        pub const HINT_BIT: u32 = 0x00008000;
        pub const HSL_COLOR_KHR: u32 = 0x92AF;
        pub const HSL_HUE_KHR: u32 = 0x92AD;
        pub const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
        pub const HSL_SATURATION_KHR: u32 = 0x92AE;
        pub const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
        pub const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
        pub const INCR: u32 = 0x1E02;
        pub const INCR_WRAP: u32 = 0x8507;
        pub const INDEX: u32 = 0x8222;
        pub const INDEX_ARRAY: u32 = 0x8077;
        pub const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
        pub const INDEX_ARRAY_POINTER: u32 = 0x8091;
        pub const INDEX_ARRAY_STRIDE: u32 = 0x8086;
        pub const INDEX_ARRAY_TYPE: u32 = 0x8085;
        pub const INDEX_BITS: u32 = 0x0D51;
        pub const INDEX_CLEAR_VALUE: u32 = 0x0C20;
        pub const INDEX_LOGIC_OP: u32 = 0x0BF1;
        pub const INDEX_MODE: u32 = 0x0C30;
        pub const INDEX_OFFSET: u32 = 0x0D13;
        pub const INDEX_SHIFT: u32 = 0x0D12;
        pub const INDEX_WRITEMASK: u32 = 0x0C21;
        pub const INFO_LOG_LENGTH: u32 = 0x8B84;
        pub const INT: u32 = 0x1404;
        pub const INTENSITY: u32 = 0x8049;
        pub const INTENSITY12: u32 = 0x804C;
        pub const INTENSITY16: u32 = 0x804D;
        pub const INTENSITY4: u32 = 0x804A;
        pub const INTENSITY8: u32 = 0x804B;
        pub const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
        pub const INTERPOLATE: u32 = 0x8575;
        pub const INT_2_10_10_10_REV: u32 = 0x8D9F;
        pub const INT_SAMPLER_1D: u32 = 0x8DC9;
        pub const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
        pub const INT_SAMPLER_2D: u32 = 0x8DCA;
        pub const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
        pub const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
        pub const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
        pub const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
        pub const INT_SAMPLER_3D: u32 = 0x8DCB;
        pub const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
        pub const INT_SAMPLER_CUBE: u32 = 0x8DCC;
        pub const INT_VEC2: u32 = 0x8B53;
        pub const INT_VEC3: u32 = 0x8B54;
        pub const INT_VEC4: u32 = 0x8B55;
        pub const INVALID_ENUM: u32 = 0x0500;
        pub const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
        pub const INVALID_INDEX: u32 = 0xFFFFFFFF;
        pub const INVALID_OPERATION: u32 = 0x0502;
        pub const INVALID_VALUE: u32 = 0x0501;
        pub const INVERT: u32 = 0x150A;
        pub const KEEP: u32 = 0x1E00;
        pub const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
        pub const LEFT: u32 = 0x0406;
        pub const LEQUAL: u32 = 0x0203;
        pub const LESS: u32 = 0x0201;
        pub const LIGHT0: u32 = 0x4000;
        pub const LIGHT1: u32 = 0x4001;
        pub const LIGHT2: u32 = 0x4002;
        pub const LIGHT3: u32 = 0x4003;
        pub const LIGHT4: u32 = 0x4004;
        pub const LIGHT5: u32 = 0x4005;
        pub const LIGHT6: u32 = 0x4006;
        pub const LIGHT7: u32 = 0x4007;
        pub const LIGHTEN_KHR: u32 = 0x9298;
        pub const LIGHTING: u32 = 0x0B50;
        pub const LIGHTING_BIT: u32 = 0x00000040;
        pub const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
        pub const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
        pub const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
        pub const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
        pub const LINE: u32 = 0x1B01;
        pub const LINEAR: u32 = 0x2601;
        pub const LINEAR_ATTENUATION: u32 = 0x1208;
        pub const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
        pub const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
        pub const LINES: u32 = 0x0001;
        pub const LINES_ADJACENCY: u32 = 0x000A;
        pub const LINE_BIT: u32 = 0x00000004;
        pub const LINE_LOOP: u32 = 0x0002;
        pub const LINE_RESET_TOKEN: u32 = 0x0707;
        pub const LINE_SMOOTH: u32 = 0x0B20;
        pub const LINE_SMOOTH_HINT: u32 = 0x0C52;
        pub const LINE_STIPPLE: u32 = 0x0B24;
        pub const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
        pub const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
        pub const LINE_STRIP: u32 = 0x0003;
        pub const LINE_STRIP_ADJACENCY: u32 = 0x000B;
        pub const LINE_TOKEN: u32 = 0x0702;
        pub const LINE_WIDTH: u32 = 0x0B21;
        pub const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const LINK_STATUS: u32 = 0x8B82;
        pub const LIST_BASE: u32 = 0x0B32;
        pub const LIST_BIT: u32 = 0x00020000;
        pub const LIST_INDEX: u32 = 0x0B33;
        pub const LIST_MODE: u32 = 0x0B30;
        pub const LOAD: u32 = 0x0101;
        pub const LOGIC_OP: u32 = 0x0BF1;
        pub const LOGIC_OP_MODE: u32 = 0x0BF0;
        pub const LOWER_LEFT: u32 = 0x8CA1;
        pub const LOW_FLOAT: u32 = 0x8DF0;
        pub const LOW_INT: u32 = 0x8DF3;
        pub const LUMINANCE: u32 = 0x1909;
        pub const LUMINANCE12: u32 = 0x8041;
        pub const LUMINANCE12_ALPHA12: u32 = 0x8047;
        pub const LUMINANCE12_ALPHA4: u32 = 0x8046;
        pub const LUMINANCE16: u32 = 0x8042;
        pub const LUMINANCE16F_EXT: u32 = 0x881E;
        pub const LUMINANCE16_ALPHA16: u32 = 0x8048;
        pub const LUMINANCE32F_EXT: u32 = 0x8818;
        pub const LUMINANCE4: u32 = 0x803F;
        pub const LUMINANCE4_ALPHA4: u32 = 0x8043;
        pub const LUMINANCE6_ALPHA2: u32 = 0x8044;
        pub const LUMINANCE8: u32 = 0x8040;
        pub const LUMINANCE8_ALPHA8: u32 = 0x8045;
        pub const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
        pub const LUMINANCE8_EXT: u32 = 0x8040;
        pub const LUMINANCE_ALPHA: u32 = 0x190A;
        pub const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
        pub const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
        pub const MAJOR_VERSION: u32 = 0x821B;
        pub const MAP1_COLOR_4: u32 = 0x0D90;
        pub const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
        pub const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
        pub const MAP1_INDEX: u32 = 0x0D91;
        pub const MAP1_NORMAL: u32 = 0x0D92;
        pub const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
        pub const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
        pub const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
        pub const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
        pub const MAP1_VERTEX_3: u32 = 0x0D97;
        pub const MAP1_VERTEX_4: u32 = 0x0D98;
        pub const MAP2_COLOR_4: u32 = 0x0DB0;
        pub const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
        pub const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
        pub const MAP2_INDEX: u32 = 0x0DB1;
        pub const MAP2_NORMAL: u32 = 0x0DB2;
        pub const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
        pub const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
        pub const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
        pub const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
        pub const MAP2_VERTEX_3: u32 = 0x0DB7;
        pub const MAP2_VERTEX_4: u32 = 0x0DB8;
        pub const MAP_COLOR: u32 = 0x0D10;
        pub const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
        pub const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
        pub const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
        pub const MAP_READ_BIT: u32 = 0x0001;
        pub const MAP_STENCIL: u32 = 0x0D11;
        pub const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
        pub const MAP_WRITE_BIT: u32 = 0x0002;
        pub const MATRIX_MODE: u32 = 0x0BA0;
        pub const MAX: u32 = 0x8008;
        pub const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
        pub const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
        pub const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
        pub const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
        pub const MAX_CLIP_DISTANCES: u32 = 0x0D32;
        pub const MAX_CLIP_PLANES: u32 = 0x0D32;
        pub const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
        pub const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
        pub const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
        pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
        pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
        pub const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
        pub const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
        pub const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
        pub const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
        pub const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
        pub const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
        pub const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
        pub const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
        pub const MAX_DRAW_BUFFERS: u32 = 0x8824;
        pub const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
        pub const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
        pub const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
        pub const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
        pub const MAX_EVAL_ORDER: u32 = 0x0D30;
        pub const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
        pub const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
        pub const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
        pub const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
        pub const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
        pub const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
        pub const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
        pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
        pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
        pub const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
        pub const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
        pub const MAX_INTEGER_SAMPLES: u32 = 0x9110;
        pub const MAX_LABEL_LENGTH: u32 = 0x82E8;
        pub const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
        pub const MAX_LIGHTS: u32 = 0x0D31;
        pub const MAX_LIST_NESTING: u32 = 0x0B31;
        pub const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
        pub const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
        pub const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
        pub const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
        pub const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
        pub const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
        pub const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
        pub const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
        pub const MAX_SAMPLES: u32 = 0x8D57;
        pub const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
        pub const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
        pub const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
        pub const MAX_TEXTURE_COORDS: u32 = 0x8871;
        pub const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
        pub const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
        pub const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
        pub const MAX_TEXTURE_SIZE: u32 = 0x0D33;
        pub const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
        pub const MAX_TEXTURE_UNITS: u32 = 0x84E2;
        pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
        pub const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
        pub const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
        pub const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
        pub const MAX_VARYING_FLOATS: u32 = 0x8B4B;
        pub const MAX_VARYING_VECTORS: u32 = 0x8DFC;
        pub const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
        pub const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
        pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
        pub const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
        pub const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
        pub const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
        pub const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
        pub const MEDIUM_FLOAT: u32 = 0x8DF1;
        pub const MEDIUM_INT: u32 = 0x8DF4;
        pub const MIN: u32 = 0x8007;
        pub const MINOR_VERSION: u32 = 0x821C;
        pub const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
        pub const MIRRORED_REPEAT: u32 = 0x8370;
        pub const MODELVIEW: u32 = 0x1700;
        pub const MODELVIEW_MATRIX: u32 = 0x0BA6;
        pub const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
        pub const MODULATE: u32 = 0x2100;
        pub const MULT: u32 = 0x0103;
        pub const MULTIPLY_KHR: u32 = 0x9294;
        pub const MULTISAMPLE: u32 = 0x809D;
        pub const MULTISAMPLE_BIT: u32 = 0x20000000;
        pub const N3F_V3F: u32 = 0x2A25;
        pub const NAME_STACK_DEPTH: u32 = 0x0D70;
        pub const NAND: u32 = 0x150E;
        pub const NEAREST: u32 = 0x2600;
        pub const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
        pub const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
        pub const NEVER: u32 = 0x0200;
        pub const NICEST: u32 = 0x1102;
        pub const NONE: u32 = 0;
        pub const NOOP: u32 = 0x1505;
        pub const NOR: u32 = 0x1508;
        pub const NORMALIZE: u32 = 0x0BA1;
        pub const NORMAL_ARRAY: u32 = 0x8075;
        pub const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
        pub const NORMAL_ARRAY_POINTER: u32 = 0x808F;
        pub const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
        pub const NORMAL_ARRAY_TYPE: u32 = 0x807E;
        pub const NORMAL_MAP: u32 = 0x8511;
        pub const NOTEQUAL: u32 = 0x0205;
        pub const NO_ERROR: u32 = 0;
        pub const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
        pub const NUM_EXTENSIONS: u32 = 0x821D;
        pub const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
        pub const NUM_SAMPLE_COUNTS: u32 = 0x9380;
        pub const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
        pub const OBJECT_LINEAR: u32 = 0x2401;
        pub const OBJECT_PLANE: u32 = 0x2501;
        pub const OBJECT_TYPE: u32 = 0x9112;
        pub const ONE: u32 = 1;
        pub const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
        pub const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
        pub const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
        pub const ONE_MINUS_DST_COLOR: u32 = 0x0307;
        pub const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
        pub const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
        pub const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
        pub const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
        pub const OPERAND0_ALPHA: u32 = 0x8598;
        pub const OPERAND0_RGB: u32 = 0x8590;
        pub const OPERAND1_ALPHA: u32 = 0x8599;
        pub const OPERAND1_RGB: u32 = 0x8591;
        pub const OPERAND2_ALPHA: u32 = 0x859A;
        pub const OPERAND2_RGB: u32 = 0x8592;
        pub const OR: u32 = 0x1507;
        pub const ORDER: u32 = 0x0A01;
        pub const OR_INVERTED: u32 = 0x150D;
        pub const OR_REVERSE: u32 = 0x150B;
        pub const OUT_OF_MEMORY: u32 = 0x0505;
        pub const OVERLAY_KHR: u32 = 0x9296;
        pub const PACK_ALIGNMENT: u32 = 0x0D05;
        pub const PACK_IMAGE_HEIGHT: u32 = 0x806C;
        pub const PACK_LSB_FIRST: u32 = 0x0D01;
        pub const PACK_ROW_LENGTH: u32 = 0x0D02;
        pub const PACK_SKIP_IMAGES: u32 = 0x806B;
        pub const PACK_SKIP_PIXELS: u32 = 0x0D04;
        pub const PACK_SKIP_ROWS: u32 = 0x0D03;
        pub const PACK_SWAP_BYTES: u32 = 0x0D00;
        pub const PASS_THROUGH_TOKEN: u32 = 0x0700;
        pub const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
        pub const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
        pub const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
        pub const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
        pub const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
        pub const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
        pub const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
        pub const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
        pub const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
        pub const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
        pub const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
        pub const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
        pub const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
        pub const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
        pub const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
        pub const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
        pub const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
        pub const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
        pub const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
        pub const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
        pub const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
        pub const PIXEL_MODE_BIT: u32 = 0x00000020;
        pub const PIXEL_PACK_BUFFER: u32 = 0x88EB;
        pub const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
        pub const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
        pub const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
        pub const POINT: u32 = 0x1B00;
        pub const POINTS: u32 = 0x0000;
        pub const POINT_BIT: u32 = 0x00000002;
        pub const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
        pub const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
        pub const POINT_SIZE: u32 = 0x0B11;
        pub const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const POINT_SIZE_MAX: u32 = 0x8127;
        pub const POINT_SIZE_MIN: u32 = 0x8126;
        pub const POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const POINT_SMOOTH: u32 = 0x0B10;
        pub const POINT_SMOOTH_HINT: u32 = 0x0C51;
        pub const POINT_SPRITE: u32 = 0x8861;
        pub const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
        pub const POINT_TOKEN: u32 = 0x0701;
        pub const POLYGON: u32 = 0x0009;
        pub const POLYGON_BIT: u32 = 0x00000008;
        pub const POLYGON_MODE: u32 = 0x0B40;
        pub const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
        pub const POLYGON_OFFSET_FILL: u32 = 0x8037;
        pub const POLYGON_OFFSET_LINE: u32 = 0x2A02;
        pub const POLYGON_OFFSET_POINT: u32 = 0x2A01;
        pub const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
        pub const POLYGON_SMOOTH: u32 = 0x0B41;
        pub const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
        pub const POLYGON_STIPPLE: u32 = 0x0B42;
        pub const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
        pub const POLYGON_TOKEN: u32 = 0x0703;
        pub const POSITION: u32 = 0x1203;
        pub const PREVIOUS: u32 = 0x8578;
        pub const PRIMARY_COLOR: u32 = 0x8577;
        pub const PRIMITIVES_GENERATED: u32 = 0x8C87;
        pub const PRIMITIVE_RESTART: u32 = 0x8F9D;
        pub const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
        pub const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
        pub const PROGRAM: u32 = 0x82E2;
        pub const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
        pub const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
        pub const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
        pub const PROGRAM_KHR: u32 = 0x82E2;
        pub const PROGRAM_PIPELINE: u32 = 0x82E4;
        pub const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
        pub const PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const PROJECTION: u32 = 0x1701;
        pub const PROJECTION_MATRIX: u32 = 0x0BA7;
        pub const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
        pub const PROVOKING_VERTEX: u32 = 0x8E4F;
        pub const PROXY_TEXTURE_1D: u32 = 0x8063;
        pub const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
        pub const PROXY_TEXTURE_2D: u32 = 0x8064;
        pub const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
        pub const PROXY_TEXTURE_3D: u32 = 0x8070;
        pub const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
        pub const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
        pub const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
        pub const Q: u32 = 0x2003;
        pub const QUADRATIC_ATTENUATION: u32 = 0x1209;
        pub const QUADS: u32 = 0x0007;
        pub const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
        pub const QUAD_STRIP: u32 = 0x0008;
        pub const QUERY: u32 = 0x82E3;
        pub const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
        pub const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
        pub const QUERY_COUNTER_BITS: u32 = 0x8864;
        pub const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
        pub const QUERY_KHR: u32 = 0x82E3;
        pub const QUERY_NO_WAIT: u32 = 0x8E14;
        pub const QUERY_RESULT: u32 = 0x8866;
        pub const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
        pub const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
        pub const QUERY_RESULT_EXT: u32 = 0x8866;
        pub const QUERY_WAIT: u32 = 0x8E13;
        pub const R: u32 = 0x2002;
        pub const R11F_G11F_B10F: u32 = 0x8C3A;
        pub const R16: u32 = 0x822A;
        pub const R16F: u32 = 0x822D;
        pub const R16F_EXT: u32 = 0x822D;
        pub const R16I: u32 = 0x8233;
        pub const R16UI: u32 = 0x8234;
        pub const R16_SNORM: u32 = 0x8F98;
        pub const R32F: u32 = 0x822E;
        pub const R32F_EXT: u32 = 0x822E;
        pub const R32I: u32 = 0x8235;
        pub const R32UI: u32 = 0x8236;
        pub const R3_G3_B2: u32 = 0x2A10;
        pub const R8: u32 = 0x8229;
        pub const R8I: u32 = 0x8231;
        pub const R8UI: u32 = 0x8232;
        pub const R8_EXT: u32 = 0x8229;
        pub const R8_SNORM: u32 = 0x8F94;
        pub const RASTERIZER_DISCARD: u32 = 0x8C89;
        pub const READ_BUFFER: u32 = 0x0C02;
        pub const READ_FRAMEBUFFER: u32 = 0x8CA8;
        pub const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
        pub const READ_ONLY: u32 = 0x88B8;
        pub const READ_WRITE: u32 = 0x88BA;
        pub const RED: u32 = 0x1903;
        pub const RED_BIAS: u32 = 0x0D15;
        pub const RED_BITS: u32 = 0x0D52;
        pub const RED_INTEGER: u32 = 0x8D94;
        pub const RED_SCALE: u32 = 0x0D14;
        pub const REFLECTION_MAP: u32 = 0x8512;
        pub const RENDER: u32 = 0x1C00;
        pub const RENDERBUFFER: u32 = 0x8D41;
        pub const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
        pub const RENDERBUFFER_BINDING: u32 = 0x8CA7;
        pub const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
        pub const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
        pub const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
        pub const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
        pub const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
        pub const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
        pub const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
        pub const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
        pub const RENDERBUFFER_WIDTH: u32 = 0x8D42;
        pub const RENDERER: u32 = 0x1F01;
        pub const RENDER_MODE: u32 = 0x0C40;
        pub const REPEAT: u32 = 0x2901;
        pub const REPLACE: u32 = 0x1E01;
        pub const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
        pub const RESCALE_NORMAL: u32 = 0x803A;
        pub const RETURN: u32 = 0x0102;
        pub const RG: u32 = 0x8227;
        pub const RG16: u32 = 0x822C;
        pub const RG16F: u32 = 0x822F;
        pub const RG16F_EXT: u32 = 0x822F;
        pub const RG16I: u32 = 0x8239;
        pub const RG16UI: u32 = 0x823A;
        pub const RG16_SNORM: u32 = 0x8F99;
        pub const RG32F: u32 = 0x8230;
        pub const RG32F_EXT: u32 = 0x8230;
        pub const RG32I: u32 = 0x823B;
        pub const RG32UI: u32 = 0x823C;
        pub const RG8: u32 = 0x822B;
        pub const RG8I: u32 = 0x8237;
        pub const RG8UI: u32 = 0x8238;
        pub const RG8_EXT: u32 = 0x822B;
        pub const RG8_SNORM: u32 = 0x8F95;
        pub const RGB: u32 = 0x1907;
        pub const RGB10: u32 = 0x8052;
        pub const RGB10_A2: u32 = 0x8059;
        pub const RGB10_A2UI: u32 = 0x906F;
        pub const RGB10_A2_EXT: u32 = 0x8059;
        pub const RGB10_EXT: u32 = 0x8052;
        pub const RGB12: u32 = 0x8053;
        pub const RGB16: u32 = 0x8054;
        pub const RGB16F: u32 = 0x881B;
        pub const RGB16F_EXT: u32 = 0x881B;
        pub const RGB16I: u32 = 0x8D89;
        pub const RGB16UI: u32 = 0x8D77;
        pub const RGB16_SNORM: u32 = 0x8F9A;
        pub const RGB32F: u32 = 0x8815;
        pub const RGB32F_EXT: u32 = 0x8815;
        pub const RGB32I: u32 = 0x8D83;
        pub const RGB32UI: u32 = 0x8D71;
        pub const RGB4: u32 = 0x804F;
        pub const RGB5: u32 = 0x8050;
        pub const RGB565: u32 = 0x8D62;
        pub const RGB5_A1: u32 = 0x8057;
        pub const RGB8: u32 = 0x8051;
        pub const RGB8I: u32 = 0x8D8F;
        pub const RGB8UI: u32 = 0x8D7D;
        pub const RGB8_SNORM: u32 = 0x8F96;
        pub const RGB9_E5: u32 = 0x8C3D;
        pub const RGBA: u32 = 0x1908;
        pub const RGBA12: u32 = 0x805A;
        pub const RGBA16: u32 = 0x805B;
        pub const RGBA16F: u32 = 0x881A;
        pub const RGBA16F_EXT: u32 = 0x881A;
        pub const RGBA16I: u32 = 0x8D88;
        pub const RGBA16UI: u32 = 0x8D76;
        pub const RGBA16_SNORM: u32 = 0x8F9B;
        pub const RGBA2: u32 = 0x8055;
        pub const RGBA32F: u32 = 0x8814;
        pub const RGBA32F_EXT: u32 = 0x8814;
        pub const RGBA32I: u32 = 0x8D82;
        pub const RGBA32UI: u32 = 0x8D70;
        pub const RGBA4: u32 = 0x8056;
        pub const RGBA8: u32 = 0x8058;
        pub const RGBA8I: u32 = 0x8D8E;
        pub const RGBA8UI: u32 = 0x8D7C;
        pub const RGBA8_SNORM: u32 = 0x8F97;
        pub const RGBA_INTEGER: u32 = 0x8D99;
        pub const RGBA_MODE: u32 = 0x0C31;
        pub const RGB_INTEGER: u32 = 0x8D98;
        pub const RGB_SCALE: u32 = 0x8573;
        pub const RG_INTEGER: u32 = 0x8228;
        pub const RIGHT: u32 = 0x0407;
        pub const S: u32 = 0x2000;
        pub const SAMPLER: u32 = 0x82E6;
        pub const SAMPLER_1D: u32 = 0x8B5D;
        pub const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
        pub const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
        pub const SAMPLER_1D_SHADOW: u32 = 0x8B61;
        pub const SAMPLER_2D: u32 = 0x8B5E;
        pub const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
        pub const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
        pub const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
        pub const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
        pub const SAMPLER_2D_RECT: u32 = 0x8B63;
        pub const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
        pub const SAMPLER_2D_SHADOW: u32 = 0x8B62;
        pub const SAMPLER_3D: u32 = 0x8B5F;
        pub const SAMPLER_BINDING: u32 = 0x8919;
        pub const SAMPLER_BUFFER: u32 = 0x8DC2;
        pub const SAMPLER_CUBE: u32 = 0x8B60;
        pub const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
        pub const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
        pub const SAMPLER_KHR: u32 = 0x82E6;
        pub const SAMPLES: u32 = 0x80A9;
        pub const SAMPLES_PASSED: u32 = 0x8914;
        pub const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
        pub const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
        pub const SAMPLE_BUFFERS: u32 = 0x80A8;
        pub const SAMPLE_COVERAGE: u32 = 0x80A0;
        pub const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
        pub const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
        pub const SAMPLE_MASK: u32 = 0x8E51;
        pub const SAMPLE_MASK_VALUE: u32 = 0x8E52;
        pub const SAMPLE_POSITION: u32 = 0x8E50;
        pub const SCISSOR_BIT: u32 = 0x00080000;
        pub const SCISSOR_BOX: u32 = 0x0C10;
        pub const SCISSOR_TEST: u32 = 0x0C11;
        pub const SCREEN_KHR: u32 = 0x9295;
        pub const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
        pub const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
        pub const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
        pub const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
        pub const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
        pub const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
        pub const SELECT: u32 = 0x1C02;
        pub const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
        pub const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
        pub const SEPARATE_ATTRIBS: u32 = 0x8C8D;
        pub const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
        pub const SET: u32 = 0x150F;
        pub const SHADER: u32 = 0x82E1;
        pub const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
        pub const SHADER_COMPILER: u32 = 0x8DFA;
        pub const SHADER_KHR: u32 = 0x82E1;
        pub const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
        pub const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
        pub const SHADER_TYPE: u32 = 0x8B4F;
        pub const SHADE_MODEL: u32 = 0x0B54;
        pub const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
        pub const SHININESS: u32 = 0x1601;
        pub const SHORT: u32 = 0x1402;
        pub const SIGNALED: u32 = 0x9119;
        pub const SIGNED_NORMALIZED: u32 = 0x8F9C;
        pub const SINGLE_COLOR: u32 = 0x81F9;
        pub const SLUMINANCE: u32 = 0x8C46;
        pub const SLUMINANCE8: u32 = 0x8C47;
        pub const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
        pub const SLUMINANCE_ALPHA: u32 = 0x8C44;
        pub const SMOOTH: u32 = 0x1D01;
        pub const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const SOFTLIGHT_KHR: u32 = 0x929C;
        pub const SOURCE0_ALPHA: u32 = 0x8588;
        pub const SOURCE0_RGB: u32 = 0x8580;
        pub const SOURCE1_ALPHA: u32 = 0x8589;
        pub const SOURCE1_RGB: u32 = 0x8581;
        pub const SOURCE2_ALPHA: u32 = 0x858A;
        pub const SOURCE2_RGB: u32 = 0x8582;
        pub const SPECULAR: u32 = 0x1202;
        pub const SPHERE_MAP: u32 = 0x2402;
        pub const SPOT_CUTOFF: u32 = 0x1206;
        pub const SPOT_DIRECTION: u32 = 0x1204;
        pub const SPOT_EXPONENT: u32 = 0x1205;
        pub const SRC0_ALPHA: u32 = 0x8588;
        pub const SRC0_RGB: u32 = 0x8580;
        pub const SRC1_ALPHA: u32 = 0x8589;
        pub const SRC1_COLOR: u32 = 0x88F9;
        pub const SRC1_RGB: u32 = 0x8581;
        pub const SRC2_ALPHA: u32 = 0x858A;
        pub const SRC2_RGB: u32 = 0x8582;
        pub const SRC_ALPHA: u32 = 0x0302;
        pub const SRC_ALPHA_SATURATE: u32 = 0x0308;
        pub const SRC_COLOR: u32 = 0x0300;
        pub const SRGB: u32 = 0x8C40;
        pub const SRGB8: u32 = 0x8C41;
        pub const SRGB8_ALPHA8: u32 = 0x8C43;
        pub const SRGB_ALPHA: u32 = 0x8C42;
        pub const STACK_OVERFLOW: u32 = 0x0503;
        pub const STACK_OVERFLOW_KHR: u32 = 0x0503;
        pub const STACK_UNDERFLOW: u32 = 0x0504;
        pub const STACK_UNDERFLOW_KHR: u32 = 0x0504;
        pub const STATIC_COPY: u32 = 0x88E6;
        pub const STATIC_DRAW: u32 = 0x88E4;
        pub const STATIC_READ: u32 = 0x88E5;
        pub const STENCIL: u32 = 0x1802;
        pub const STENCIL_ATTACHMENT: u32 = 0x8D20;
        pub const STENCIL_BACK_FAIL: u32 = 0x8801;
        pub const STENCIL_BACK_FUNC: u32 = 0x8800;
        pub const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
        pub const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
        pub const STENCIL_BACK_REF: u32 = 0x8CA3;
        pub const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
        pub const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
        pub const STENCIL_BITS: u32 = 0x0D57;
        pub const STENCIL_BUFFER_BIT: u32 = 0x00000400;
        pub const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
        pub const STENCIL_FAIL: u32 = 0x0B94;
        pub const STENCIL_FUNC: u32 = 0x0B92;
        pub const STENCIL_INDEX: u32 = 0x1901;
        pub const STENCIL_INDEX1: u32 = 0x8D46;
        pub const STENCIL_INDEX16: u32 = 0x8D49;
        pub const STENCIL_INDEX4: u32 = 0x8D47;
        pub const STENCIL_INDEX8: u32 = 0x8D48;
        pub const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
        pub const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
        pub const STENCIL_REF: u32 = 0x0B97;
        pub const STENCIL_TEST: u32 = 0x0B90;
        pub const STENCIL_VALUE_MASK: u32 = 0x0B93;
        pub const STENCIL_WRITEMASK: u32 = 0x0B98;
        pub const STEREO: u32 = 0x0C33;
        pub const STORAGE_CACHED_APPLE: u32 = 0x85BE;
        pub const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
        pub const STORAGE_SHARED_APPLE: u32 = 0x85BF;
        pub const STREAM_COPY: u32 = 0x88E2;
        pub const STREAM_DRAW: u32 = 0x88E0;
        pub const STREAM_READ: u32 = 0x88E1;
        pub const SUBPIXEL_BITS: u32 = 0x0D50;
        pub const SUBTRACT: u32 = 0x84E7;
        pub const SYNC_CONDITION: u32 = 0x9113;
        pub const SYNC_FENCE: u32 = 0x9116;
        pub const SYNC_FLAGS: u32 = 0x9115;
        pub const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
        pub const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
        pub const SYNC_STATUS: u32 = 0x9114;
        pub const T: u32 = 0x2001;
        pub const T2F_C3F_V3F: u32 = 0x2A2A;
        pub const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
        pub const T2F_C4UB_V3F: u32 = 0x2A29;
        pub const T2F_N3F_V3F: u32 = 0x2A2B;
        pub const T2F_V3F: u32 = 0x2A27;
        pub const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
        pub const T4F_V4F: u32 = 0x2A28;
        pub const TEXTURE: u32 = 0x1702;
        pub const TEXTURE0: u32 = 0x84C0;
        pub const TEXTURE1: u32 = 0x84C1;
        pub const TEXTURE10: u32 = 0x84CA;
        pub const TEXTURE11: u32 = 0x84CB;
        pub const TEXTURE12: u32 = 0x84CC;
        pub const TEXTURE13: u32 = 0x84CD;
        pub const TEXTURE14: u32 = 0x84CE;
        pub const TEXTURE15: u32 = 0x84CF;
        pub const TEXTURE16: u32 = 0x84D0;
        pub const TEXTURE17: u32 = 0x84D1;
        pub const TEXTURE18: u32 = 0x84D2;
        pub const TEXTURE19: u32 = 0x84D3;
        pub const TEXTURE2: u32 = 0x84C2;
        pub const TEXTURE20: u32 = 0x84D4;
        pub const TEXTURE21: u32 = 0x84D5;
        pub const TEXTURE22: u32 = 0x84D6;
        pub const TEXTURE23: u32 = 0x84D7;
        pub const TEXTURE24: u32 = 0x84D8;
        pub const TEXTURE25: u32 = 0x84D9;
        pub const TEXTURE26: u32 = 0x84DA;
        pub const TEXTURE27: u32 = 0x84DB;
        pub const TEXTURE28: u32 = 0x84DC;
        pub const TEXTURE29: u32 = 0x84DD;
        pub const TEXTURE3: u32 = 0x84C3;
        pub const TEXTURE30: u32 = 0x84DE;
        pub const TEXTURE31: u32 = 0x84DF;
        pub const TEXTURE4: u32 = 0x84C4;
        pub const TEXTURE5: u32 = 0x84C5;
        pub const TEXTURE6: u32 = 0x84C6;
        pub const TEXTURE7: u32 = 0x84C7;
        pub const TEXTURE8: u32 = 0x84C8;
        pub const TEXTURE9: u32 = 0x84C9;
        pub const TEXTURE_1D: u32 = 0x0DE0;
        pub const TEXTURE_1D_ARRAY: u32 = 0x8C18;
        pub const TEXTURE_2D: u32 = 0x0DE1;
        pub const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
        pub const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
        pub const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
        pub const TEXTURE_3D: u32 = 0x806F;
        pub const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
        pub const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
        pub const TEXTURE_BASE_LEVEL: u32 = 0x813C;
        pub const TEXTURE_BINDING_1D: u32 = 0x8068;
        pub const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
        pub const TEXTURE_BINDING_2D: u32 = 0x8069;
        pub const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
        pub const TEXTURE_BINDING_3D: u32 = 0x806A;
        pub const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
        pub const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
        pub const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
        pub const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
        pub const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
        pub const TEXTURE_BIT: u32 = 0x00040000;
        pub const TEXTURE_BLUE_SIZE: u32 = 0x805E;
        pub const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
        pub const TEXTURE_BORDER: u32 = 0x1005;
        pub const TEXTURE_BORDER_COLOR: u32 = 0x1004;
        pub const TEXTURE_BUFFER: u32 = 0x8C2A;
        pub const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
        pub const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
        pub const TEXTURE_COMPARE_MODE: u32 = 0x884C;
        pub const TEXTURE_COMPONENTS: u32 = 0x1003;
        pub const TEXTURE_COMPRESSED: u32 = 0x86A1;
        pub const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
        pub const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
        pub const TEXTURE_COORD_ARRAY: u32 = 0x8078;
        pub const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
        pub const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
        pub const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
        pub const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
        pub const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
        pub const TEXTURE_CUBE_MAP: u32 = 0x8513;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
        pub const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
        pub const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
        pub const TEXTURE_DEPTH: u32 = 0x8071;
        pub const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
        pub const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
        pub const TEXTURE_ENV: u32 = 0x2300;
        pub const TEXTURE_ENV_COLOR: u32 = 0x2201;
        pub const TEXTURE_ENV_MODE: u32 = 0x2200;
        pub const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
        pub const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
        pub const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
        pub const TEXTURE_GEN_MODE: u32 = 0x2500;
        pub const TEXTURE_GEN_Q: u32 = 0x0C63;
        pub const TEXTURE_GEN_R: u32 = 0x0C62;
        pub const TEXTURE_GEN_S: u32 = 0x0C60;
        pub const TEXTURE_GEN_T: u32 = 0x0C61;
        pub const TEXTURE_GREEN_SIZE: u32 = 0x805D;
        pub const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
        pub const TEXTURE_HEIGHT: u32 = 0x1001;
        pub const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
        pub const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
        pub const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
        pub const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
        pub const TEXTURE_LOD_BIAS: u32 = 0x8501;
        pub const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
        pub const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
        pub const TEXTURE_MAG_FILTER: u32 = 0x2800;
        pub const TEXTURE_MATRIX: u32 = 0x0BA8;
        pub const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
        pub const TEXTURE_MAX_LEVEL: u32 = 0x813D;
        pub const TEXTURE_MAX_LOD: u32 = 0x813B;
        pub const TEXTURE_MIN_FILTER: u32 = 0x2801;
        pub const TEXTURE_MIN_LOD: u32 = 0x813A;
        pub const TEXTURE_PRIORITY: u32 = 0x8066;
        pub const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
        pub const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
        pub const TEXTURE_RECTANGLE: u32 = 0x84F5;
        pub const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
        pub const TEXTURE_RED_SIZE: u32 = 0x805C;
        pub const TEXTURE_RED_TYPE: u32 = 0x8C10;
        pub const TEXTURE_RESIDENT: u32 = 0x8067;
        pub const TEXTURE_SAMPLES: u32 = 0x9106;
        pub const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
        pub const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
        pub const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
        pub const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
        pub const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
        pub const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
        pub const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
        pub const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
        pub const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
        pub const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
        pub const TEXTURE_WIDTH: u32 = 0x1000;
        pub const TEXTURE_WRAP_R: u32 = 0x8072;
        pub const TEXTURE_WRAP_S: u32 = 0x2802;
        pub const TEXTURE_WRAP_T: u32 = 0x2803;
        pub const TIMEOUT_EXPIRED: u32 = 0x911B;
        pub const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
        pub const TIMESTAMP: u32 = 0x8E28;
        pub const TIMESTAMP_EXT: u32 = 0x8E28;
        pub const TIME_ELAPSED: u32 = 0x88BF;
        pub const TIME_ELAPSED_EXT: u32 = 0x88BF;
        pub const TRANSFORM_BIT: u32 = 0x00001000;
        pub const TRANSFORM_FEEDBACK: u32 = 0x8E22;
        pub const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
        pub const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
        pub const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
        pub const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
        pub const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
        pub const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
        pub const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
        pub const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
        pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
        pub const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
        pub const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
        pub const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
        pub const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
        pub const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
        pub const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
        pub const TRIANGLES: u32 = 0x0004;
        pub const TRIANGLES_ADJACENCY: u32 = 0x000C;
        pub const TRIANGLE_FAN: u32 = 0x0006;
        pub const TRIANGLE_STRIP: u32 = 0x0005;
        pub const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
        pub const TRUE: u8 = 1;
        pub const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
        pub const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
        pub const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
        pub const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
        pub const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
        pub const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
        pub const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
        pub const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
        pub const UNIFORM_BUFFER: u32 = 0x8A11;
        pub const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
        pub const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
        pub const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
        pub const UNIFORM_BUFFER_START: u32 = 0x8A29;
        pub const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
        pub const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
        pub const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
        pub const UNIFORM_OFFSET: u32 = 0x8A3B;
        pub const UNIFORM_SIZE: u32 = 0x8A38;
        pub const UNIFORM_TYPE: u32 = 0x8A37;
        pub const UNPACK_ALIGNMENT: u32 = 0x0CF5;
        pub const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
        pub const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
        pub const UNPACK_LSB_FIRST: u32 = 0x0CF1;
        pub const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
        pub const UNPACK_SKIP_IMAGES: u32 = 0x806D;
        pub const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
        pub const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
        pub const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
        pub const UNSIGNALED: u32 = 0x9118;
        pub const UNSIGNED_BYTE: u32 = 0x1401;
        pub const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
        pub const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
        pub const UNSIGNED_INT: u32 = 0x1405;
        pub const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
        pub const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
        pub const UNSIGNED_INT_24_8: u32 = 0x84FA;
        pub const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
        pub const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
        pub const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
        pub const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
        pub const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
        pub const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
        pub const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
        pub const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
        pub const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
        pub const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
        pub const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
        pub const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
        pub const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
        pub const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
        pub const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
        pub const UNSIGNED_NORMALIZED: u32 = 0x8C17;
        pub const UNSIGNED_SHORT: u32 = 0x1403;
        pub const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
        pub const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
        pub const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
        pub const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
        pub const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
        pub const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
        pub const UPPER_LEFT: u32 = 0x8CA2;
        pub const V2F: u32 = 0x2A20;
        pub const V3F: u32 = 0x2A21;
        pub const VALIDATE_STATUS: u32 = 0x8B83;
        pub const VENDOR: u32 = 0x1F00;
        pub const VERSION: u32 = 0x1F02;
        pub const VERTEX_ARRAY: u32 = 0x8074;
        pub const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
        pub const VERTEX_ARRAY_KHR: u32 = 0x8074;
        pub const VERTEX_ARRAY_POINTER: u32 = 0x808E;
        pub const VERTEX_ARRAY_SIZE: u32 = 0x807A;
        pub const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
        pub const VERTEX_ARRAY_TYPE: u32 = 0x807B;
        pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
        pub const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
        pub const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
        pub const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
        pub const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
        pub const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
        pub const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
        pub const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
        pub const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
        pub const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
        pub const VERTEX_SHADER: u32 = 0x8B31;
        pub const VIEWPORT: u32 = 0x0BA2;
        pub const VIEWPORT_BIT: u32 = 0x00000800;
        pub const WAIT_FAILED: u32 = 0x911D;
        pub const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
        pub const WRITE_ONLY: u32 = 0x88B9;
        pub const XOR: u32 = 0x1506;
        pub const ZERO: u32 = 0;
        pub const ZOOM_X: u32 = 0x0D16;
        pub const ZOOM_Y: u32 = 0x0D17;

        /// Calls the `Gl::get_type` function.
        pub fn get_type(&self)  -> crate::gl::GlType { unsafe { crate::dll::AzGl_getType(self) } }
        /// Calls the `Gl::buffer_data_untyped` function.
        pub fn buffer_data_untyped(&self, target: u32, size: isize, data: GlVoidPtrConst, usage: u32)  { unsafe { crate::dll::AzGl_bufferDataUntyped(self, target, size, data, usage) } }
        /// Calls the `Gl::buffer_sub_data_untyped` function.
        pub fn buffer_sub_data_untyped(&self, target: u32, offset: isize, size: isize, data: GlVoidPtrConst)  { unsafe { crate::dll::AzGl_bufferSubDataUntyped(self, target, offset, size, data) } }
        /// Calls the `Gl::map_buffer` function.
        pub fn map_buffer(&self, target: u32, access: u32)  -> crate::gl::GlVoidPtrMut { unsafe { crate::dll::AzGl_mapBuffer(self, target, access) } }
        /// Calls the `Gl::map_buffer_range` function.
        pub fn map_buffer_range(&self, target: u32, offset: isize, length: isize, access: u32)  -> crate::gl::GlVoidPtrMut { unsafe { crate::dll::AzGl_mapBufferRange(self, target, offset, length, access) } }
        /// Calls the `Gl::unmap_buffer` function.
        pub fn unmap_buffer(&self, target: u32)  -> u8 { unsafe { crate::dll::AzGl_unmapBuffer(self, target) } }
        /// Calls the `Gl::tex_buffer` function.
        pub fn tex_buffer(&self, target: u32, internal_format: u32, buffer: u32)  { unsafe { crate::dll::AzGl_texBuffer(self, target, internal_format, buffer) } }
        /// Calls the `Gl::shader_source` function.
        pub fn shader_source(&self, shader: u32, strings: StringVec)  { unsafe { crate::dll::AzGl_shaderSource(self, shader, strings) } }
        /// Calls the `Gl::read_buffer` function.
        pub fn read_buffer(&self, mode: u32)  { unsafe { crate::dll::AzGl_readBuffer(self, mode) } }
        /// Calls the `Gl::read_pixels_into_buffer` function.
        pub fn read_pixels_into_buffer(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32, dst_buffer: U8VecRefMut)  { unsafe { crate::dll::AzGl_readPixelsIntoBuffer(self, x, y, width, height, format, pixel_type, dst_buffer) } }
        /// Calls the `Gl::read_pixels` function.
        pub fn read_pixels(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32)  -> crate::vec::U8Vec { unsafe { crate::dll::AzGl_readPixels(self, x, y, width, height, format, pixel_type) } }
        /// Calls the `Gl::read_pixels_into_pbo` function.
        pub fn read_pixels_into_pbo(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32)  { unsafe { crate::dll::AzGl_readPixelsIntoPbo(self, x, y, width, height, format, pixel_type) } }
        /// Calls the `Gl::sample_coverage` function.
        pub fn sample_coverage(&self, value: f32, invert: bool)  { unsafe { crate::dll::AzGl_sampleCoverage(self, value, invert) } }
        /// Calls the `Gl::polygon_offset` function.
        pub fn polygon_offset(&self, factor: f32, units: f32)  { unsafe { crate::dll::AzGl_polygonOffset(self, factor, units) } }
        /// Calls the `Gl::pixel_store_i` function.
        pub fn pixel_store_i(&self, name: u32, param: i32)  { unsafe { crate::dll::AzGl_pixelStoreI(self, name, param) } }
        /// Calls the `Gl::gen_buffers` function.
        pub fn gen_buffers(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genBuffers(self, n) } }
        /// Calls the `Gl::gen_renderbuffers` function.
        pub fn gen_renderbuffers(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genRenderbuffers(self, n) } }
        /// Calls the `Gl::gen_framebuffers` function.
        pub fn gen_framebuffers(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genFramebuffers(self, n) } }
        /// Calls the `Gl::gen_textures` function.
        pub fn gen_textures(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genTextures(self, n) } }
        /// Calls the `Gl::gen_vertex_arrays` function.
        pub fn gen_vertex_arrays(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genVertexArrays(self, n) } }
        /// Calls the `Gl::gen_queries` function.
        pub fn gen_queries(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genQueries(self, n) } }
        /// Calls the `Gl::begin_query` function.
        pub fn begin_query(&self, target: u32, id: u32)  { unsafe { crate::dll::AzGl_beginQuery(self, target, id) } }
        /// Calls the `Gl::end_query` function.
        pub fn end_query(&self, target: u32)  { unsafe { crate::dll::AzGl_endQuery(self, target) } }
        /// Calls the `Gl::query_counter` function.
        pub fn query_counter(&self, id: u32, target: u32)  { unsafe { crate::dll::AzGl_queryCounter(self, id, target) } }
        /// Calls the `Gl::get_query_object_iv` function.
        pub fn get_query_object_iv(&self, id: u32, pname: u32)  -> i32 { unsafe { crate::dll::AzGl_getQueryObjectIv(self, id, pname) } }
        /// Calls the `Gl::get_query_object_uiv` function.
        pub fn get_query_object_uiv(&self, id: u32, pname: u32)  -> u32 { unsafe { crate::dll::AzGl_getQueryObjectUiv(self, id, pname) } }
        /// Calls the `Gl::get_query_object_i64v` function.
        pub fn get_query_object_i64v(&self, id: u32, pname: u32)  -> i64 { unsafe { crate::dll::AzGl_getQueryObjectI64V(self, id, pname) } }
        /// Calls the `Gl::get_query_object_ui64v` function.
        pub fn get_query_object_ui64v(&self, id: u32, pname: u32)  -> u64 { unsafe { crate::dll::AzGl_getQueryObjectUi64V(self, id, pname) } }
        /// Calls the `Gl::delete_queries` function.
        pub fn delete_queries(&self, queries: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteQueries(self, queries) } }
        /// Calls the `Gl::delete_vertex_arrays` function.
        pub fn delete_vertex_arrays(&self, vertex_arrays: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteVertexArrays(self, vertex_arrays) } }
        /// Calls the `Gl::delete_buffers` function.
        pub fn delete_buffers(&self, buffers: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteBuffers(self, buffers) } }
        /// Calls the `Gl::delete_renderbuffers` function.
        pub fn delete_renderbuffers(&self, renderbuffers: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteRenderbuffers(self, renderbuffers) } }
        /// Calls the `Gl::delete_framebuffers` function.
        pub fn delete_framebuffers(&self, framebuffers: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteFramebuffers(self, framebuffers) } }
        /// Calls the `Gl::delete_textures` function.
        pub fn delete_textures(&self, textures: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteTextures(self, textures) } }
        /// Calls the `Gl::framebuffer_renderbuffer` function.
        pub fn framebuffer_renderbuffer(&self, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32)  { unsafe { crate::dll::AzGl_framebufferRenderbuffer(self, target, attachment, renderbuffertarget, renderbuffer) } }
        /// Calls the `Gl::renderbuffer_storage` function.
        pub fn renderbuffer_storage(&self, target: u32, internalformat: u32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_renderbufferStorage(self, target, internalformat, width, height) } }
        /// Calls the `Gl::depth_func` function.
        pub fn depth_func(&self, func: u32)  { unsafe { crate::dll::AzGl_depthFunc(self, func) } }
        /// Calls the `Gl::active_texture` function.
        pub fn active_texture(&self, texture: u32)  { unsafe { crate::dll::AzGl_activeTexture(self, texture) } }
        /// Calls the `Gl::attach_shader` function.
        pub fn attach_shader(&self, program: u32, shader: u32)  { unsafe { crate::dll::AzGl_attachShader(self, program, shader) } }
        /// Calls the `Gl::bind_attrib_location` function.
        pub fn bind_attrib_location(&self, program: u32, index: u32, name: Refstr)  { unsafe { crate::dll::AzGl_bindAttribLocation(self, program, index, name) } }
        /// Calls the `Gl::get_uniform_iv` function.
        pub fn get_uniform_iv(&self, program: u32, location: i32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getUniformIv(self, program, location, result) } }
        /// Calls the `Gl::get_uniform_fv` function.
        pub fn get_uniform_fv(&self, program: u32, location: i32, result: GLfloatVecRefMut)  { unsafe { crate::dll::AzGl_getUniformFv(self, program, location, result) } }
        /// Calls the `Gl::get_uniform_block_index` function.
        pub fn get_uniform_block_index(&self, program: u32, name: Refstr)  -> u32 { unsafe { crate::dll::AzGl_getUniformBlockIndex(self, program, name) } }
        /// Calls the `Gl::get_uniform_indices` function.
        pub fn get_uniform_indices(&self, program: u32, names: RefstrVecRef)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_getUniformIndices(self, program, names) } }
        /// Calls the `Gl::bind_buffer_base` function.
        pub fn bind_buffer_base(&self, target: u32, index: u32, buffer: u32)  { unsafe { crate::dll::AzGl_bindBufferBase(self, target, index, buffer) } }
        /// Calls the `Gl::bind_buffer_range` function.
        pub fn bind_buffer_range(&self, target: u32, index: u32, buffer: u32, offset: isize, size: isize)  { unsafe { crate::dll::AzGl_bindBufferRange(self, target, index, buffer, offset, size) } }
        /// Calls the `Gl::uniform_block_binding` function.
        pub fn uniform_block_binding(&self, program: u32, uniform_block_index: u32, uniform_block_binding: u32)  { unsafe { crate::dll::AzGl_uniformBlockBinding(self, program, uniform_block_index, uniform_block_binding) } }
        /// Calls the `Gl::bind_buffer` function.
        pub fn bind_buffer(&self, target: u32, buffer: u32)  { unsafe { crate::dll::AzGl_bindBuffer(self, target, buffer) } }
        /// Calls the `Gl::bind_vertex_array` function.
        pub fn bind_vertex_array(&self, vao: u32)  { unsafe { crate::dll::AzGl_bindVertexArray(self, vao) } }
        /// Calls the `Gl::bind_renderbuffer` function.
        pub fn bind_renderbuffer(&self, target: u32, renderbuffer: u32)  { unsafe { crate::dll::AzGl_bindRenderbuffer(self, target, renderbuffer) } }
        /// Calls the `Gl::bind_framebuffer` function.
        pub fn bind_framebuffer(&self, target: u32, framebuffer: u32)  { unsafe { crate::dll::AzGl_bindFramebuffer(self, target, framebuffer) } }
        /// Calls the `Gl::bind_texture` function.
        pub fn bind_texture(&self, target: u32, texture: u32)  { unsafe { crate::dll::AzGl_bindTexture(self, target, texture) } }
        /// Calls the `Gl::draw_buffers` function.
        pub fn draw_buffers(&self, bufs: GLenumVecRef)  { unsafe { crate::dll::AzGl_drawBuffers(self, bufs) } }
        /// Calls the `Gl::tex_image_2d` function.
        pub fn tex_image_2d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, border: i32, format: u32, ty: u32, opt_data: OptionU8VecRef)  { unsafe { crate::dll::AzGl_texImage2D(self, target, level, internal_format, width, height, border, format, ty, opt_data) } }
        /// Calls the `Gl::compressed_tex_image_2d` function.
        pub fn compressed_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, width: i32, height: i32, border: i32, data: U8VecRef)  { unsafe { crate::dll::AzGl_compressedTexImage2D(self, target, level, internal_format, width, height, border, data) } }
        /// Calls the `Gl::compressed_tex_sub_image_2d` function.
        pub fn compressed_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: U8VecRef)  { unsafe { crate::dll::AzGl_compressedTexSubImage2D(self, target, level, xoffset, yoffset, width, height, format, data) } }
        /// Calls the `Gl::tex_image_3d` function.
        pub fn tex_image_3d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, ty: u32, opt_data: OptionU8VecRef)  { unsafe { crate::dll::AzGl_texImage3D(self, target, level, internal_format, width, height, depth, border, format, ty, opt_data) } }
        /// Calls the `Gl::copy_tex_image_2d` function.
        pub fn copy_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, x: i32, y: i32, width: i32, height: i32, border: i32)  { unsafe { crate::dll::AzGl_copyTexImage2D(self, target, level, internal_format, x, y, width, height, border) } }
        /// Calls the `Gl::copy_tex_sub_image_2d` function.
        pub fn copy_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_copyTexSubImage2D(self, target, level, xoffset, yoffset, x, y, width, height) } }
        /// Calls the `Gl::copy_tex_sub_image_3d` function.
        pub fn copy_tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_copyTexSubImage3D(self, target, level, xoffset, yoffset, zoffset, x, y, width, height) } }
        /// Calls the `Gl::tex_sub_image_2d` function.
        pub fn tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, data: U8VecRef)  { unsafe { crate::dll::AzGl_texSubImage2D(self, target, level, xoffset, yoffset, width, height, format, ty, data) } }
        /// Calls the `Gl::tex_sub_image_2d_pbo` function.
        pub fn tex_sub_image_2d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, offset: usize)  { unsafe { crate::dll::AzGl_texSubImage2DPbo(self, target, level, xoffset, yoffset, width, height, format, ty, offset) } }
        /// Calls the `Gl::tex_sub_image_3d` function.
        pub fn tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, data: U8VecRef)  { unsafe { crate::dll::AzGl_texSubImage3D(self, target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, data) } }
        /// Calls the `Gl::tex_sub_image_3d_pbo` function.
        pub fn tex_sub_image_3d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, offset: usize)  { unsafe { crate::dll::AzGl_texSubImage3DPbo(self, target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, offset) } }
        /// Calls the `Gl::tex_storage_2d` function.
        pub fn tex_storage_2d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_texStorage2D(self, target, levels, internal_format, width, height) } }
        /// Calls the `Gl::tex_storage_3d` function.
        pub fn tex_storage_3d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32, depth: i32)  { unsafe { crate::dll::AzGl_texStorage3D(self, target, levels, internal_format, width, height, depth) } }
        /// Calls the `Gl::get_tex_image_into_buffer` function.
        pub fn get_tex_image_into_buffer(&self, target: u32, level: i32, format: u32, ty: u32, output: U8VecRefMut)  { unsafe { crate::dll::AzGl_getTexImageIntoBuffer(self, target, level, format, ty, output) } }
        /// Calls the `Gl::copy_image_sub_data` function.
        pub fn copy_image_sub_data(&self, src_name: u32, src_target: u32, src_level: i32, src_x: i32, src_y: i32, src_z: i32, dst_name: u32, dst_target: u32, dst_level: i32, dst_x: i32, dst_y: i32, dst_z: i32, src_width: i32, src_height: i32, src_depth: i32)  { unsafe { crate::dll::AzGl_copyImageSubData(self, src_name, src_target, src_level, src_x, src_y, src_z, dst_name, dst_target, dst_level, dst_x, dst_y, dst_z, src_width, src_height, src_depth) } }
        /// Calls the `Gl::invalidate_framebuffer` function.
        pub fn invalidate_framebuffer(&self, target: u32, attachments: GLenumVecRef)  { unsafe { crate::dll::AzGl_invalidateFramebuffer(self, target, attachments) } }
        /// Calls the `Gl::invalidate_sub_framebuffer` function.
        pub fn invalidate_sub_framebuffer(&self, target: u32, attachments: GLenumVecRef, xoffset: i32, yoffset: i32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_invalidateSubFramebuffer(self, target, attachments, xoffset, yoffset, width, height) } }
        /// Calls the `Gl::get_integer_v` function.
        pub fn get_integer_v(&self, name: u32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getIntegerV(self, name, result) } }
        /// Calls the `Gl::get_integer_64v` function.
        pub fn get_integer_64v(&self, name: u32, result: GLint64VecRefMut)  { unsafe { crate::dll::AzGl_getInteger64V(self, name, result) } }
        /// Calls the `Gl::get_integer_iv` function.
        pub fn get_integer_iv(&self, name: u32, index: u32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getIntegerIv(self, name, index, result) } }
        /// Calls the `Gl::get_integer_64iv` function.
        pub fn get_integer_64iv(&self, name: u32, index: u32, result: GLint64VecRefMut)  { unsafe { crate::dll::AzGl_getInteger64Iv(self, name, index, result) } }
        /// Calls the `Gl::get_boolean_v` function.
        pub fn get_boolean_v(&self, name: u32, result: GLbooleanVecRefMut)  { unsafe { crate::dll::AzGl_getBooleanV(self, name, result) } }
        /// Calls the `Gl::get_float_v` function.
        pub fn get_float_v(&self, name: u32, result: GLfloatVecRefMut)  { unsafe { crate::dll::AzGl_getFloatV(self, name, result) } }
        /// Calls the `Gl::get_framebuffer_attachment_parameter_iv` function.
        pub fn get_framebuffer_attachment_parameter_iv(&self, target: u32, attachment: u32, pname: u32)  -> i32 { unsafe { crate::dll::AzGl_getFramebufferAttachmentParameterIv(self, target, attachment, pname) } }
        /// Calls the `Gl::get_renderbuffer_parameter_iv` function.
        pub fn get_renderbuffer_parameter_iv(&self, target: u32, pname: u32)  -> i32 { unsafe { crate::dll::AzGl_getRenderbufferParameterIv(self, target, pname) } }
        /// Calls the `Gl::get_tex_parameter_iv` function.
        pub fn get_tex_parameter_iv(&self, target: u32, name: u32)  -> i32 { unsafe { crate::dll::AzGl_getTexParameterIv(self, target, name) } }
        /// Calls the `Gl::get_tex_parameter_fv` function.
        pub fn get_tex_parameter_fv(&self, target: u32, name: u32)  -> f32 { unsafe { crate::dll::AzGl_getTexParameterFv(self, target, name) } }
        /// Calls the `Gl::tex_parameter_i` function.
        pub fn tex_parameter_i(&self, target: u32, pname: u32, param: i32)  { unsafe { crate::dll::AzGl_texParameterI(self, target, pname, param) } }
        /// Calls the `Gl::tex_parameter_f` function.
        pub fn tex_parameter_f(&self, target: u32, pname: u32, param: f32)  { unsafe { crate::dll::AzGl_texParameterF(self, target, pname, param) } }
        /// Calls the `Gl::framebuffer_texture_2d` function.
        pub fn framebuffer_texture_2d(&self, target: u32, attachment: u32, textarget: u32, texture: u32, level: i32)  { unsafe { crate::dll::AzGl_framebufferTexture2D(self, target, attachment, textarget, texture, level) } }
        /// Calls the `Gl::framebuffer_texture_layer` function.
        pub fn framebuffer_texture_layer(&self, target: u32, attachment: u32, texture: u32, level: i32, layer: i32)  { unsafe { crate::dll::AzGl_framebufferTextureLayer(self, target, attachment, texture, level, layer) } }
        /// Calls the `Gl::blit_framebuffer` function.
        pub fn blit_framebuffer(&self, src_x0: i32, src_y0: i32, src_x1: i32, src_y1: i32, dst_x0: i32, dst_y0: i32, dst_x1: i32, dst_y1: i32, mask: u32, filter: u32)  { unsafe { crate::dll::AzGl_blitFramebuffer(self, src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask, filter) } }
        /// Calls the `Gl::vertex_attrib_4f` function.
        pub fn vertex_attrib_4f(&self, index: u32, x: f32, y: f32, z: f32, w: f32)  { unsafe { crate::dll::AzGl_vertexAttrib4F(self, index, x, y, z, w) } }
        /// Calls the `Gl::vertex_attrib_pointer_f32` function.
        pub fn vertex_attrib_pointer_f32(&self, index: u32, size: i32, normalized: bool, stride: i32, offset: u32)  { unsafe { crate::dll::AzGl_vertexAttribPointerF32(self, index, size, normalized, stride, offset) } }
        /// Calls the `Gl::vertex_attrib_pointer` function.
        pub fn vertex_attrib_pointer(&self, index: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: u32)  { unsafe { crate::dll::AzGl_vertexAttribPointer(self, index, size, type_, normalized, stride, offset) } }
        /// Calls the `Gl::vertex_attrib_i_pointer` function.
        pub fn vertex_attrib_i_pointer(&self, index: u32, size: i32, type_: u32, stride: i32, offset: u32)  { unsafe { crate::dll::AzGl_vertexAttribIPointer(self, index, size, type_, stride, offset) } }
        /// Calls the `Gl::vertex_attrib_divisor` function.
        pub fn vertex_attrib_divisor(&self, index: u32, divisor: u32)  { unsafe { crate::dll::AzGl_vertexAttribDivisor(self, index, divisor) } }
        /// Calls the `Gl::viewport` function.
        pub fn viewport(&self, x: i32, y: i32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_viewport(self, x, y, width, height) } }
        /// Calls the `Gl::scissor` function.
        pub fn scissor(&self, x: i32, y: i32, width: i32, height: i32)  { unsafe { crate::dll::AzGl_scissor(self, x, y, width, height) } }
        /// Calls the `Gl::line_width` function.
        pub fn line_width(&self, width: f32)  { unsafe { crate::dll::AzGl_lineWidth(self, width) } }
        /// Calls the `Gl::use_program` function.
        pub fn use_program(&self, program: u32)  { unsafe { crate::dll::AzGl_useProgram(self, program) } }
        /// Calls the `Gl::validate_program` function.
        pub fn validate_program(&self, program: u32)  { unsafe { crate::dll::AzGl_validateProgram(self, program) } }
        /// Calls the `Gl::draw_arrays` function.
        pub fn draw_arrays(&self, mode: u32, first: i32, count: i32)  { unsafe { crate::dll::AzGl_drawArrays(self, mode, first, count) } }
        /// Calls the `Gl::draw_arrays_instanced` function.
        pub fn draw_arrays_instanced(&self, mode: u32, first: i32, count: i32, primcount: i32)  { unsafe { crate::dll::AzGl_drawArraysInstanced(self, mode, first, count, primcount) } }
        /// Calls the `Gl::draw_elements` function.
        pub fn draw_elements(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32)  { unsafe { crate::dll::AzGl_drawElements(self, mode, count, element_type, indices_offset) } }
        /// Calls the `Gl::draw_elements_instanced` function.
        pub fn draw_elements_instanced(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32, primcount: i32)  { unsafe { crate::dll::AzGl_drawElementsInstanced(self, mode, count, element_type, indices_offset, primcount) } }
        /// Calls the `Gl::blend_color` function.
        pub fn blend_color(&self, r: f32, g: f32, b: f32, a: f32)  { unsafe { crate::dll::AzGl_blendColor(self, r, g, b, a) } }
        /// Calls the `Gl::blend_func` function.
        pub fn blend_func(&self, sfactor: u32, dfactor: u32)  { unsafe { crate::dll::AzGl_blendFunc(self, sfactor, dfactor) } }
        /// Calls the `Gl::blend_func_separate` function.
        pub fn blend_func_separate(&self, src_rgb: u32, dest_rgb: u32, src_alpha: u32, dest_alpha: u32)  { unsafe { crate::dll::AzGl_blendFuncSeparate(self, src_rgb, dest_rgb, src_alpha, dest_alpha) } }
        /// Calls the `Gl::blend_equation` function.
        pub fn blend_equation(&self, mode: u32)  { unsafe { crate::dll::AzGl_blendEquation(self, mode) } }
        /// Calls the `Gl::blend_equation_separate` function.
        pub fn blend_equation_separate(&self, mode_rgb: u32, mode_alpha: u32)  { unsafe { crate::dll::AzGl_blendEquationSeparate(self, mode_rgb, mode_alpha) } }
        /// Calls the `Gl::color_mask` function.
        pub fn color_mask(&self, r: bool, g: bool, b: bool, a: bool)  { unsafe { crate::dll::AzGl_colorMask(self, r, g, b, a) } }
        /// Calls the `Gl::cull_face` function.
        pub fn cull_face(&self, mode: u32)  { unsafe { crate::dll::AzGl_cullFace(self, mode) } }
        /// Calls the `Gl::front_face` function.
        pub fn front_face(&self, mode: u32)  { unsafe { crate::dll::AzGl_frontFace(self, mode) } }
        /// Calls the `Gl::enable` function.
        pub fn enable(&self, cap: u32)  { unsafe { crate::dll::AzGl_enable(self, cap) } }
        /// Calls the `Gl::disable` function.
        pub fn disable(&self, cap: u32)  { unsafe { crate::dll::AzGl_disable(self, cap) } }
        /// Calls the `Gl::hint` function.
        pub fn hint(&self, param_name: u32, param_val: u32)  { unsafe { crate::dll::AzGl_hint(self, param_name, param_val) } }
        /// Calls the `Gl::is_enabled` function.
        pub fn is_enabled(&self, cap: u32)  -> u8 { unsafe { crate::dll::AzGl_isEnabled(self, cap) } }
        /// Calls the `Gl::is_shader` function.
        pub fn is_shader(&self, shader: u32)  -> u8 { unsafe { crate::dll::AzGl_isShader(self, shader) } }
        /// Calls the `Gl::is_texture` function.
        pub fn is_texture(&self, texture: u32)  -> u8 { unsafe { crate::dll::AzGl_isTexture(self, texture) } }
        /// Calls the `Gl::is_framebuffer` function.
        pub fn is_framebuffer(&self, framebuffer: u32)  -> u8 { unsafe { crate::dll::AzGl_isFramebuffer(self, framebuffer) } }
        /// Calls the `Gl::is_renderbuffer` function.
        pub fn is_renderbuffer(&self, renderbuffer: u32)  -> u8 { unsafe { crate::dll::AzGl_isRenderbuffer(self, renderbuffer) } }
        /// Calls the `Gl::check_frame_buffer_status` function.
        pub fn check_frame_buffer_status(&self, target: u32)  -> u32 { unsafe { crate::dll::AzGl_checkFrameBufferStatus(self, target) } }
        /// Calls the `Gl::enable_vertex_attrib_array` function.
        pub fn enable_vertex_attrib_array(&self, index: u32)  { unsafe { crate::dll::AzGl_enableVertexAttribArray(self, index) } }
        /// Calls the `Gl::disable_vertex_attrib_array` function.
        pub fn disable_vertex_attrib_array(&self, index: u32)  { unsafe { crate::dll::AzGl_disableVertexAttribArray(self, index) } }
        /// Calls the `Gl::uniform_1f` function.
        pub fn uniform_1f(&self, location: i32, v0: f32)  { unsafe { crate::dll::AzGl_uniform1F(self, location, v0) } }
        /// Calls the `Gl::uniform_1fv` function.
        pub fn uniform_1fv(&self, location: i32, values: F32VecRef)  { unsafe { crate::dll::AzGl_uniform1Fv(self, location, values) } }
        /// Calls the `Gl::uniform_1i` function.
        pub fn uniform_1i(&self, location: i32, v0: i32)  { unsafe { crate::dll::AzGl_uniform1I(self, location, v0) } }
        /// Calls the `Gl::uniform_1iv` function.
        pub fn uniform_1iv(&self, location: i32, values: I32VecRef)  { unsafe { crate::dll::AzGl_uniform1Iv(self, location, values) } }
        /// Calls the `Gl::uniform_1ui` function.
        pub fn uniform_1ui(&self, location: i32, v0: u32)  { unsafe { crate::dll::AzGl_uniform1Ui(self, location, v0) } }
        /// Calls the `Gl::uniform_2f` function.
        pub fn uniform_2f(&self, location: i32, v0: f32, v1: f32)  { unsafe { crate::dll::AzGl_uniform2F(self, location, v0, v1) } }
        /// Calls the `Gl::uniform_2fv` function.
        pub fn uniform_2fv(&self, location: i32, values: F32VecRef)  { unsafe { crate::dll::AzGl_uniform2Fv(self, location, values) } }
        /// Calls the `Gl::uniform_2i` function.
        pub fn uniform_2i(&self, location: i32, v0: i32, v1: i32)  { unsafe { crate::dll::AzGl_uniform2I(self, location, v0, v1) } }
        /// Calls the `Gl::uniform_2iv` function.
        pub fn uniform_2iv(&self, location: i32, values: I32VecRef)  { unsafe { crate::dll::AzGl_uniform2Iv(self, location, values) } }
        /// Calls the `Gl::uniform_2ui` function.
        pub fn uniform_2ui(&self, location: i32, v0: u32, v1: u32)  { unsafe { crate::dll::AzGl_uniform2Ui(self, location, v0, v1) } }
        /// Calls the `Gl::uniform_3f` function.
        pub fn uniform_3f(&self, location: i32, v0: f32, v1: f32, v2: f32)  { unsafe { crate::dll::AzGl_uniform3F(self, location, v0, v1, v2) } }
        /// Calls the `Gl::uniform_3fv` function.
        pub fn uniform_3fv(&self, location: i32, values: F32VecRef)  { unsafe { crate::dll::AzGl_uniform3Fv(self, location, values) } }
        /// Calls the `Gl::uniform_3i` function.
        pub fn uniform_3i(&self, location: i32, v0: i32, v1: i32, v2: i32)  { unsafe { crate::dll::AzGl_uniform3I(self, location, v0, v1, v2) } }
        /// Calls the `Gl::uniform_3iv` function.
        pub fn uniform_3iv(&self, location: i32, values: I32VecRef)  { unsafe { crate::dll::AzGl_uniform3Iv(self, location, values) } }
        /// Calls the `Gl::uniform_3ui` function.
        pub fn uniform_3ui(&self, location: i32, v0: u32, v1: u32, v2: u32)  { unsafe { crate::dll::AzGl_uniform3Ui(self, location, v0, v1, v2) } }
        /// Calls the `Gl::uniform_4f` function.
        pub fn uniform_4f(&self, location: i32, x: f32, y: f32, z: f32, w: f32)  { unsafe { crate::dll::AzGl_uniform4F(self, location, x, y, z, w) } }
        /// Calls the `Gl::uniform_4i` function.
        pub fn uniform_4i(&self, location: i32, x: i32, y: i32, z: i32, w: i32)  { unsafe { crate::dll::AzGl_uniform4I(self, location, x, y, z, w) } }
        /// Calls the `Gl::uniform_4iv` function.
        pub fn uniform_4iv(&self, location: i32, values: I32VecRef)  { unsafe { crate::dll::AzGl_uniform4Iv(self, location, values) } }
        /// Calls the `Gl::uniform_4ui` function.
        pub fn uniform_4ui(&self, location: i32, x: u32, y: u32, z: u32, w: u32)  { unsafe { crate::dll::AzGl_uniform4Ui(self, location, x, y, z, w) } }
        /// Calls the `Gl::uniform_4fv` function.
        pub fn uniform_4fv(&self, location: i32, values: F32VecRef)  { unsafe { crate::dll::AzGl_uniform4Fv(self, location, values) } }
        /// Calls the `Gl::uniform_matrix_2fv` function.
        pub fn uniform_matrix_2fv(&self, location: i32, transpose: bool, value: F32VecRef)  { unsafe { crate::dll::AzGl_uniformMatrix2Fv(self, location, transpose, value) } }
        /// Calls the `Gl::uniform_matrix_3fv` function.
        pub fn uniform_matrix_3fv(&self, location: i32, transpose: bool, value: F32VecRef)  { unsafe { crate::dll::AzGl_uniformMatrix3Fv(self, location, transpose, value) } }
        /// Calls the `Gl::uniform_matrix_4fv` function.
        pub fn uniform_matrix_4fv(&self, location: i32, transpose: bool, value: F32VecRef)  { unsafe { crate::dll::AzGl_uniformMatrix4Fv(self, location, transpose, value) } }
        /// Calls the `Gl::depth_mask` function.
        pub fn depth_mask(&self, flag: bool)  { unsafe { crate::dll::AzGl_depthMask(self, flag) } }
        /// Calls the `Gl::depth_range` function.
        pub fn depth_range(&self, near: f64, far: f64)  { unsafe { crate::dll::AzGl_depthRange(self, near, far) } }
        /// Calls the `Gl::get_active_attrib` function.
        pub fn get_active_attrib(&self, program: u32, index: u32)  -> crate::gl::GetActiveAttribReturn { unsafe { crate::dll::AzGl_getActiveAttrib(self, program, index) } }
        /// Calls the `Gl::get_active_uniform` function.
        pub fn get_active_uniform(&self, program: u32, index: u32)  -> crate::gl::GetActiveUniformReturn { unsafe { crate::dll::AzGl_getActiveUniform(self, program, index) } }
        /// Calls the `Gl::get_active_uniforms_iv` function.
        pub fn get_active_uniforms_iv(&self, program: u32, indices: GLuintVec, pname: u32)  -> crate::vec::GLintVec { unsafe { crate::dll::AzGl_getActiveUniformsIv(self, program, indices, pname) } }
        /// Calls the `Gl::get_active_uniform_block_i` function.
        pub fn get_active_uniform_block_i(&self, program: u32, index: u32, pname: u32)  -> i32 { unsafe { crate::dll::AzGl_getActiveUniformBlockI(self, program, index, pname) } }
        /// Calls the `Gl::get_active_uniform_block_iv` function.
        pub fn get_active_uniform_block_iv(&self, program: u32, index: u32, pname: u32)  -> crate::vec::GLintVec { unsafe { crate::dll::AzGl_getActiveUniformBlockIv(self, program, index, pname) } }
        /// Calls the `Gl::get_active_uniform_block_name` function.
        pub fn get_active_uniform_block_name(&self, program: u32, index: u32)  -> crate::str::String { unsafe { crate::dll::AzGl_getActiveUniformBlockName(self, program, index) } }
        /// Calls the `Gl::get_attrib_location` function.
        pub fn get_attrib_location(&self, program: u32, name: Refstr)  -> i32 { unsafe { crate::dll::AzGl_getAttribLocation(self, program, name) } }
        /// Calls the `Gl::get_frag_data_location` function.
        pub fn get_frag_data_location(&self, program: u32, name: Refstr)  -> i32 { unsafe { crate::dll::AzGl_getFragDataLocation(self, program, name) } }
        /// Calls the `Gl::get_uniform_location` function.
        pub fn get_uniform_location(&self, program: u32, name: Refstr)  -> i32 { unsafe { crate::dll::AzGl_getUniformLocation(self, program, name) } }
        /// Calls the `Gl::get_program_info_log` function.
        pub fn get_program_info_log(&self, program: u32)  -> crate::str::String { unsafe { crate::dll::AzGl_getProgramInfoLog(self, program) } }
        /// Calls the `Gl::get_program_iv` function.
        pub fn get_program_iv(&self, program: u32, pname: u32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getProgramIv(self, program, pname, result) } }
        /// Calls the `Gl::get_program_binary` function.
        pub fn get_program_binary(&self, program: u32)  -> crate::gl::GetProgramBinaryReturn { unsafe { crate::dll::AzGl_getProgramBinary(self, program) } }
        /// Calls the `Gl::program_binary` function.
        pub fn program_binary(&self, program: u32, format: u32, binary: U8VecRef)  { unsafe { crate::dll::AzGl_programBinary(self, program, format, binary) } }
        /// Calls the `Gl::program_parameter_i` function.
        pub fn program_parameter_i(&self, program: u32, pname: u32, value: i32)  { unsafe { crate::dll::AzGl_programParameterI(self, program, pname, value) } }
        /// Calls the `Gl::get_vertex_attrib_iv` function.
        pub fn get_vertex_attrib_iv(&self, index: u32, pname: u32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getVertexAttribIv(self, index, pname, result) } }
        /// Calls the `Gl::get_vertex_attrib_fv` function.
        pub fn get_vertex_attrib_fv(&self, index: u32, pname: u32, result: GLfloatVecRefMut)  { unsafe { crate::dll::AzGl_getVertexAttribFv(self, index, pname, result) } }
        /// Calls the `Gl::get_vertex_attrib_pointer_v` function.
        pub fn get_vertex_attrib_pointer_v(&self, index: u32, pname: u32)  -> isize { unsafe { crate::dll::AzGl_getVertexAttribPointerV(self, index, pname) } }
        /// Calls the `Gl::get_buffer_parameter_iv` function.
        pub fn get_buffer_parameter_iv(&self, target: u32, pname: u32)  -> i32 { unsafe { crate::dll::AzGl_getBufferParameterIv(self, target, pname) } }
        /// Calls the `Gl::get_shader_info_log` function.
        pub fn get_shader_info_log(&self, shader: u32)  -> crate::str::String { unsafe { crate::dll::AzGl_getShaderInfoLog(self, shader) } }
        /// Calls the `Gl::get_string` function.
        pub fn get_string(&self, which: u32)  -> crate::str::String { unsafe { crate::dll::AzGl_getString(self, which) } }
        /// Calls the `Gl::get_string_i` function.
        pub fn get_string_i(&self, which: u32, index: u32)  -> crate::str::String { unsafe { crate::dll::AzGl_getStringI(self, which, index) } }
        /// Calls the `Gl::get_shader_iv` function.
        pub fn get_shader_iv(&self, shader: u32, pname: u32, result: GLintVecRefMut)  { unsafe { crate::dll::AzGl_getShaderIv(self, shader, pname, result) } }
        /// Calls the `Gl::get_shader_precision_format` function.
        pub fn get_shader_precision_format(&self, shader_type: u32, precision_type: u32)  -> crate::gl::GlShaderPrecisionFormatReturn { unsafe { crate::dll::AzGl_getShaderPrecisionFormat(self, shader_type, precision_type) } }
        /// Calls the `Gl::compile_shader` function.
        pub fn compile_shader(&self, shader: u32)  { unsafe { crate::dll::AzGl_compileShader(self, shader) } }
        /// Calls the `Gl::create_program` function.
        pub fn create_program(&self)  -> u32 { unsafe { crate::dll::AzGl_createProgram(self) } }
        /// Calls the `Gl::delete_program` function.
        pub fn delete_program(&self, program: u32)  { unsafe { crate::dll::AzGl_deleteProgram(self, program) } }
        /// Calls the `Gl::create_shader` function.
        pub fn create_shader(&self, shader_type: u32)  -> u32 { unsafe { crate::dll::AzGl_createShader(self, shader_type) } }
        /// Calls the `Gl::delete_shader` function.
        pub fn delete_shader(&self, shader: u32)  { unsafe { crate::dll::AzGl_deleteShader(self, shader) } }
        /// Calls the `Gl::detach_shader` function.
        pub fn detach_shader(&self, program: u32, shader: u32)  { unsafe { crate::dll::AzGl_detachShader(self, program, shader) } }
        /// Calls the `Gl::link_program` function.
        pub fn link_program(&self, program: u32)  { unsafe { crate::dll::AzGl_linkProgram(self, program) } }
        /// Calls the `Gl::clear_color` function.
        pub fn clear_color(&self, r: f32, g: f32, b: f32, a: f32)  { unsafe { crate::dll::AzGl_clearColor(self, r, g, b, a) } }
        /// Calls the `Gl::clear` function.
        pub fn clear(&self, buffer_mask: u32)  { unsafe { crate::dll::AzGl_clear(self, buffer_mask) } }
        /// Calls the `Gl::clear_depth` function.
        pub fn clear_depth(&self, depth: f64)  { unsafe { crate::dll::AzGl_clearDepth(self, depth) } }
        /// Calls the `Gl::clear_stencil` function.
        pub fn clear_stencil(&self, s: i32)  { unsafe { crate::dll::AzGl_clearStencil(self, s) } }
        /// Calls the `Gl::flush` function.
        pub fn flush(&self)  { unsafe { crate::dll::AzGl_flush(self) } }
        /// Calls the `Gl::finish` function.
        pub fn finish(&self)  { unsafe { crate::dll::AzGl_finish(self) } }
        /// Calls the `Gl::get_error` function.
        pub fn get_error(&self)  -> u32 { unsafe { crate::dll::AzGl_getError(self) } }
        /// Calls the `Gl::stencil_mask` function.
        pub fn stencil_mask(&self, mask: u32)  { unsafe { crate::dll::AzGl_stencilMask(self, mask) } }
        /// Calls the `Gl::stencil_mask_separate` function.
        pub fn stencil_mask_separate(&self, face: u32, mask: u32)  { unsafe { crate::dll::AzGl_stencilMaskSeparate(self, face, mask) } }
        /// Calls the `Gl::stencil_func` function.
        pub fn stencil_func(&self, func: u32, ref_: i32, mask: u32)  { unsafe { crate::dll::AzGl_stencilFunc(self, func, ref_, mask) } }
        /// Calls the `Gl::stencil_func_separate` function.
        pub fn stencil_func_separate(&self, face: u32, func: u32, ref_: i32, mask: u32)  { unsafe { crate::dll::AzGl_stencilFuncSeparate(self, face, func, ref_, mask) } }
        /// Calls the `Gl::stencil_op` function.
        pub fn stencil_op(&self, sfail: u32, dpfail: u32, dppass: u32)  { unsafe { crate::dll::AzGl_stencilOp(self, sfail, dpfail, dppass) } }
        /// Calls the `Gl::stencil_op_separate` function.
        pub fn stencil_op_separate(&self, face: u32, sfail: u32, dpfail: u32, dppass: u32)  { unsafe { crate::dll::AzGl_stencilOpSeparate(self, face, sfail, dpfail, dppass) } }
        /// Calls the `Gl::egl_image_target_texture2d_oes` function.
        pub fn egl_image_target_texture2d_oes(&self, target: u32, image: GlVoidPtrConst)  { unsafe { crate::dll::AzGl_eglImageTargetTexture2DOes(self, target, image) } }
        /// Calls the `Gl::generate_mipmap` function.
        pub fn generate_mipmap(&self, target: u32)  { unsafe { crate::dll::AzGl_generateMipmap(self, target) } }
        /// Calls the `Gl::insert_event_marker_ext` function.
        pub fn insert_event_marker_ext(&self, message: Refstr)  { unsafe { crate::dll::AzGl_insertEventMarkerExt(self, message) } }
        /// Calls the `Gl::push_group_marker_ext` function.
        pub fn push_group_marker_ext(&self, message: Refstr)  { unsafe { crate::dll::AzGl_pushGroupMarkerExt(self, message) } }
        /// Calls the `Gl::pop_group_marker_ext` function.
        pub fn pop_group_marker_ext(&self)  { unsafe { crate::dll::AzGl_popGroupMarkerExt(self) } }
        /// Calls the `Gl::debug_message_insert_khr` function.
        pub fn debug_message_insert_khr(&self, source: u32, type_: u32, id: u32, severity: u32, message: Refstr)  { unsafe { crate::dll::AzGl_debugMessageInsertKhr(self, source, type_, id, severity, message) } }
        /// Calls the `Gl::push_debug_group_khr` function.
        pub fn push_debug_group_khr(&self, source: u32, id: u32, message: Refstr)  { unsafe { crate::dll::AzGl_pushDebugGroupKhr(self, source, id, message) } }
        /// Calls the `Gl::pop_debug_group_khr` function.
        pub fn pop_debug_group_khr(&self)  { unsafe { crate::dll::AzGl_popDebugGroupKhr(self) } }
        /// Calls the `Gl::fence_sync` function.
        pub fn fence_sync(&self, condition: u32, flags: u32)  -> crate::gl::GLsyncPtr { unsafe { crate::dll::AzGl_fenceSync(self, condition, flags) } }
        /// Calls the `Gl::client_wait_sync` function.
        pub fn client_wait_sync(&self, sync: GLsyncPtr, flags: u32, timeout: u64)  -> u32 { unsafe { crate::dll::AzGl_clientWaitSync(self, sync, flags, timeout) } }
        /// Calls the `Gl::wait_sync` function.
        pub fn wait_sync(&self, sync: GLsyncPtr, flags: u32, timeout: u64)  { unsafe { crate::dll::AzGl_waitSync(self, sync, flags, timeout) } }
        /// Calls the `Gl::delete_sync` function.
        pub fn delete_sync(&self, sync: GLsyncPtr)  { unsafe { crate::dll::AzGl_deleteSync(self, sync) } }
        /// Calls the `Gl::texture_range_apple` function.
        pub fn texture_range_apple(&self, target: u32, data: U8VecRef)  { unsafe { crate::dll::AzGl_textureRangeApple(self, target, data) } }
        /// Calls the `Gl::gen_fences_apple` function.
        pub fn gen_fences_apple(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genFencesApple(self, n) } }
        /// Calls the `Gl::delete_fences_apple` function.
        pub fn delete_fences_apple(&self, fences: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteFencesApple(self, fences) } }
        /// Calls the `Gl::set_fence_apple` function.
        pub fn set_fence_apple(&self, fence: u32)  { unsafe { crate::dll::AzGl_setFenceApple(self, fence) } }
        /// Calls the `Gl::finish_fence_apple` function.
        pub fn finish_fence_apple(&self, fence: u32)  { unsafe { crate::dll::AzGl_finishFenceApple(self, fence) } }
        /// Calls the `Gl::test_fence_apple` function.
        pub fn test_fence_apple(&self, fence: u32)  { unsafe { crate::dll::AzGl_testFenceApple(self, fence) } }
        /// Calls the `Gl::test_object_apple` function.
        pub fn test_object_apple(&self, object: u32, name: u32)  -> u8 { unsafe { crate::dll::AzGl_testObjectApple(self, object, name) } }
        /// Calls the `Gl::finish_object_apple` function.
        pub fn finish_object_apple(&self, object: u32, name: u32)  { unsafe { crate::dll::AzGl_finishObjectApple(self, object, name) } }
        /// Calls the `Gl::get_frag_data_index` function.
        pub fn get_frag_data_index(&self, program: u32, name: Refstr)  -> i32 { unsafe { crate::dll::AzGl_getFragDataIndex(self, program, name) } }
        /// Calls the `Gl::blend_barrier_khr` function.
        pub fn blend_barrier_khr(&self)  { unsafe { crate::dll::AzGl_blendBarrierKhr(self) } }
        /// Calls the `Gl::bind_frag_data_location_indexed` function.
        pub fn bind_frag_data_location_indexed(&self, program: u32, color_number: u32, index: u32, name: Refstr)  { unsafe { crate::dll::AzGl_bindFragDataLocationIndexed(self, program, color_number, index, name) } }
        /// Calls the `Gl::get_debug_messages` function.
        pub fn get_debug_messages(&self)  -> crate::vec::DebugMessageVec { unsafe { crate::dll::AzGl_getDebugMessages(self) } }
        /// Calls the `Gl::provoking_vertex_angle` function.
        pub fn provoking_vertex_angle(&self, mode: u32)  { unsafe { crate::dll::AzGl_provokingVertexAngle(self, mode) } }
        /// Calls the `Gl::gen_vertex_arrays_apple` function.
        pub fn gen_vertex_arrays_apple(&self, n: i32)  -> crate::vec::GLuintVec { unsafe { crate::dll::AzGl_genVertexArraysApple(self, n) } }
        /// Calls the `Gl::bind_vertex_array_apple` function.
        pub fn bind_vertex_array_apple(&self, vao: u32)  { unsafe { crate::dll::AzGl_bindVertexArrayApple(self, vao) } }
        /// Calls the `Gl::delete_vertex_arrays_apple` function.
        pub fn delete_vertex_arrays_apple(&self, vertex_arrays: GLuintVecRef)  { unsafe { crate::dll::AzGl_deleteVertexArraysApple(self, vertex_arrays) } }
        /// Calls the `Gl::copy_texture_chromium` function.
        pub fn copy_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  { unsafe { crate::dll::AzGl_copyTextureChromium(self, source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) } }
        /// Calls the `Gl::copy_sub_texture_chromium` function.
        pub fn copy_sub_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, x: i32, y: i32, width: i32, height: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  { unsafe { crate::dll::AzGl_copySubTextureChromium(self, source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, x, y, width, height, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) } }
        /// Calls the `Gl::egl_image_target_renderbuffer_storage_oes` function.
        pub fn egl_image_target_renderbuffer_storage_oes(&self, target: u32, image: GlVoidPtrConst)  { unsafe { crate::dll::AzGl_eglImageTargetRenderbufferStorageOes(self, target, image) } }
        /// Calls the `Gl::copy_texture_3d_angle` function.
        pub fn copy_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  { unsafe { crate::dll::AzGl_copyTexture3DAngle(self, source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) } }
        /// Calls the `Gl::copy_sub_texture_3d_angle` function.
        pub fn copy_sub_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, z_offset: i32, x: i32, y: i32, z: i32, width: i32, height: i32, depth: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  { unsafe { crate::dll::AzGl_copySubTexture3DAngle(self, source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, z_offset, x, y, z, width, height, depth, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) } }
        /// Calls the `Gl::buffer_storage` function.
        pub fn buffer_storage(&self, target: u32, size: isize, data: GlVoidPtrConst, flags: u32)  { unsafe { crate::dll::AzGl_bufferStorage(self, target, size, data, flags) } }
        /// Calls the `Gl::flush_mapped_buffer_range` function.
        pub fn flush_mapped_buffer_range(&self, target: u32, offset: isize, length: isize)  { unsafe { crate::dll::AzGl_flushMappedBufferRange(self, target, offset, length) } }
    }

    #[cfg(feature = "link_static")]
    impl GlCrossCrateImpl {

        pub const ACCUM: u32 = 0x0100;
        pub const ACCUM_ALPHA_BITS: u32 = 0x0D5B;
        pub const ACCUM_BLUE_BITS: u32 = 0x0D5A;
        pub const ACCUM_BUFFER_BIT: u32 = 0x00000200;
        pub const ACCUM_CLEAR_VALUE: u32 = 0x0B80;
        pub const ACCUM_GREEN_BITS: u32 = 0x0D59;
        pub const ACCUM_RED_BITS: u32 = 0x0D58;
        pub const ACTIVE_ATTRIBUTES: u32 = 0x8B89;
        pub const ACTIVE_ATTRIBUTE_MAX_LENGTH: u32 = 0x8B8A;
        pub const ACTIVE_TEXTURE: u32 = 0x84E0;
        pub const ACTIVE_UNIFORMS: u32 = 0x8B86;
        pub const ACTIVE_UNIFORM_BLOCKS: u32 = 0x8A36;
        pub const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: u32 = 0x8A35;
        pub const ACTIVE_UNIFORM_MAX_LENGTH: u32 = 0x8B87;
        pub const ADD: u32 = 0x0104;
        pub const ADD_SIGNED: u32 = 0x8574;
        pub const ALIASED_LINE_WIDTH_RANGE: u32 = 0x846E;
        pub const ALIASED_POINT_SIZE_RANGE: u32 = 0x846D;
        pub const ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const ALPHA: u32 = 0x1906;
        pub const ALPHA12: u32 = 0x803D;
        pub const ALPHA16: u32 = 0x803E;
        pub const ALPHA16F_EXT: u32 = 0x881C;
        pub const ALPHA32F_EXT: u32 = 0x8816;
        pub const ALPHA4: u32 = 0x803B;
        pub const ALPHA8: u32 = 0x803C;
        pub const ALPHA8_EXT: u32 = 0x803C;
        pub const ALPHA_BIAS: u32 = 0x0D1D;
        pub const ALPHA_BITS: u32 = 0x0D55;
        pub const ALPHA_INTEGER: u32 = 0x8D97;
        pub const ALPHA_SCALE: u32 = 0x0D1C;
        pub const ALPHA_TEST: u32 = 0x0BC0;
        pub const ALPHA_TEST_FUNC: u32 = 0x0BC1;
        pub const ALPHA_TEST_REF: u32 = 0x0BC2;
        pub const ALREADY_SIGNALED: u32 = 0x911A;
        pub const ALWAYS: u32 = 0x0207;
        pub const AMBIENT: u32 = 0x1200;
        pub const AMBIENT_AND_DIFFUSE: u32 = 0x1602;
        pub const AND: u32 = 0x1501;
        pub const AND_INVERTED: u32 = 0x1504;
        pub const AND_REVERSE: u32 = 0x1502;
        pub const ANY_SAMPLES_PASSED: u32 = 0x8C2F;
        pub const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 0x8D6A;
        pub const ARRAY_BUFFER: u32 = 0x8892;
        pub const ARRAY_BUFFER_BINDING: u32 = 0x8894;
        pub const ATTACHED_SHADERS: u32 = 0x8B85;
        pub const ATTRIB_STACK_DEPTH: u32 = 0x0BB0;
        pub const AUTO_NORMAL: u32 = 0x0D80;
        pub const AUX0: u32 = 0x0409;
        pub const AUX1: u32 = 0x040A;
        pub const AUX2: u32 = 0x040B;
        pub const AUX3: u32 = 0x040C;
        pub const AUX_BUFFERS: u32 = 0x0C00;
        pub const BACK: u32 = 0x0405;
        pub const BACK_LEFT: u32 = 0x0402;
        pub const BACK_RIGHT: u32 = 0x0403;
        pub const BGR: u32 = 0x80E0;
        pub const BGRA: u32 = 0x80E1;
        pub const BGRA8_EXT: u32 = 0x93A1;
        pub const BGRA_EXT: u32 = 0x80E1;
        pub const BGRA_INTEGER: u32 = 0x8D9B;
        pub const BGR_INTEGER: u32 = 0x8D9A;
        pub const BITMAP: u32 = 0x1A00;
        pub const BITMAP_TOKEN: u32 = 0x0704;
        pub const BLEND: u32 = 0x0BE2;
        pub const BLEND_ADVANCED_COHERENT_KHR: u32 = 0x9285;
        pub const BLEND_COLOR: u32 = 0x8005;
        pub const BLEND_DST: u32 = 0x0BE0;
        pub const BLEND_DST_ALPHA: u32 = 0x80CA;
        pub const BLEND_DST_RGB: u32 = 0x80C8;
        pub const BLEND_EQUATION: u32 = 0x8009;
        pub const BLEND_EQUATION_ALPHA: u32 = 0x883D;
        pub const BLEND_EQUATION_RGB: u32 = 0x8009;
        pub const BLEND_SRC: u32 = 0x0BE1;
        pub const BLEND_SRC_ALPHA: u32 = 0x80CB;
        pub const BLEND_SRC_RGB: u32 = 0x80C9;
        pub const BLUE: u32 = 0x1905;
        pub const BLUE_BIAS: u32 = 0x0D1B;
        pub const BLUE_BITS: u32 = 0x0D54;
        pub const BLUE_INTEGER: u32 = 0x8D96;
        pub const BLUE_SCALE: u32 = 0x0D1A;
        pub const BOOL: u32 = 0x8B56;
        pub const BOOL_VEC2: u32 = 0x8B57;
        pub const BOOL_VEC3: u32 = 0x8B58;
        pub const BOOL_VEC4: u32 = 0x8B59;
        pub const BUFFER: u32 = 0x82E0;
        pub const BUFFER_ACCESS: u32 = 0x88BB;
        pub const BUFFER_ACCESS_FLAGS: u32 = 0x911F;
        pub const BUFFER_KHR: u32 = 0x82E0;
        pub const BUFFER_MAPPED: u32 = 0x88BC;
        pub const BUFFER_MAP_LENGTH: u32 = 0x9120;
        pub const BUFFER_MAP_OFFSET: u32 = 0x9121;
        pub const BUFFER_MAP_POINTER: u32 = 0x88BD;
        pub const BUFFER_SIZE: u32 = 0x8764;
        pub const BUFFER_USAGE: u32 = 0x8765;
        pub const BYTE: u32 = 0x1400;
        pub const C3F_V3F: u32 = 0x2A24;
        pub const C4F_N3F_V3F: u32 = 0x2A26;
        pub const C4UB_V2F: u32 = 0x2A22;
        pub const C4UB_V3F: u32 = 0x2A23;
        pub const CCW: u32 = 0x0901;
        pub const CLAMP: u32 = 0x2900;
        pub const CLAMP_FRAGMENT_COLOR: u32 = 0x891B;
        pub const CLAMP_READ_COLOR: u32 = 0x891C;
        pub const CLAMP_TO_BORDER: u32 = 0x812D;
        pub const CLAMP_TO_EDGE: u32 = 0x812F;
        pub const CLAMP_VERTEX_COLOR: u32 = 0x891A;
        pub const CLEAR: u32 = 0x1500;
        pub const CLIENT_ACTIVE_TEXTURE: u32 = 0x84E1;
        pub const CLIENT_ALL_ATTRIB_BITS: u32 = 0xFFFFFFFF;
        pub const CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0BB1;
        pub const CLIENT_PIXEL_STORE_BIT: u32 = 0x00000001;
        pub const CLIENT_VERTEX_ARRAY_BIT: u32 = 0x00000002;
        pub const CLIP_DISTANCE0: u32 = 0x3000;
        pub const CLIP_DISTANCE1: u32 = 0x3001;
        pub const CLIP_DISTANCE2: u32 = 0x3002;
        pub const CLIP_DISTANCE3: u32 = 0x3003;
        pub const CLIP_DISTANCE4: u32 = 0x3004;
        pub const CLIP_DISTANCE5: u32 = 0x3005;
        pub const CLIP_DISTANCE6: u32 = 0x3006;
        pub const CLIP_DISTANCE7: u32 = 0x3007;
        pub const CLIP_PLANE0: u32 = 0x3000;
        pub const CLIP_PLANE1: u32 = 0x3001;
        pub const CLIP_PLANE2: u32 = 0x3002;
        pub const CLIP_PLANE3: u32 = 0x3003;
        pub const CLIP_PLANE4: u32 = 0x3004;
        pub const CLIP_PLANE5: u32 = 0x3005;
        pub const COEFF: u32 = 0x0A00;
        pub const COLOR: u32 = 0x1800;
        pub const COLORBURN_KHR: u32 = 0x929A;
        pub const COLORDODGE_KHR: u32 = 0x9299;
        pub const COLOR_ARRAY: u32 = 0x8076;
        pub const COLOR_ARRAY_BUFFER_BINDING: u32 = 0x8898;
        pub const COLOR_ARRAY_POINTER: u32 = 0x8090;
        pub const COLOR_ARRAY_SIZE: u32 = 0x8081;
        pub const COLOR_ARRAY_STRIDE: u32 = 0x8083;
        pub const COLOR_ARRAY_TYPE: u32 = 0x8082;
        pub const COLOR_ATTACHMENT0: u32 = 0x8CE0;
        pub const COLOR_ATTACHMENT1: u32 = 0x8CE1;
        pub const COLOR_ATTACHMENT10: u32 = 0x8CEA;
        pub const COLOR_ATTACHMENT11: u32 = 0x8CEB;
        pub const COLOR_ATTACHMENT12: u32 = 0x8CEC;
        pub const COLOR_ATTACHMENT13: u32 = 0x8CED;
        pub const COLOR_ATTACHMENT14: u32 = 0x8CEE;
        pub const COLOR_ATTACHMENT15: u32 = 0x8CEF;
        pub const COLOR_ATTACHMENT16: u32 = 0x8CF0;
        pub const COLOR_ATTACHMENT17: u32 = 0x8CF1;
        pub const COLOR_ATTACHMENT18: u32 = 0x8CF2;
        pub const COLOR_ATTACHMENT19: u32 = 0x8CF3;
        pub const COLOR_ATTACHMENT2: u32 = 0x8CE2;
        pub const COLOR_ATTACHMENT20: u32 = 0x8CF4;
        pub const COLOR_ATTACHMENT21: u32 = 0x8CF5;
        pub const COLOR_ATTACHMENT22: u32 = 0x8CF6;
        pub const COLOR_ATTACHMENT23: u32 = 0x8CF7;
        pub const COLOR_ATTACHMENT24: u32 = 0x8CF8;
        pub const COLOR_ATTACHMENT25: u32 = 0x8CF9;
        pub const COLOR_ATTACHMENT26: u32 = 0x8CFA;
        pub const COLOR_ATTACHMENT27: u32 = 0x8CFB;
        pub const COLOR_ATTACHMENT28: u32 = 0x8CFC;
        pub const COLOR_ATTACHMENT29: u32 = 0x8CFD;
        pub const COLOR_ATTACHMENT3: u32 = 0x8CE3;
        pub const COLOR_ATTACHMENT30: u32 = 0x8CFE;
        pub const COLOR_ATTACHMENT31: u32 = 0x8CFF;
        pub const COLOR_ATTACHMENT4: u32 = 0x8CE4;
        pub const COLOR_ATTACHMENT5: u32 = 0x8CE5;
        pub const COLOR_ATTACHMENT6: u32 = 0x8CE6;
        pub const COLOR_ATTACHMENT7: u32 = 0x8CE7;
        pub const COLOR_ATTACHMENT8: u32 = 0x8CE8;
        pub const COLOR_ATTACHMENT9: u32 = 0x8CE9;
        pub const COLOR_BUFFER_BIT: u32 = 0x00004000;
        pub const COLOR_CLEAR_VALUE: u32 = 0x0C22;
        pub const COLOR_INDEX: u32 = 0x1900;
        pub const COLOR_INDEXES: u32 = 0x1603;
        pub const COLOR_LOGIC_OP: u32 = 0x0BF2;
        pub const COLOR_MATERIAL: u32 = 0x0B57;
        pub const COLOR_MATERIAL_FACE: u32 = 0x0B55;
        pub const COLOR_MATERIAL_PARAMETER: u32 = 0x0B56;
        pub const COLOR_SUM: u32 = 0x8458;
        pub const COLOR_WRITEMASK: u32 = 0x0C23;
        pub const COMBINE: u32 = 0x8570;
        pub const COMBINE_ALPHA: u32 = 0x8572;
        pub const COMBINE_RGB: u32 = 0x8571;
        pub const COMPARE_REF_TO_TEXTURE: u32 = 0x884E;
        pub const COMPARE_R_TO_TEXTURE: u32 = 0x884E;
        pub const COMPILE: u32 = 0x1300;
        pub const COMPILE_AND_EXECUTE: u32 = 0x1301;
        pub const COMPILE_STATUS: u32 = 0x8B81;
        pub const COMPRESSED_ALPHA: u32 = 0x84E9;
        pub const COMPRESSED_INTENSITY: u32 = 0x84EC;
        pub const COMPRESSED_LUMINANCE: u32 = 0x84EA;
        pub const COMPRESSED_LUMINANCE_ALPHA: u32 = 0x84EB;
        pub const COMPRESSED_R11_EAC: u32 = 0x9270;
        pub const COMPRESSED_RED: u32 = 0x8225;
        pub const COMPRESSED_RED_RGTC1: u32 = 0x8DBB;
        pub const COMPRESSED_RG: u32 = 0x8226;
        pub const COMPRESSED_RG11_EAC: u32 = 0x9272;
        pub const COMPRESSED_RGB: u32 = 0x84ED;
        pub const COMPRESSED_RGB8_ETC2: u32 = 0x9274;
        pub const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9276;
        pub const COMPRESSED_RGBA: u32 = 0x84EE;
        pub const COMPRESSED_RGBA8_ETC2_EAC: u32 = 0x9278;
        pub const COMPRESSED_RG_RGTC2: u32 = 0x8DBD;
        pub const COMPRESSED_SIGNED_R11_EAC: u32 = 0x9271;
        pub const COMPRESSED_SIGNED_RED_RGTC1: u32 = 0x8DBC;
        pub const COMPRESSED_SIGNED_RG11_EAC: u32 = 0x9273;
        pub const COMPRESSED_SIGNED_RG_RGTC2: u32 = 0x8DBE;
        pub const COMPRESSED_SLUMINANCE: u32 = 0x8C4A;
        pub const COMPRESSED_SLUMINANCE_ALPHA: u32 = 0x8C4B;
        pub const COMPRESSED_SRGB: u32 = 0x8C48;
        pub const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: u32 = 0x9279;
        pub const COMPRESSED_SRGB8_ETC2: u32 = 0x9275;
        pub const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: u32 = 0x9277;
        pub const COMPRESSED_SRGB_ALPHA: u32 = 0x8C49;
        pub const COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A3;
        pub const CONDITION_SATISFIED: u32 = 0x911C;
        pub const CONSTANT: u32 = 0x8576;
        pub const CONSTANT_ALPHA: u32 = 0x8003;
        pub const CONSTANT_ATTENUATION: u32 = 0x1207;
        pub const CONSTANT_COLOR: u32 = 0x8001;
        pub const CONTEXT_COMPATIBILITY_PROFILE_BIT: u32 = 0x00000002;
        pub const CONTEXT_CORE_PROFILE_BIT: u32 = 0x00000001;
        pub const CONTEXT_FLAGS: u32 = 0x821E;
        pub const CONTEXT_FLAG_DEBUG_BIT: u32 = 0x00000002;
        pub const CONTEXT_FLAG_DEBUG_BIT_KHR: u32 = 0x00000002;
        pub const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: u32 = 0x00000001;
        pub const CONTEXT_PROFILE_MASK: u32 = 0x9126;
        pub const COORD_REPLACE: u32 = 0x8862;
        pub const COPY: u32 = 0x1503;
        pub const COPY_INVERTED: u32 = 0x150C;
        pub const COPY_PIXEL_TOKEN: u32 = 0x0706;
        pub const COPY_READ_BUFFER: u32 = 0x8F36;
        pub const COPY_READ_BUFFER_BINDING: u32 = 0x8F36;
        pub const COPY_WRITE_BUFFER: u32 = 0x8F37;
        pub const COPY_WRITE_BUFFER_BINDING: u32 = 0x8F37;
        pub const CULL_FACE: u32 = 0x0B44;
        pub const CULL_FACE_MODE: u32 = 0x0B45;
        pub const CURRENT_BIT: u32 = 0x00000001;
        pub const CURRENT_COLOR: u32 = 0x0B00;
        pub const CURRENT_FOG_COORD: u32 = 0x8453;
        pub const CURRENT_FOG_COORDINATE: u32 = 0x8453;
        pub const CURRENT_INDEX: u32 = 0x0B01;
        pub const CURRENT_NORMAL: u32 = 0x0B02;
        pub const CURRENT_PROGRAM: u32 = 0x8B8D;
        pub const CURRENT_QUERY: u32 = 0x8865;
        pub const CURRENT_QUERY_EXT: u32 = 0x8865;
        pub const CURRENT_RASTER_COLOR: u32 = 0x0B04;
        pub const CURRENT_RASTER_DISTANCE: u32 = 0x0B09;
        pub const CURRENT_RASTER_INDEX: u32 = 0x0B05;
        pub const CURRENT_RASTER_POSITION: u32 = 0x0B07;
        pub const CURRENT_RASTER_POSITION_VALID: u32 = 0x0B08;
        pub const CURRENT_RASTER_SECONDARY_COLOR: u32 = 0x845F;
        pub const CURRENT_RASTER_TEXTURE_COORDS: u32 = 0x0B06;
        pub const CURRENT_SECONDARY_COLOR: u32 = 0x8459;
        pub const CURRENT_TEXTURE_COORDS: u32 = 0x0B03;
        pub const CURRENT_VERTEX_ATTRIB: u32 = 0x8626;
        pub const CW: u32 = 0x0900;
        pub const DARKEN_KHR: u32 = 0x9297;
        pub const DEBUG_CALLBACK_FUNCTION: u32 = 0x8244;
        pub const DEBUG_CALLBACK_FUNCTION_KHR: u32 = 0x8244;
        pub const DEBUG_CALLBACK_USER_PARAM: u32 = 0x8245;
        pub const DEBUG_CALLBACK_USER_PARAM_KHR: u32 = 0x8245;
        pub const DEBUG_GROUP_STACK_DEPTH: u32 = 0x826D;
        pub const DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826D;
        pub const DEBUG_LOGGED_MESSAGES: u32 = 0x9145;
        pub const DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9145;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: u32 = 0x8243;
        pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR: u32 = 0x8243;
        pub const DEBUG_OUTPUT: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_KHR: u32 = 0x92E0;
        pub const DEBUG_OUTPUT_SYNCHRONOUS: u32 = 0x8242;
        pub const DEBUG_OUTPUT_SYNCHRONOUS_KHR: u32 = 0x8242;
        pub const DEBUG_SEVERITY_HIGH: u32 = 0x9146;
        pub const DEBUG_SEVERITY_HIGH_KHR: u32 = 0x9146;
        pub const DEBUG_SEVERITY_LOW: u32 = 0x9148;
        pub const DEBUG_SEVERITY_LOW_KHR: u32 = 0x9148;
        pub const DEBUG_SEVERITY_MEDIUM: u32 = 0x9147;
        pub const DEBUG_SEVERITY_MEDIUM_KHR: u32 = 0x9147;
        pub const DEBUG_SEVERITY_NOTIFICATION: u32 = 0x826B;
        pub const DEBUG_SEVERITY_NOTIFICATION_KHR: u32 = 0x826B;
        pub const DEBUG_SOURCE_API: u32 = 0x8246;
        pub const DEBUG_SOURCE_API_KHR: u32 = 0x8246;
        pub const DEBUG_SOURCE_APPLICATION: u32 = 0x824A;
        pub const DEBUG_SOURCE_APPLICATION_KHR: u32 = 0x824A;
        pub const DEBUG_SOURCE_OTHER: u32 = 0x824B;
        pub const DEBUG_SOURCE_OTHER_KHR: u32 = 0x824B;
        pub const DEBUG_SOURCE_SHADER_COMPILER: u32 = 0x8248;
        pub const DEBUG_SOURCE_SHADER_COMPILER_KHR: u32 = 0x8248;
        pub const DEBUG_SOURCE_THIRD_PARTY: u32 = 0x8249;
        pub const DEBUG_SOURCE_THIRD_PARTY_KHR: u32 = 0x8249;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM: u32 = 0x8247;
        pub const DEBUG_SOURCE_WINDOW_SYSTEM_KHR: u32 = 0x8247;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR: u32 = 0x824D;
        pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR: u32 = 0x824D;
        pub const DEBUG_TYPE_ERROR: u32 = 0x824C;
        pub const DEBUG_TYPE_ERROR_KHR: u32 = 0x824C;
        pub const DEBUG_TYPE_MARKER: u32 = 0x8268;
        pub const DEBUG_TYPE_MARKER_KHR: u32 = 0x8268;
        pub const DEBUG_TYPE_OTHER: u32 = 0x8251;
        pub const DEBUG_TYPE_OTHER_KHR: u32 = 0x8251;
        pub const DEBUG_TYPE_PERFORMANCE: u32 = 0x8250;
        pub const DEBUG_TYPE_PERFORMANCE_KHR: u32 = 0x8250;
        pub const DEBUG_TYPE_POP_GROUP: u32 = 0x826A;
        pub const DEBUG_TYPE_POP_GROUP_KHR: u32 = 0x826A;
        pub const DEBUG_TYPE_PORTABILITY: u32 = 0x824F;
        pub const DEBUG_TYPE_PORTABILITY_KHR: u32 = 0x824F;
        pub const DEBUG_TYPE_PUSH_GROUP: u32 = 0x8269;
        pub const DEBUG_TYPE_PUSH_GROUP_KHR: u32 = 0x8269;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR: u32 = 0x824E;
        pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR: u32 = 0x824E;
        pub const DECAL: u32 = 0x2101;
        pub const DECR: u32 = 0x1E03;
        pub const DECR_WRAP: u32 = 0x8508;
        pub const DELETE_STATUS: u32 = 0x8B80;
        pub const DEPTH: u32 = 0x1801;
        pub const DEPTH24_STENCIL8: u32 = 0x88F0;
        pub const DEPTH32F_STENCIL8: u32 = 0x8CAD;
        pub const DEPTH_ATTACHMENT: u32 = 0x8D00;
        pub const DEPTH_BIAS: u32 = 0x0D1F;
        pub const DEPTH_BITS: u32 = 0x0D56;
        pub const DEPTH_BUFFER_BIT: u32 = 0x00000100;
        pub const DEPTH_CLAMP: u32 = 0x864F;
        pub const DEPTH_CLEAR_VALUE: u32 = 0x0B73;
        pub const DEPTH_COMPONENT: u32 = 0x1902;
        pub const DEPTH_COMPONENT16: u32 = 0x81A5;
        pub const DEPTH_COMPONENT24: u32 = 0x81A6;
        pub const DEPTH_COMPONENT32: u32 = 0x81A7;
        pub const DEPTH_COMPONENT32F: u32 = 0x8CAC;
        pub const DEPTH_FUNC: u32 = 0x0B74;
        pub const DEPTH_RANGE: u32 = 0x0B70;
        pub const DEPTH_SCALE: u32 = 0x0D1E;
        pub const DEPTH_STENCIL: u32 = 0x84F9;
        pub const DEPTH_STENCIL_ATTACHMENT: u32 = 0x821A;
        pub const DEPTH_TEST: u32 = 0x0B71;
        pub const DEPTH_TEXTURE_MODE: u32 = 0x884B;
        pub const DEPTH_WRITEMASK: u32 = 0x0B72;
        pub const DIFFERENCE_KHR: u32 = 0x929E;
        pub const DIFFUSE: u32 = 0x1201;
        pub const DISPLAY_LIST: u32 = 0x82E7;
        pub const DITHER: u32 = 0x0BD0;
        pub const DOMAIN: u32 = 0x0A02;
        pub const DONT_CARE: u32 = 0x1100;
        pub const DOT3_RGB: u32 = 0x86AE;
        pub const DOT3_RGBA: u32 = 0x86AF;
        pub const DOUBLE: u32 = 0x140A;
        pub const DOUBLEBUFFER: u32 = 0x0C32;
        pub const DRAW_BUFFER: u32 = 0x0C01;
        pub const DRAW_BUFFER0: u32 = 0x8825;
        pub const DRAW_BUFFER1: u32 = 0x8826;
        pub const DRAW_BUFFER10: u32 = 0x882F;
        pub const DRAW_BUFFER11: u32 = 0x8830;
        pub const DRAW_BUFFER12: u32 = 0x8831;
        pub const DRAW_BUFFER13: u32 = 0x8832;
        pub const DRAW_BUFFER14: u32 = 0x8833;
        pub const DRAW_BUFFER15: u32 = 0x8834;
        pub const DRAW_BUFFER2: u32 = 0x8827;
        pub const DRAW_BUFFER3: u32 = 0x8828;
        pub const DRAW_BUFFER4: u32 = 0x8829;
        pub const DRAW_BUFFER5: u32 = 0x882A;
        pub const DRAW_BUFFER6: u32 = 0x882B;
        pub const DRAW_BUFFER7: u32 = 0x882C;
        pub const DRAW_BUFFER8: u32 = 0x882D;
        pub const DRAW_BUFFER9: u32 = 0x882E;
        pub const DRAW_FRAMEBUFFER: u32 = 0x8CA9;
        pub const DRAW_FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const DRAW_PIXELS_APPLE: u32 = 0x8A0A;
        pub const DRAW_PIXEL_TOKEN: u32 = 0x0705;
        pub const DST_ALPHA: u32 = 0x0304;
        pub const DST_COLOR: u32 = 0x0306;
        pub const DYNAMIC_COPY: u32 = 0x88EA;
        pub const DYNAMIC_DRAW: u32 = 0x88E8;
        pub const DYNAMIC_READ: u32 = 0x88E9;
        pub const EDGE_FLAG: u32 = 0x0B43;
        pub const EDGE_FLAG_ARRAY: u32 = 0x8079;
        pub const EDGE_FLAG_ARRAY_BUFFER_BINDING: u32 = 0x889B;
        pub const EDGE_FLAG_ARRAY_POINTER: u32 = 0x8093;
        pub const EDGE_FLAG_ARRAY_STRIDE: u32 = 0x808C;
        pub const ELEMENT_ARRAY_BUFFER: u32 = 0x8893;
        pub const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 0x8895;
        pub const EMISSION: u32 = 0x1600;
        pub const ENABLE_BIT: u32 = 0x00002000;
        pub const EQUAL: u32 = 0x0202;
        pub const EQUIV: u32 = 0x1509;
        pub const EVAL_BIT: u32 = 0x00010000;
        pub const EXCLUSION_KHR: u32 = 0x92A0;
        pub const EXP: u32 = 0x0800;
        pub const EXP2: u32 = 0x0801;
        pub const EXTENSIONS: u32 = 0x1F03;
        pub const EYE_LINEAR: u32 = 0x2400;
        pub const EYE_PLANE: u32 = 0x2502;
        pub const FALSE: u8 = 0;
        pub const FASTEST: u32 = 0x1101;
        pub const FEEDBACK: u32 = 0x1C01;
        pub const FEEDBACK_BUFFER_POINTER: u32 = 0x0DF0;
        pub const FEEDBACK_BUFFER_SIZE: u32 = 0x0DF1;
        pub const FEEDBACK_BUFFER_TYPE: u32 = 0x0DF2;
        pub const FENCE_APPLE: u32 = 0x8A0B;
        pub const FILL: u32 = 0x1B02;
        pub const FIRST_VERTEX_CONVENTION: u32 = 0x8E4D;
        pub const FIXED: u32 = 0x140C;
        pub const FIXED_ONLY: u32 = 0x891D;
        pub const FLAT: u32 = 0x1D00;
        pub const FLOAT: u32 = 0x1406;
        pub const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 0x8DAD;
        pub const FLOAT_MAT2: u32 = 0x8B5A;
        pub const FLOAT_MAT2x3: u32 = 0x8B65;
        pub const FLOAT_MAT2x4: u32 = 0x8B66;
        pub const FLOAT_MAT3: u32 = 0x8B5B;
        pub const FLOAT_MAT3x2: u32 = 0x8B67;
        pub const FLOAT_MAT3x4: u32 = 0x8B68;
        pub const FLOAT_MAT4: u32 = 0x8B5C;
        pub const FLOAT_MAT4x2: u32 = 0x8B69;
        pub const FLOAT_MAT4x3: u32 = 0x8B6A;
        pub const FLOAT_VEC2: u32 = 0x8B50;
        pub const FLOAT_VEC3: u32 = 0x8B51;
        pub const FLOAT_VEC4: u32 = 0x8B52;
        pub const FOG: u32 = 0x0B60;
        pub const FOG_BIT: u32 = 0x00000080;
        pub const FOG_COLOR: u32 = 0x0B66;
        pub const FOG_COORD: u32 = 0x8451;
        pub const FOG_COORDINATE: u32 = 0x8451;
        pub const FOG_COORDINATE_ARRAY: u32 = 0x8457;
        pub const FOG_COORDINATE_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORDINATE_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORDINATE_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORDINATE_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORDINATE_SOURCE: u32 = 0x8450;
        pub const FOG_COORD_ARRAY: u32 = 0x8457;
        pub const FOG_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889D;
        pub const FOG_COORD_ARRAY_POINTER: u32 = 0x8456;
        pub const FOG_COORD_ARRAY_STRIDE: u32 = 0x8455;
        pub const FOG_COORD_ARRAY_TYPE: u32 = 0x8454;
        pub const FOG_COORD_SRC: u32 = 0x8450;
        pub const FOG_DENSITY: u32 = 0x0B62;
        pub const FOG_END: u32 = 0x0B64;
        pub const FOG_HINT: u32 = 0x0C54;
        pub const FOG_INDEX: u32 = 0x0B61;
        pub const FOG_MODE: u32 = 0x0B65;
        pub const FOG_START: u32 = 0x0B63;
        pub const FRAGMENT_DEPTH: u32 = 0x8452;
        pub const FRAGMENT_SHADER: u32 = 0x8B30;
        pub const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 0x8B8B;
        pub const FRAMEBUFFER: u32 = 0x8D40;
        pub const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 0x8215;
        pub const FRAMEBUFFER_ATTACHMENT_ANGLE: u32 = 0x93A3;
        pub const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 0x8214;
        pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 0x8210;
        pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 0x8211;
        pub const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 0x8216;
        pub const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 0x8213;
        pub const FRAMEBUFFER_ATTACHMENT_LAYERED: u32 = 0x8DA7;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 0x8CD1;
        pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 0x8CD0;
        pub const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 0x8212;
        pub const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 0x8217;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 0x8CD3;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 0x8CD4;
        pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 0x8CD2;
        pub const FRAMEBUFFER_BINDING: u32 = 0x8CA6;
        pub const FRAMEBUFFER_COMPLETE: u32 = 0x8CD5;
        pub const FRAMEBUFFER_DEFAULT: u32 = 0x8218;
        pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 0x8CD6;
        pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 0x8CD9;
        pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: u32 = 0x8CDB;
        pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: u32 = 0x8DA8;
        pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 0x8CD7;
        pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 0x8D56;
        pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER: u32 = 0x8CDC;
        pub const FRAMEBUFFER_SRGB: u32 = 0x8DB9;
        pub const FRAMEBUFFER_UNDEFINED: u32 = 0x8219;
        pub const FRAMEBUFFER_UNSUPPORTED: u32 = 0x8CDD;
        pub const FRONT: u32 = 0x0404;
        pub const FRONT_AND_BACK: u32 = 0x0408;
        pub const FRONT_FACE: u32 = 0x0B46;
        pub const FRONT_LEFT: u32 = 0x0400;
        pub const FRONT_RIGHT: u32 = 0x0401;
        pub const FUNC_ADD: u32 = 0x8006;
        pub const FUNC_REVERSE_SUBTRACT: u32 = 0x800B;
        pub const FUNC_SUBTRACT: u32 = 0x800A;
        pub const GENERATE_MIPMAP: u32 = 0x8191;
        pub const GENERATE_MIPMAP_HINT: u32 = 0x8192;
        pub const GEOMETRY_INPUT_TYPE: u32 = 0x8917;
        pub const GEOMETRY_OUTPUT_TYPE: u32 = 0x8918;
        pub const GEOMETRY_SHADER: u32 = 0x8DD9;
        pub const GEOMETRY_VERTICES_OUT: u32 = 0x8916;
        pub const GEQUAL: u32 = 0x0206;
        pub const GPU_DISJOINT_EXT: u32 = 0x8FBB;
        pub const GREATER: u32 = 0x0204;
        pub const GREEN: u32 = 0x1904;
        pub const GREEN_BIAS: u32 = 0x0D19;
        pub const GREEN_BITS: u32 = 0x0D53;
        pub const GREEN_INTEGER: u32 = 0x8D95;
        pub const GREEN_SCALE: u32 = 0x0D18;
        pub const HALF_FLOAT: u32 = 0x140B;
        pub const HALF_FLOAT_OES: u32 = 0x8D61;
        pub const HARDLIGHT_KHR: u32 = 0x929B;
        pub const HIGH_FLOAT: u32 = 0x8DF2;
        pub const HIGH_INT: u32 = 0x8DF5;
        pub const HINT_BIT: u32 = 0x00008000;
        pub const HSL_COLOR_KHR: u32 = 0x92AF;
        pub const HSL_HUE_KHR: u32 = 0x92AD;
        pub const HSL_LUMINOSITY_KHR: u32 = 0x92B0;
        pub const HSL_SATURATION_KHR: u32 = 0x92AE;
        pub const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 0x8B9B;
        pub const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 0x8B9A;
        pub const INCR: u32 = 0x1E02;
        pub const INCR_WRAP: u32 = 0x8507;
        pub const INDEX: u32 = 0x8222;
        pub const INDEX_ARRAY: u32 = 0x8077;
        pub const INDEX_ARRAY_BUFFER_BINDING: u32 = 0x8899;
        pub const INDEX_ARRAY_POINTER: u32 = 0x8091;
        pub const INDEX_ARRAY_STRIDE: u32 = 0x8086;
        pub const INDEX_ARRAY_TYPE: u32 = 0x8085;
        pub const INDEX_BITS: u32 = 0x0D51;
        pub const INDEX_CLEAR_VALUE: u32 = 0x0C20;
        pub const INDEX_LOGIC_OP: u32 = 0x0BF1;
        pub const INDEX_MODE: u32 = 0x0C30;
        pub const INDEX_OFFSET: u32 = 0x0D13;
        pub const INDEX_SHIFT: u32 = 0x0D12;
        pub const INDEX_WRITEMASK: u32 = 0x0C21;
        pub const INFO_LOG_LENGTH: u32 = 0x8B84;
        pub const INT: u32 = 0x1404;
        pub const INTENSITY: u32 = 0x8049;
        pub const INTENSITY12: u32 = 0x804C;
        pub const INTENSITY16: u32 = 0x804D;
        pub const INTENSITY4: u32 = 0x804A;
        pub const INTENSITY8: u32 = 0x804B;
        pub const INTERLEAVED_ATTRIBS: u32 = 0x8C8C;
        pub const INTERPOLATE: u32 = 0x8575;
        pub const INT_2_10_10_10_REV: u32 = 0x8D9F;
        pub const INT_SAMPLER_1D: u32 = 0x8DC9;
        pub const INT_SAMPLER_1D_ARRAY: u32 = 0x8DCE;
        pub const INT_SAMPLER_2D: u32 = 0x8DCA;
        pub const INT_SAMPLER_2D_ARRAY: u32 = 0x8DCF;
        pub const INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x9109;
        pub const INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910C;
        pub const INT_SAMPLER_2D_RECT: u32 = 0x8DCD;
        pub const INT_SAMPLER_3D: u32 = 0x8DCB;
        pub const INT_SAMPLER_BUFFER: u32 = 0x8DD0;
        pub const INT_SAMPLER_CUBE: u32 = 0x8DCC;
        pub const INT_VEC2: u32 = 0x8B53;
        pub const INT_VEC3: u32 = 0x8B54;
        pub const INT_VEC4: u32 = 0x8B55;
        pub const INVALID_ENUM: u32 = 0x0500;
        pub const INVALID_FRAMEBUFFER_OPERATION: u32 = 0x0506;
        pub const INVALID_INDEX: u32 = 0xFFFFFFFF;
        pub const INVALID_OPERATION: u32 = 0x0502;
        pub const INVALID_VALUE: u32 = 0x0501;
        pub const INVERT: u32 = 0x150A;
        pub const KEEP: u32 = 0x1E00;
        pub const LAST_VERTEX_CONVENTION: u32 = 0x8E4E;
        pub const LEFT: u32 = 0x0406;
        pub const LEQUAL: u32 = 0x0203;
        pub const LESS: u32 = 0x0201;
        pub const LIGHT0: u32 = 0x4000;
        pub const LIGHT1: u32 = 0x4001;
        pub const LIGHT2: u32 = 0x4002;
        pub const LIGHT3: u32 = 0x4003;
        pub const LIGHT4: u32 = 0x4004;
        pub const LIGHT5: u32 = 0x4005;
        pub const LIGHT6: u32 = 0x4006;
        pub const LIGHT7: u32 = 0x4007;
        pub const LIGHTEN_KHR: u32 = 0x9298;
        pub const LIGHTING: u32 = 0x0B50;
        pub const LIGHTING_BIT: u32 = 0x00000040;
        pub const LIGHT_MODEL_AMBIENT: u32 = 0x0B53;
        pub const LIGHT_MODEL_COLOR_CONTROL: u32 = 0x81F8;
        pub const LIGHT_MODEL_LOCAL_VIEWER: u32 = 0x0B51;
        pub const LIGHT_MODEL_TWO_SIDE: u32 = 0x0B52;
        pub const LINE: u32 = 0x1B01;
        pub const LINEAR: u32 = 0x2601;
        pub const LINEAR_ATTENUATION: u32 = 0x1208;
        pub const LINEAR_MIPMAP_LINEAR: u32 = 0x2703;
        pub const LINEAR_MIPMAP_NEAREST: u32 = 0x2701;
        pub const LINES: u32 = 0x0001;
        pub const LINES_ADJACENCY: u32 = 0x000A;
        pub const LINE_BIT: u32 = 0x00000004;
        pub const LINE_LOOP: u32 = 0x0002;
        pub const LINE_RESET_TOKEN: u32 = 0x0707;
        pub const LINE_SMOOTH: u32 = 0x0B20;
        pub const LINE_SMOOTH_HINT: u32 = 0x0C52;
        pub const LINE_STIPPLE: u32 = 0x0B24;
        pub const LINE_STIPPLE_PATTERN: u32 = 0x0B25;
        pub const LINE_STIPPLE_REPEAT: u32 = 0x0B26;
        pub const LINE_STRIP: u32 = 0x0003;
        pub const LINE_STRIP_ADJACENCY: u32 = 0x000B;
        pub const LINE_TOKEN: u32 = 0x0702;
        pub const LINE_WIDTH: u32 = 0x0B21;
        pub const LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const LINK_STATUS: u32 = 0x8B82;
        pub const LIST_BASE: u32 = 0x0B32;
        pub const LIST_BIT: u32 = 0x00020000;
        pub const LIST_INDEX: u32 = 0x0B33;
        pub const LIST_MODE: u32 = 0x0B30;
        pub const LOAD: u32 = 0x0101;
        pub const LOGIC_OP: u32 = 0x0BF1;
        pub const LOGIC_OP_MODE: u32 = 0x0BF0;
        pub const LOWER_LEFT: u32 = 0x8CA1;
        pub const LOW_FLOAT: u32 = 0x8DF0;
        pub const LOW_INT: u32 = 0x8DF3;
        pub const LUMINANCE: u32 = 0x1909;
        pub const LUMINANCE12: u32 = 0x8041;
        pub const LUMINANCE12_ALPHA12: u32 = 0x8047;
        pub const LUMINANCE12_ALPHA4: u32 = 0x8046;
        pub const LUMINANCE16: u32 = 0x8042;
        pub const LUMINANCE16F_EXT: u32 = 0x881E;
        pub const LUMINANCE16_ALPHA16: u32 = 0x8048;
        pub const LUMINANCE32F_EXT: u32 = 0x8818;
        pub const LUMINANCE4: u32 = 0x803F;
        pub const LUMINANCE4_ALPHA4: u32 = 0x8043;
        pub const LUMINANCE6_ALPHA2: u32 = 0x8044;
        pub const LUMINANCE8: u32 = 0x8040;
        pub const LUMINANCE8_ALPHA8: u32 = 0x8045;
        pub const LUMINANCE8_ALPHA8_EXT: u32 = 0x8045;
        pub const LUMINANCE8_EXT: u32 = 0x8040;
        pub const LUMINANCE_ALPHA: u32 = 0x190A;
        pub const LUMINANCE_ALPHA16F_EXT: u32 = 0x881F;
        pub const LUMINANCE_ALPHA32F_EXT: u32 = 0x8819;
        pub const MAJOR_VERSION: u32 = 0x821B;
        pub const MAP1_COLOR_4: u32 = 0x0D90;
        pub const MAP1_GRID_DOMAIN: u32 = 0x0DD0;
        pub const MAP1_GRID_SEGMENTS: u32 = 0x0DD1;
        pub const MAP1_INDEX: u32 = 0x0D91;
        pub const MAP1_NORMAL: u32 = 0x0D92;
        pub const MAP1_TEXTURE_COORD_1: u32 = 0x0D93;
        pub const MAP1_TEXTURE_COORD_2: u32 = 0x0D94;
        pub const MAP1_TEXTURE_COORD_3: u32 = 0x0D95;
        pub const MAP1_TEXTURE_COORD_4: u32 = 0x0D96;
        pub const MAP1_VERTEX_3: u32 = 0x0D97;
        pub const MAP1_VERTEX_4: u32 = 0x0D98;
        pub const MAP2_COLOR_4: u32 = 0x0DB0;
        pub const MAP2_GRID_DOMAIN: u32 = 0x0DD2;
        pub const MAP2_GRID_SEGMENTS: u32 = 0x0DD3;
        pub const MAP2_INDEX: u32 = 0x0DB1;
        pub const MAP2_NORMAL: u32 = 0x0DB2;
        pub const MAP2_TEXTURE_COORD_1: u32 = 0x0DB3;
        pub const MAP2_TEXTURE_COORD_2: u32 = 0x0DB4;
        pub const MAP2_TEXTURE_COORD_3: u32 = 0x0DB5;
        pub const MAP2_TEXTURE_COORD_4: u32 = 0x0DB6;
        pub const MAP2_VERTEX_3: u32 = 0x0DB7;
        pub const MAP2_VERTEX_4: u32 = 0x0DB8;
        pub const MAP_COLOR: u32 = 0x0D10;
        pub const MAP_FLUSH_EXPLICIT_BIT: u32 = 0x0010;
        pub const MAP_INVALIDATE_BUFFER_BIT: u32 = 0x0008;
        pub const MAP_INVALIDATE_RANGE_BIT: u32 = 0x0004;
        pub const MAP_READ_BIT: u32 = 0x0001;
        pub const MAP_STENCIL: u32 = 0x0D11;
        pub const MAP_UNSYNCHRONIZED_BIT: u32 = 0x0020;
        pub const MAP_WRITE_BIT: u32 = 0x0002;
        pub const MATRIX_MODE: u32 = 0x0BA0;
        pub const MAX: u32 = 0x8008;
        pub const MAX_3D_TEXTURE_SIZE: u32 = 0x8073;
        pub const MAX_ARRAY_TEXTURE_LAYERS: u32 = 0x88FF;
        pub const MAX_ATTRIB_STACK_DEPTH: u32 = 0x0D35;
        pub const MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 0x0D3B;
        pub const MAX_CLIP_DISTANCES: u32 = 0x0D32;
        pub const MAX_CLIP_PLANES: u32 = 0x0D32;
        pub const MAX_COLOR_ATTACHMENTS: u32 = 0x8CDF;
        pub const MAX_COLOR_TEXTURE_SAMPLES: u32 = 0x910E;
        pub const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8A33;
        pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8A32;
        pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 0x8B4D;
        pub const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 0x8A2E;
        pub const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8A31;
        pub const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 0x851C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH: u32 = 0x826C;
        pub const MAX_DEBUG_GROUP_STACK_DEPTH_KHR: u32 = 0x826C;
        pub const MAX_DEBUG_LOGGED_MESSAGES: u32 = 0x9144;
        pub const MAX_DEBUG_LOGGED_MESSAGES_KHR: u32 = 0x9144;
        pub const MAX_DEBUG_MESSAGE_LENGTH: u32 = 0x9143;
        pub const MAX_DEBUG_MESSAGE_LENGTH_KHR: u32 = 0x9143;
        pub const MAX_DEPTH_TEXTURE_SAMPLES: u32 = 0x910F;
        pub const MAX_DRAW_BUFFERS: u32 = 0x8824;
        pub const MAX_DUAL_SOURCE_DRAW_BUFFERS: u32 = 0x88FC;
        pub const MAX_ELEMENTS_INDICES: u32 = 0x80E9;
        pub const MAX_ELEMENTS_VERTICES: u32 = 0x80E8;
        pub const MAX_ELEMENT_INDEX: u32 = 0x8D6B;
        pub const MAX_EVAL_ORDER: u32 = 0x0D30;
        pub const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 0x9125;
        pub const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 0x8A2D;
        pub const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 0x8B49;
        pub const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 0x8DFD;
        pub const MAX_GEOMETRY_INPUT_COMPONENTS: u32 = 0x9123;
        pub const MAX_GEOMETRY_OUTPUT_COMPONENTS: u32 = 0x9124;
        pub const MAX_GEOMETRY_OUTPUT_VERTICES: u32 = 0x8DE0;
        pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: u32 = 0x8C29;
        pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: u32 = 0x8DE1;
        pub const MAX_GEOMETRY_UNIFORM_BLOCKS: u32 = 0x8A2C;
        pub const MAX_GEOMETRY_UNIFORM_COMPONENTS: u32 = 0x8DDF;
        pub const MAX_INTEGER_SAMPLES: u32 = 0x9110;
        pub const MAX_LABEL_LENGTH: u32 = 0x82E8;
        pub const MAX_LABEL_LENGTH_KHR: u32 = 0x82E8;
        pub const MAX_LIGHTS: u32 = 0x0D31;
        pub const MAX_LIST_NESTING: u32 = 0x0B31;
        pub const MAX_MODELVIEW_STACK_DEPTH: u32 = 0x0D36;
        pub const MAX_NAME_STACK_DEPTH: u32 = 0x0D37;
        pub const MAX_PIXEL_MAP_TABLE: u32 = 0x0D34;
        pub const MAX_PROGRAM_TEXEL_OFFSET: u32 = 0x8905;
        pub const MAX_PROJECTION_STACK_DEPTH: u32 = 0x0D38;
        pub const MAX_RECTANGLE_TEXTURE_SIZE: u32 = 0x84F8;
        pub const MAX_RECTANGLE_TEXTURE_SIZE_ARB: u32 = 0x84F8;
        pub const MAX_RENDERBUFFER_SIZE: u32 = 0x84E8;
        pub const MAX_SAMPLES: u32 = 0x8D57;
        pub const MAX_SAMPLE_MASK_WORDS: u32 = 0x8E59;
        pub const MAX_SERVER_WAIT_TIMEOUT: u32 = 0x9111;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT: u32 = 0x8F63;
        pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT: u32 = 0x8F67;
        pub const MAX_TEXTURE_BUFFER_SIZE: u32 = 0x8C2B;
        pub const MAX_TEXTURE_COORDS: u32 = 0x8871;
        pub const MAX_TEXTURE_IMAGE_UNITS: u32 = 0x8872;
        pub const MAX_TEXTURE_LOD_BIAS: u32 = 0x84FD;
        pub const MAX_TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FF;
        pub const MAX_TEXTURE_SIZE: u32 = 0x0D33;
        pub const MAX_TEXTURE_STACK_DEPTH: u32 = 0x0D39;
        pub const MAX_TEXTURE_UNITS: u32 = 0x84E2;
        pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 0x8C8A;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 0x8C8B;
        pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 0x8C80;
        pub const MAX_UNIFORM_BLOCK_SIZE: u32 = 0x8A30;
        pub const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 0x8A2F;
        pub const MAX_VARYING_COMPONENTS: u32 = 0x8B4B;
        pub const MAX_VARYING_FLOATS: u32 = 0x8B4B;
        pub const MAX_VARYING_VECTORS: u32 = 0x8DFC;
        pub const MAX_VERTEX_ATTRIBS: u32 = 0x8869;
        pub const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 0x9122;
        pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 0x8B4C;
        pub const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 0x8A2B;
        pub const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 0x8B4A;
        pub const MAX_VERTEX_UNIFORM_VECTORS: u32 = 0x8DFB;
        pub const MAX_VIEWPORT_DIMS: u32 = 0x0D3A;
        pub const MEDIUM_FLOAT: u32 = 0x8DF1;
        pub const MEDIUM_INT: u32 = 0x8DF4;
        pub const MIN: u32 = 0x8007;
        pub const MINOR_VERSION: u32 = 0x821C;
        pub const MIN_PROGRAM_TEXEL_OFFSET: u32 = 0x8904;
        pub const MIRRORED_REPEAT: u32 = 0x8370;
        pub const MODELVIEW: u32 = 0x1700;
        pub const MODELVIEW_MATRIX: u32 = 0x0BA6;
        pub const MODELVIEW_STACK_DEPTH: u32 = 0x0BA3;
        pub const MODULATE: u32 = 0x2100;
        pub const MULT: u32 = 0x0103;
        pub const MULTIPLY_KHR: u32 = 0x9294;
        pub const MULTISAMPLE: u32 = 0x809D;
        pub const MULTISAMPLE_BIT: u32 = 0x20000000;
        pub const N3F_V3F: u32 = 0x2A25;
        pub const NAME_STACK_DEPTH: u32 = 0x0D70;
        pub const NAND: u32 = 0x150E;
        pub const NEAREST: u32 = 0x2600;
        pub const NEAREST_MIPMAP_LINEAR: u32 = 0x2702;
        pub const NEAREST_MIPMAP_NEAREST: u32 = 0x2700;
        pub const NEVER: u32 = 0x0200;
        pub const NICEST: u32 = 0x1102;
        pub const NONE: u32 = 0;
        pub const NOOP: u32 = 0x1505;
        pub const NOR: u32 = 0x1508;
        pub const NORMALIZE: u32 = 0x0BA1;
        pub const NORMAL_ARRAY: u32 = 0x8075;
        pub const NORMAL_ARRAY_BUFFER_BINDING: u32 = 0x8897;
        pub const NORMAL_ARRAY_POINTER: u32 = 0x808F;
        pub const NORMAL_ARRAY_STRIDE: u32 = 0x807F;
        pub const NORMAL_ARRAY_TYPE: u32 = 0x807E;
        pub const NORMAL_MAP: u32 = 0x8511;
        pub const NOTEQUAL: u32 = 0x0205;
        pub const NO_ERROR: u32 = 0;
        pub const NUM_COMPRESSED_TEXTURE_FORMATS: u32 = 0x86A2;
        pub const NUM_EXTENSIONS: u32 = 0x821D;
        pub const NUM_PROGRAM_BINARY_FORMATS: u32 = 0x87FE;
        pub const NUM_SAMPLE_COUNTS: u32 = 0x9380;
        pub const NUM_SHADER_BINARY_FORMATS: u32 = 0x8DF9;
        pub const OBJECT_LINEAR: u32 = 0x2401;
        pub const OBJECT_PLANE: u32 = 0x2501;
        pub const OBJECT_TYPE: u32 = 0x9112;
        pub const ONE: u32 = 1;
        pub const ONE_MINUS_CONSTANT_ALPHA: u32 = 0x8004;
        pub const ONE_MINUS_CONSTANT_COLOR: u32 = 0x8002;
        pub const ONE_MINUS_DST_ALPHA: u32 = 0x0305;
        pub const ONE_MINUS_DST_COLOR: u32 = 0x0307;
        pub const ONE_MINUS_SRC1_ALPHA: u32 = 0x88FB;
        pub const ONE_MINUS_SRC1_COLOR: u32 = 0x88FA;
        pub const ONE_MINUS_SRC_ALPHA: u32 = 0x0303;
        pub const ONE_MINUS_SRC_COLOR: u32 = 0x0301;
        pub const OPERAND0_ALPHA: u32 = 0x8598;
        pub const OPERAND0_RGB: u32 = 0x8590;
        pub const OPERAND1_ALPHA: u32 = 0x8599;
        pub const OPERAND1_RGB: u32 = 0x8591;
        pub const OPERAND2_ALPHA: u32 = 0x859A;
        pub const OPERAND2_RGB: u32 = 0x8592;
        pub const OR: u32 = 0x1507;
        pub const ORDER: u32 = 0x0A01;
        pub const OR_INVERTED: u32 = 0x150D;
        pub const OR_REVERSE: u32 = 0x150B;
        pub const OUT_OF_MEMORY: u32 = 0x0505;
        pub const OVERLAY_KHR: u32 = 0x9296;
        pub const PACK_ALIGNMENT: u32 = 0x0D05;
        pub const PACK_IMAGE_HEIGHT: u32 = 0x806C;
        pub const PACK_LSB_FIRST: u32 = 0x0D01;
        pub const PACK_ROW_LENGTH: u32 = 0x0D02;
        pub const PACK_SKIP_IMAGES: u32 = 0x806B;
        pub const PACK_SKIP_PIXELS: u32 = 0x0D04;
        pub const PACK_SKIP_ROWS: u32 = 0x0D03;
        pub const PACK_SWAP_BYTES: u32 = 0x0D00;
        pub const PASS_THROUGH_TOKEN: u32 = 0x0700;
        pub const PERSPECTIVE_CORRECTION_HINT: u32 = 0x0C50;
        pub const PIXEL_MAP_A_TO_A: u32 = 0x0C79;
        pub const PIXEL_MAP_A_TO_A_SIZE: u32 = 0x0CB9;
        pub const PIXEL_MAP_B_TO_B: u32 = 0x0C78;
        pub const PIXEL_MAP_B_TO_B_SIZE: u32 = 0x0CB8;
        pub const PIXEL_MAP_G_TO_G: u32 = 0x0C77;
        pub const PIXEL_MAP_G_TO_G_SIZE: u32 = 0x0CB7;
        pub const PIXEL_MAP_I_TO_A: u32 = 0x0C75;
        pub const PIXEL_MAP_I_TO_A_SIZE: u32 = 0x0CB5;
        pub const PIXEL_MAP_I_TO_B: u32 = 0x0C74;
        pub const PIXEL_MAP_I_TO_B_SIZE: u32 = 0x0CB4;
        pub const PIXEL_MAP_I_TO_G: u32 = 0x0C73;
        pub const PIXEL_MAP_I_TO_G_SIZE: u32 = 0x0CB3;
        pub const PIXEL_MAP_I_TO_I: u32 = 0x0C70;
        pub const PIXEL_MAP_I_TO_I_SIZE: u32 = 0x0CB0;
        pub const PIXEL_MAP_I_TO_R: u32 = 0x0C72;
        pub const PIXEL_MAP_I_TO_R_SIZE: u32 = 0x0CB2;
        pub const PIXEL_MAP_R_TO_R: u32 = 0x0C76;
        pub const PIXEL_MAP_R_TO_R_SIZE: u32 = 0x0CB6;
        pub const PIXEL_MAP_S_TO_S: u32 = 0x0C71;
        pub const PIXEL_MAP_S_TO_S_SIZE: u32 = 0x0CB1;
        pub const PIXEL_MODE_BIT: u32 = 0x00000020;
        pub const PIXEL_PACK_BUFFER: u32 = 0x88EB;
        pub const PIXEL_PACK_BUFFER_BINDING: u32 = 0x88ED;
        pub const PIXEL_UNPACK_BUFFER: u32 = 0x88EC;
        pub const PIXEL_UNPACK_BUFFER_BINDING: u32 = 0x88EF;
        pub const POINT: u32 = 0x1B00;
        pub const POINTS: u32 = 0x0000;
        pub const POINT_BIT: u32 = 0x00000002;
        pub const POINT_DISTANCE_ATTENUATION: u32 = 0x8129;
        pub const POINT_FADE_THRESHOLD_SIZE: u32 = 0x8128;
        pub const POINT_SIZE: u32 = 0x0B11;
        pub const POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const POINT_SIZE_MAX: u32 = 0x8127;
        pub const POINT_SIZE_MIN: u32 = 0x8126;
        pub const POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const POINT_SMOOTH: u32 = 0x0B10;
        pub const POINT_SMOOTH_HINT: u32 = 0x0C51;
        pub const POINT_SPRITE: u32 = 0x8861;
        pub const POINT_SPRITE_COORD_ORIGIN: u32 = 0x8CA0;
        pub const POINT_TOKEN: u32 = 0x0701;
        pub const POLYGON: u32 = 0x0009;
        pub const POLYGON_BIT: u32 = 0x00000008;
        pub const POLYGON_MODE: u32 = 0x0B40;
        pub const POLYGON_OFFSET_FACTOR: u32 = 0x8038;
        pub const POLYGON_OFFSET_FILL: u32 = 0x8037;
        pub const POLYGON_OFFSET_LINE: u32 = 0x2A02;
        pub const POLYGON_OFFSET_POINT: u32 = 0x2A01;
        pub const POLYGON_OFFSET_UNITS: u32 = 0x2A00;
        pub const POLYGON_SMOOTH: u32 = 0x0B41;
        pub const POLYGON_SMOOTH_HINT: u32 = 0x0C53;
        pub const POLYGON_STIPPLE: u32 = 0x0B42;
        pub const POLYGON_STIPPLE_BIT: u32 = 0x00000010;
        pub const POLYGON_TOKEN: u32 = 0x0703;
        pub const POSITION: u32 = 0x1203;
        pub const PREVIOUS: u32 = 0x8578;
        pub const PRIMARY_COLOR: u32 = 0x8577;
        pub const PRIMITIVES_GENERATED: u32 = 0x8C87;
        pub const PRIMITIVE_RESTART: u32 = 0x8F9D;
        pub const PRIMITIVE_RESTART_FIXED_INDEX: u32 = 0x8D69;
        pub const PRIMITIVE_RESTART_INDEX: u32 = 0x8F9E;
        pub const PROGRAM: u32 = 0x82E2;
        pub const PROGRAM_BINARY_FORMATS: u32 = 0x87FF;
        pub const PROGRAM_BINARY_LENGTH: u32 = 0x8741;
        pub const PROGRAM_BINARY_RETRIEVABLE_HINT: u32 = 0x8257;
        pub const PROGRAM_KHR: u32 = 0x82E2;
        pub const PROGRAM_PIPELINE: u32 = 0x82E4;
        pub const PROGRAM_PIPELINE_KHR: u32 = 0x82E4;
        pub const PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const PROJECTION: u32 = 0x1701;
        pub const PROJECTION_MATRIX: u32 = 0x0BA7;
        pub const PROJECTION_STACK_DEPTH: u32 = 0x0BA4;
        pub const PROVOKING_VERTEX: u32 = 0x8E4F;
        pub const PROXY_TEXTURE_1D: u32 = 0x8063;
        pub const PROXY_TEXTURE_1D_ARRAY: u32 = 0x8C19;
        pub const PROXY_TEXTURE_2D: u32 = 0x8064;
        pub const PROXY_TEXTURE_2D_ARRAY: u32 = 0x8C1B;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE: u32 = 0x9101;
        pub const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9103;
        pub const PROXY_TEXTURE_3D: u32 = 0x8070;
        pub const PROXY_TEXTURE_CUBE_MAP: u32 = 0x851B;
        pub const PROXY_TEXTURE_RECTANGLE: u32 = 0x84F7;
        pub const PROXY_TEXTURE_RECTANGLE_ARB: u32 = 0x84F7;
        pub const Q: u32 = 0x2003;
        pub const QUADRATIC_ATTENUATION: u32 = 0x1209;
        pub const QUADS: u32 = 0x0007;
        pub const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: u32 = 0x8E4C;
        pub const QUAD_STRIP: u32 = 0x0008;
        pub const QUERY: u32 = 0x82E3;
        pub const QUERY_BY_REGION_NO_WAIT: u32 = 0x8E16;
        pub const QUERY_BY_REGION_WAIT: u32 = 0x8E15;
        pub const QUERY_COUNTER_BITS: u32 = 0x8864;
        pub const QUERY_COUNTER_BITS_EXT: u32 = 0x8864;
        pub const QUERY_KHR: u32 = 0x82E3;
        pub const QUERY_NO_WAIT: u32 = 0x8E14;
        pub const QUERY_RESULT: u32 = 0x8866;
        pub const QUERY_RESULT_AVAILABLE: u32 = 0x8867;
        pub const QUERY_RESULT_AVAILABLE_EXT: u32 = 0x8867;
        pub const QUERY_RESULT_EXT: u32 = 0x8866;
        pub const QUERY_WAIT: u32 = 0x8E13;
        pub const R: u32 = 0x2002;
        pub const R11F_G11F_B10F: u32 = 0x8C3A;
        pub const R16: u32 = 0x822A;
        pub const R16F: u32 = 0x822D;
        pub const R16F_EXT: u32 = 0x822D;
        pub const R16I: u32 = 0x8233;
        pub const R16UI: u32 = 0x8234;
        pub const R16_SNORM: u32 = 0x8F98;
        pub const R32F: u32 = 0x822E;
        pub const R32F_EXT: u32 = 0x822E;
        pub const R32I: u32 = 0x8235;
        pub const R32UI: u32 = 0x8236;
        pub const R3_G3_B2: u32 = 0x2A10;
        pub const R8: u32 = 0x8229;
        pub const R8I: u32 = 0x8231;
        pub const R8UI: u32 = 0x8232;
        pub const R8_EXT: u32 = 0x8229;
        pub const R8_SNORM: u32 = 0x8F94;
        pub const RASTERIZER_DISCARD: u32 = 0x8C89;
        pub const READ_BUFFER: u32 = 0x0C02;
        pub const READ_FRAMEBUFFER: u32 = 0x8CA8;
        pub const READ_FRAMEBUFFER_BINDING: u32 = 0x8CAA;
        pub const READ_ONLY: u32 = 0x88B8;
        pub const READ_WRITE: u32 = 0x88BA;
        pub const RED: u32 = 0x1903;
        pub const RED_BIAS: u32 = 0x0D15;
        pub const RED_BITS: u32 = 0x0D52;
        pub const RED_INTEGER: u32 = 0x8D94;
        pub const RED_SCALE: u32 = 0x0D14;
        pub const REFLECTION_MAP: u32 = 0x8512;
        pub const RENDER: u32 = 0x1C00;
        pub const RENDERBUFFER: u32 = 0x8D41;
        pub const RENDERBUFFER_ALPHA_SIZE: u32 = 0x8D53;
        pub const RENDERBUFFER_BINDING: u32 = 0x8CA7;
        pub const RENDERBUFFER_BLUE_SIZE: u32 = 0x8D52;
        pub const RENDERBUFFER_DEPTH_SIZE: u32 = 0x8D54;
        pub const RENDERBUFFER_GREEN_SIZE: u32 = 0x8D51;
        pub const RENDERBUFFER_HEIGHT: u32 = 0x8D43;
        pub const RENDERBUFFER_INTERNAL_FORMAT: u32 = 0x8D44;
        pub const RENDERBUFFER_RED_SIZE: u32 = 0x8D50;
        pub const RENDERBUFFER_SAMPLES: u32 = 0x8CAB;
        pub const RENDERBUFFER_STENCIL_SIZE: u32 = 0x8D55;
        pub const RENDERBUFFER_WIDTH: u32 = 0x8D42;
        pub const RENDERER: u32 = 0x1F01;
        pub const RENDER_MODE: u32 = 0x0C40;
        pub const REPEAT: u32 = 0x2901;
        pub const REPLACE: u32 = 0x1E01;
        pub const REQUIRED_TEXTURE_IMAGE_UNITS_OES: u32 = 0x8D68;
        pub const RESCALE_NORMAL: u32 = 0x803A;
        pub const RETURN: u32 = 0x0102;
        pub const RG: u32 = 0x8227;
        pub const RG16: u32 = 0x822C;
        pub const RG16F: u32 = 0x822F;
        pub const RG16F_EXT: u32 = 0x822F;
        pub const RG16I: u32 = 0x8239;
        pub const RG16UI: u32 = 0x823A;
        pub const RG16_SNORM: u32 = 0x8F99;
        pub const RG32F: u32 = 0x8230;
        pub const RG32F_EXT: u32 = 0x8230;
        pub const RG32I: u32 = 0x823B;
        pub const RG32UI: u32 = 0x823C;
        pub const RG8: u32 = 0x822B;
        pub const RG8I: u32 = 0x8237;
        pub const RG8UI: u32 = 0x8238;
        pub const RG8_EXT: u32 = 0x822B;
        pub const RG8_SNORM: u32 = 0x8F95;
        pub const RGB: u32 = 0x1907;
        pub const RGB10: u32 = 0x8052;
        pub const RGB10_A2: u32 = 0x8059;
        pub const RGB10_A2UI: u32 = 0x906F;
        pub const RGB10_A2_EXT: u32 = 0x8059;
        pub const RGB10_EXT: u32 = 0x8052;
        pub const RGB12: u32 = 0x8053;
        pub const RGB16: u32 = 0x8054;
        pub const RGB16F: u32 = 0x881B;
        pub const RGB16F_EXT: u32 = 0x881B;
        pub const RGB16I: u32 = 0x8D89;
        pub const RGB16UI: u32 = 0x8D77;
        pub const RGB16_SNORM: u32 = 0x8F9A;
        pub const RGB32F: u32 = 0x8815;
        pub const RGB32F_EXT: u32 = 0x8815;
        pub const RGB32I: u32 = 0x8D83;
        pub const RGB32UI: u32 = 0x8D71;
        pub const RGB4: u32 = 0x804F;
        pub const RGB5: u32 = 0x8050;
        pub const RGB565: u32 = 0x8D62;
        pub const RGB5_A1: u32 = 0x8057;
        pub const RGB8: u32 = 0x8051;
        pub const RGB8I: u32 = 0x8D8F;
        pub const RGB8UI: u32 = 0x8D7D;
        pub const RGB8_SNORM: u32 = 0x8F96;
        pub const RGB9_E5: u32 = 0x8C3D;
        pub const RGBA: u32 = 0x1908;
        pub const RGBA12: u32 = 0x805A;
        pub const RGBA16: u32 = 0x805B;
        pub const RGBA16F: u32 = 0x881A;
        pub const RGBA16F_EXT: u32 = 0x881A;
        pub const RGBA16I: u32 = 0x8D88;
        pub const RGBA16UI: u32 = 0x8D76;
        pub const RGBA16_SNORM: u32 = 0x8F9B;
        pub const RGBA2: u32 = 0x8055;
        pub const RGBA32F: u32 = 0x8814;
        pub const RGBA32F_EXT: u32 = 0x8814;
        pub const RGBA32I: u32 = 0x8D82;
        pub const RGBA32UI: u32 = 0x8D70;
        pub const RGBA4: u32 = 0x8056;
        pub const RGBA8: u32 = 0x8058;
        pub const RGBA8I: u32 = 0x8D8E;
        pub const RGBA8UI: u32 = 0x8D7C;
        pub const RGBA8_SNORM: u32 = 0x8F97;
        pub const RGBA_INTEGER: u32 = 0x8D99;
        pub const RGBA_MODE: u32 = 0x0C31;
        pub const RGB_INTEGER: u32 = 0x8D98;
        pub const RGB_SCALE: u32 = 0x8573;
        pub const RG_INTEGER: u32 = 0x8228;
        pub const RIGHT: u32 = 0x0407;
        pub const S: u32 = 0x2000;
        pub const SAMPLER: u32 = 0x82E6;
        pub const SAMPLER_1D: u32 = 0x8B5D;
        pub const SAMPLER_1D_ARRAY: u32 = 0x8DC0;
        pub const SAMPLER_1D_ARRAY_SHADOW: u32 = 0x8DC3;
        pub const SAMPLER_1D_SHADOW: u32 = 0x8B61;
        pub const SAMPLER_2D: u32 = 0x8B5E;
        pub const SAMPLER_2D_ARRAY: u32 = 0x8DC1;
        pub const SAMPLER_2D_ARRAY_SHADOW: u32 = 0x8DC4;
        pub const SAMPLER_2D_MULTISAMPLE: u32 = 0x9108;
        pub const SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910B;
        pub const SAMPLER_2D_RECT: u32 = 0x8B63;
        pub const SAMPLER_2D_RECT_SHADOW: u32 = 0x8B64;
        pub const SAMPLER_2D_SHADOW: u32 = 0x8B62;
        pub const SAMPLER_3D: u32 = 0x8B5F;
        pub const SAMPLER_BINDING: u32 = 0x8919;
        pub const SAMPLER_BUFFER: u32 = 0x8DC2;
        pub const SAMPLER_CUBE: u32 = 0x8B60;
        pub const SAMPLER_CUBE_SHADOW: u32 = 0x8DC5;
        pub const SAMPLER_EXTERNAL_OES: u32 = 0x8D66;
        pub const SAMPLER_KHR: u32 = 0x82E6;
        pub const SAMPLES: u32 = 0x80A9;
        pub const SAMPLES_PASSED: u32 = 0x8914;
        pub const SAMPLE_ALPHA_TO_COVERAGE: u32 = 0x809E;
        pub const SAMPLE_ALPHA_TO_ONE: u32 = 0x809F;
        pub const SAMPLE_BUFFERS: u32 = 0x80A8;
        pub const SAMPLE_COVERAGE: u32 = 0x80A0;
        pub const SAMPLE_COVERAGE_INVERT: u32 = 0x80AB;
        pub const SAMPLE_COVERAGE_VALUE: u32 = 0x80AA;
        pub const SAMPLE_MASK: u32 = 0x8E51;
        pub const SAMPLE_MASK_VALUE: u32 = 0x8E52;
        pub const SAMPLE_POSITION: u32 = 0x8E50;
        pub const SCISSOR_BIT: u32 = 0x00080000;
        pub const SCISSOR_BOX: u32 = 0x0C10;
        pub const SCISSOR_TEST: u32 = 0x0C11;
        pub const SCREEN_KHR: u32 = 0x9295;
        pub const SECONDARY_COLOR_ARRAY: u32 = 0x845E;
        pub const SECONDARY_COLOR_ARRAY_BUFFER_BINDING: u32 = 0x889C;
        pub const SECONDARY_COLOR_ARRAY_POINTER: u32 = 0x845D;
        pub const SECONDARY_COLOR_ARRAY_SIZE: u32 = 0x845A;
        pub const SECONDARY_COLOR_ARRAY_STRIDE: u32 = 0x845C;
        pub const SECONDARY_COLOR_ARRAY_TYPE: u32 = 0x845B;
        pub const SELECT: u32 = 0x1C02;
        pub const SELECTION_BUFFER_POINTER: u32 = 0x0DF3;
        pub const SELECTION_BUFFER_SIZE: u32 = 0x0DF4;
        pub const SEPARATE_ATTRIBS: u32 = 0x8C8D;
        pub const SEPARATE_SPECULAR_COLOR: u32 = 0x81FA;
        pub const SET: u32 = 0x150F;
        pub const SHADER: u32 = 0x82E1;
        pub const SHADER_BINARY_FORMATS: u32 = 0x8DF8;
        pub const SHADER_COMPILER: u32 = 0x8DFA;
        pub const SHADER_KHR: u32 = 0x82E1;
        pub const SHADER_PIXEL_LOCAL_STORAGE_EXT: u32 = 0x8F64;
        pub const SHADER_SOURCE_LENGTH: u32 = 0x8B88;
        pub const SHADER_TYPE: u32 = 0x8B4F;
        pub const SHADE_MODEL: u32 = 0x0B54;
        pub const SHADING_LANGUAGE_VERSION: u32 = 0x8B8C;
        pub const SHININESS: u32 = 0x1601;
        pub const SHORT: u32 = 0x1402;
        pub const SIGNALED: u32 = 0x9119;
        pub const SIGNED_NORMALIZED: u32 = 0x8F9C;
        pub const SINGLE_COLOR: u32 = 0x81F9;
        pub const SLUMINANCE: u32 = 0x8C46;
        pub const SLUMINANCE8: u32 = 0x8C47;
        pub const SLUMINANCE8_ALPHA8: u32 = 0x8C45;
        pub const SLUMINANCE_ALPHA: u32 = 0x8C44;
        pub const SMOOTH: u32 = 0x1D01;
        pub const SMOOTH_LINE_WIDTH_GRANULARITY: u32 = 0x0B23;
        pub const SMOOTH_LINE_WIDTH_RANGE: u32 = 0x0B22;
        pub const SMOOTH_POINT_SIZE_GRANULARITY: u32 = 0x0B13;
        pub const SMOOTH_POINT_SIZE_RANGE: u32 = 0x0B12;
        pub const SOFTLIGHT_KHR: u32 = 0x929C;
        pub const SOURCE0_ALPHA: u32 = 0x8588;
        pub const SOURCE0_RGB: u32 = 0x8580;
        pub const SOURCE1_ALPHA: u32 = 0x8589;
        pub const SOURCE1_RGB: u32 = 0x8581;
        pub const SOURCE2_ALPHA: u32 = 0x858A;
        pub const SOURCE2_RGB: u32 = 0x8582;
        pub const SPECULAR: u32 = 0x1202;
        pub const SPHERE_MAP: u32 = 0x2402;
        pub const SPOT_CUTOFF: u32 = 0x1206;
        pub const SPOT_DIRECTION: u32 = 0x1204;
        pub const SPOT_EXPONENT: u32 = 0x1205;
        pub const SRC0_ALPHA: u32 = 0x8588;
        pub const SRC0_RGB: u32 = 0x8580;
        pub const SRC1_ALPHA: u32 = 0x8589;
        pub const SRC1_COLOR: u32 = 0x88F9;
        pub const SRC1_RGB: u32 = 0x8581;
        pub const SRC2_ALPHA: u32 = 0x858A;
        pub const SRC2_RGB: u32 = 0x8582;
        pub const SRC_ALPHA: u32 = 0x0302;
        pub const SRC_ALPHA_SATURATE: u32 = 0x0308;
        pub const SRC_COLOR: u32 = 0x0300;
        pub const SRGB: u32 = 0x8C40;
        pub const SRGB8: u32 = 0x8C41;
        pub const SRGB8_ALPHA8: u32 = 0x8C43;
        pub const SRGB_ALPHA: u32 = 0x8C42;
        pub const STACK_OVERFLOW: u32 = 0x0503;
        pub const STACK_OVERFLOW_KHR: u32 = 0x0503;
        pub const STACK_UNDERFLOW: u32 = 0x0504;
        pub const STACK_UNDERFLOW_KHR: u32 = 0x0504;
        pub const STATIC_COPY: u32 = 0x88E6;
        pub const STATIC_DRAW: u32 = 0x88E4;
        pub const STATIC_READ: u32 = 0x88E5;
        pub const STENCIL: u32 = 0x1802;
        pub const STENCIL_ATTACHMENT: u32 = 0x8D20;
        pub const STENCIL_BACK_FAIL: u32 = 0x8801;
        pub const STENCIL_BACK_FUNC: u32 = 0x8800;
        pub const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 0x8802;
        pub const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 0x8803;
        pub const STENCIL_BACK_REF: u32 = 0x8CA3;
        pub const STENCIL_BACK_VALUE_MASK: u32 = 0x8CA4;
        pub const STENCIL_BACK_WRITEMASK: u32 = 0x8CA5;
        pub const STENCIL_BITS: u32 = 0x0D57;
        pub const STENCIL_BUFFER_BIT: u32 = 0x00000400;
        pub const STENCIL_CLEAR_VALUE: u32 = 0x0B91;
        pub const STENCIL_FAIL: u32 = 0x0B94;
        pub const STENCIL_FUNC: u32 = 0x0B92;
        pub const STENCIL_INDEX: u32 = 0x1901;
        pub const STENCIL_INDEX1: u32 = 0x8D46;
        pub const STENCIL_INDEX16: u32 = 0x8D49;
        pub const STENCIL_INDEX4: u32 = 0x8D47;
        pub const STENCIL_INDEX8: u32 = 0x8D48;
        pub const STENCIL_PASS_DEPTH_FAIL: u32 = 0x0B95;
        pub const STENCIL_PASS_DEPTH_PASS: u32 = 0x0B96;
        pub const STENCIL_REF: u32 = 0x0B97;
        pub const STENCIL_TEST: u32 = 0x0B90;
        pub const STENCIL_VALUE_MASK: u32 = 0x0B93;
        pub const STENCIL_WRITEMASK: u32 = 0x0B98;
        pub const STEREO: u32 = 0x0C33;
        pub const STORAGE_CACHED_APPLE: u32 = 0x85BE;
        pub const STORAGE_PRIVATE_APPLE: u32 = 0x85BD;
        pub const STORAGE_SHARED_APPLE: u32 = 0x85BF;
        pub const STREAM_COPY: u32 = 0x88E2;
        pub const STREAM_DRAW: u32 = 0x88E0;
        pub const STREAM_READ: u32 = 0x88E1;
        pub const SUBPIXEL_BITS: u32 = 0x0D50;
        pub const SUBTRACT: u32 = 0x84E7;
        pub const SYNC_CONDITION: u32 = 0x9113;
        pub const SYNC_FENCE: u32 = 0x9116;
        pub const SYNC_FLAGS: u32 = 0x9115;
        pub const SYNC_FLUSH_COMMANDS_BIT: u32 = 0x00000001;
        pub const SYNC_GPU_COMMANDS_COMPLETE: u32 = 0x9117;
        pub const SYNC_STATUS: u32 = 0x9114;
        pub const T: u32 = 0x2001;
        pub const T2F_C3F_V3F: u32 = 0x2A2A;
        pub const T2F_C4F_N3F_V3F: u32 = 0x2A2C;
        pub const T2F_C4UB_V3F: u32 = 0x2A29;
        pub const T2F_N3F_V3F: u32 = 0x2A2B;
        pub const T2F_V3F: u32 = 0x2A27;
        pub const T4F_C4F_N3F_V4F: u32 = 0x2A2D;
        pub const T4F_V4F: u32 = 0x2A28;
        pub const TEXTURE: u32 = 0x1702;
        pub const TEXTURE0: u32 = 0x84C0;
        pub const TEXTURE1: u32 = 0x84C1;
        pub const TEXTURE10: u32 = 0x84CA;
        pub const TEXTURE11: u32 = 0x84CB;
        pub const TEXTURE12: u32 = 0x84CC;
        pub const TEXTURE13: u32 = 0x84CD;
        pub const TEXTURE14: u32 = 0x84CE;
        pub const TEXTURE15: u32 = 0x84CF;
        pub const TEXTURE16: u32 = 0x84D0;
        pub const TEXTURE17: u32 = 0x84D1;
        pub const TEXTURE18: u32 = 0x84D2;
        pub const TEXTURE19: u32 = 0x84D3;
        pub const TEXTURE2: u32 = 0x84C2;
        pub const TEXTURE20: u32 = 0x84D4;
        pub const TEXTURE21: u32 = 0x84D5;
        pub const TEXTURE22: u32 = 0x84D6;
        pub const TEXTURE23: u32 = 0x84D7;
        pub const TEXTURE24: u32 = 0x84D8;
        pub const TEXTURE25: u32 = 0x84D9;
        pub const TEXTURE26: u32 = 0x84DA;
        pub const TEXTURE27: u32 = 0x84DB;
        pub const TEXTURE28: u32 = 0x84DC;
        pub const TEXTURE29: u32 = 0x84DD;
        pub const TEXTURE3: u32 = 0x84C3;
        pub const TEXTURE30: u32 = 0x84DE;
        pub const TEXTURE31: u32 = 0x84DF;
        pub const TEXTURE4: u32 = 0x84C4;
        pub const TEXTURE5: u32 = 0x84C5;
        pub const TEXTURE6: u32 = 0x84C6;
        pub const TEXTURE7: u32 = 0x84C7;
        pub const TEXTURE8: u32 = 0x84C8;
        pub const TEXTURE9: u32 = 0x84C9;
        pub const TEXTURE_1D: u32 = 0x0DE0;
        pub const TEXTURE_1D_ARRAY: u32 = 0x8C18;
        pub const TEXTURE_2D: u32 = 0x0DE1;
        pub const TEXTURE_2D_ARRAY: u32 = 0x8C1A;
        pub const TEXTURE_2D_MULTISAMPLE: u32 = 0x9100;
        pub const TEXTURE_2D_MULTISAMPLE_ARRAY: u32 = 0x9102;
        pub const TEXTURE_3D: u32 = 0x806F;
        pub const TEXTURE_ALPHA_SIZE: u32 = 0x805F;
        pub const TEXTURE_ALPHA_TYPE: u32 = 0x8C13;
        pub const TEXTURE_BASE_LEVEL: u32 = 0x813C;
        pub const TEXTURE_BINDING_1D: u32 = 0x8068;
        pub const TEXTURE_BINDING_1D_ARRAY: u32 = 0x8C1C;
        pub const TEXTURE_BINDING_2D: u32 = 0x8069;
        pub const TEXTURE_BINDING_2D_ARRAY: u32 = 0x8C1D;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE: u32 = 0x9104;
        pub const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: u32 = 0x9105;
        pub const TEXTURE_BINDING_3D: u32 = 0x806A;
        pub const TEXTURE_BINDING_BUFFER: u32 = 0x8C2C;
        pub const TEXTURE_BINDING_CUBE_MAP: u32 = 0x8514;
        pub const TEXTURE_BINDING_EXTERNAL_OES: u32 = 0x8D67;
        pub const TEXTURE_BINDING_RECTANGLE: u32 = 0x84F6;
        pub const TEXTURE_BINDING_RECTANGLE_ARB: u32 = 0x84F6;
        pub const TEXTURE_BIT: u32 = 0x00040000;
        pub const TEXTURE_BLUE_SIZE: u32 = 0x805E;
        pub const TEXTURE_BLUE_TYPE: u32 = 0x8C12;
        pub const TEXTURE_BORDER: u32 = 0x1005;
        pub const TEXTURE_BORDER_COLOR: u32 = 0x1004;
        pub const TEXTURE_BUFFER: u32 = 0x8C2A;
        pub const TEXTURE_BUFFER_DATA_STORE_BINDING: u32 = 0x8C2D;
        pub const TEXTURE_COMPARE_FUNC: u32 = 0x884D;
        pub const TEXTURE_COMPARE_MODE: u32 = 0x884C;
        pub const TEXTURE_COMPONENTS: u32 = 0x1003;
        pub const TEXTURE_COMPRESSED: u32 = 0x86A1;
        pub const TEXTURE_COMPRESSED_IMAGE_SIZE: u32 = 0x86A0;
        pub const TEXTURE_COMPRESSION_HINT: u32 = 0x84EF;
        pub const TEXTURE_COORD_ARRAY: u32 = 0x8078;
        pub const TEXTURE_COORD_ARRAY_BUFFER_BINDING: u32 = 0x889A;
        pub const TEXTURE_COORD_ARRAY_POINTER: u32 = 0x8092;
        pub const TEXTURE_COORD_ARRAY_SIZE: u32 = 0x8088;
        pub const TEXTURE_COORD_ARRAY_STRIDE: u32 = 0x808A;
        pub const TEXTURE_COORD_ARRAY_TYPE: u32 = 0x8089;
        pub const TEXTURE_CUBE_MAP: u32 = 0x8513;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 0x8516;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 0x8518;
        pub const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 0x851A;
        pub const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 0x8515;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 0x8517;
        pub const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 0x8519;
        pub const TEXTURE_CUBE_MAP_SEAMLESS: u32 = 0x884F;
        pub const TEXTURE_DEPTH: u32 = 0x8071;
        pub const TEXTURE_DEPTH_SIZE: u32 = 0x884A;
        pub const TEXTURE_DEPTH_TYPE: u32 = 0x8C16;
        pub const TEXTURE_ENV: u32 = 0x2300;
        pub const TEXTURE_ENV_COLOR: u32 = 0x2201;
        pub const TEXTURE_ENV_MODE: u32 = 0x2200;
        pub const TEXTURE_EXTERNAL_OES: u32 = 0x8D65;
        pub const TEXTURE_FILTER_CONTROL: u32 = 0x8500;
        pub const TEXTURE_FIXED_SAMPLE_LOCATIONS: u32 = 0x9107;
        pub const TEXTURE_GEN_MODE: u32 = 0x2500;
        pub const TEXTURE_GEN_Q: u32 = 0x0C63;
        pub const TEXTURE_GEN_R: u32 = 0x0C62;
        pub const TEXTURE_GEN_S: u32 = 0x0C60;
        pub const TEXTURE_GEN_T: u32 = 0x0C61;
        pub const TEXTURE_GREEN_SIZE: u32 = 0x805D;
        pub const TEXTURE_GREEN_TYPE: u32 = 0x8C11;
        pub const TEXTURE_HEIGHT: u32 = 0x1001;
        pub const TEXTURE_IMMUTABLE_FORMAT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_FORMAT_EXT: u32 = 0x912F;
        pub const TEXTURE_IMMUTABLE_LEVELS: u32 = 0x82DF;
        pub const TEXTURE_INTENSITY_SIZE: u32 = 0x8061;
        pub const TEXTURE_INTENSITY_TYPE: u32 = 0x8C15;
        pub const TEXTURE_INTERNAL_FORMAT: u32 = 0x1003;
        pub const TEXTURE_LOD_BIAS: u32 = 0x8501;
        pub const TEXTURE_LUMINANCE_SIZE: u32 = 0x8060;
        pub const TEXTURE_LUMINANCE_TYPE: u32 = 0x8C14;
        pub const TEXTURE_MAG_FILTER: u32 = 0x2800;
        pub const TEXTURE_MATRIX: u32 = 0x0BA8;
        pub const TEXTURE_MAX_ANISOTROPY_EXT: u32 = 0x84FE;
        pub const TEXTURE_MAX_LEVEL: u32 = 0x813D;
        pub const TEXTURE_MAX_LOD: u32 = 0x813B;
        pub const TEXTURE_MIN_FILTER: u32 = 0x2801;
        pub const TEXTURE_MIN_LOD: u32 = 0x813A;
        pub const TEXTURE_PRIORITY: u32 = 0x8066;
        pub const TEXTURE_RANGE_LENGTH_APPLE: u32 = 0x85B7;
        pub const TEXTURE_RANGE_POINTER_APPLE: u32 = 0x85B8;
        pub const TEXTURE_RECTANGLE: u32 = 0x84F5;
        pub const TEXTURE_RECTANGLE_ARB: u32 = 0x84F5;
        pub const TEXTURE_RED_SIZE: u32 = 0x805C;
        pub const TEXTURE_RED_TYPE: u32 = 0x8C10;
        pub const TEXTURE_RESIDENT: u32 = 0x8067;
        pub const TEXTURE_SAMPLES: u32 = 0x9106;
        pub const TEXTURE_SHARED_SIZE: u32 = 0x8C3F;
        pub const TEXTURE_STACK_DEPTH: u32 = 0x0BA5;
        pub const TEXTURE_STENCIL_SIZE: u32 = 0x88F1;
        pub const TEXTURE_STORAGE_HINT_APPLE: u32 = 0x85BC;
        pub const TEXTURE_SWIZZLE_A: u32 = 0x8E45;
        pub const TEXTURE_SWIZZLE_B: u32 = 0x8E44;
        pub const TEXTURE_SWIZZLE_G: u32 = 0x8E43;
        pub const TEXTURE_SWIZZLE_R: u32 = 0x8E42;
        pub const TEXTURE_SWIZZLE_RGBA: u32 = 0x8E46;
        pub const TEXTURE_USAGE_ANGLE: u32 = 0x93A2;
        pub const TEXTURE_WIDTH: u32 = 0x1000;
        pub const TEXTURE_WRAP_R: u32 = 0x8072;
        pub const TEXTURE_WRAP_S: u32 = 0x2802;
        pub const TEXTURE_WRAP_T: u32 = 0x2803;
        pub const TIMEOUT_EXPIRED: u32 = 0x911B;
        pub const TIMEOUT_IGNORED: u64 = 0xFFFFFFFFFFFFFFFF;
        pub const TIMESTAMP: u32 = 0x8E28;
        pub const TIMESTAMP_EXT: u32 = 0x8E28;
        pub const TIME_ELAPSED: u32 = 0x88BF;
        pub const TIME_ELAPSED_EXT: u32 = 0x88BF;
        pub const TRANSFORM_BIT: u32 = 0x00001000;
        pub const TRANSFORM_FEEDBACK: u32 = 0x8E22;
        pub const TRANSFORM_FEEDBACK_ACTIVE: u32 = 0x8E24;
        pub const TRANSFORM_FEEDBACK_BINDING: u32 = 0x8E25;
        pub const TRANSFORM_FEEDBACK_BUFFER: u32 = 0x8C8E;
        pub const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 0x8C8F;
        pub const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 0x8C7F;
        pub const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 0x8C85;
        pub const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 0x8C84;
        pub const TRANSFORM_FEEDBACK_PAUSED: u32 = 0x8E23;
        pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 0x8C88;
        pub const TRANSFORM_FEEDBACK_VARYINGS: u32 = 0x8C83;
        pub const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: u32 = 0x8C76;
        pub const TRANSPOSE_COLOR_MATRIX: u32 = 0x84E6;
        pub const TRANSPOSE_MODELVIEW_MATRIX: u32 = 0x84E3;
        pub const TRANSPOSE_PROJECTION_MATRIX: u32 = 0x84E4;
        pub const TRANSPOSE_TEXTURE_MATRIX: u32 = 0x84E5;
        pub const TRIANGLES: u32 = 0x0004;
        pub const TRIANGLES_ADJACENCY: u32 = 0x000C;
        pub const TRIANGLE_FAN: u32 = 0x0006;
        pub const TRIANGLE_STRIP: u32 = 0x0005;
        pub const TRIANGLE_STRIP_ADJACENCY: u32 = 0x000D;
        pub const TRUE: u8 = 1;
        pub const UNIFORM_ARRAY_STRIDE: u32 = 0x8A3C;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 0x8A42;
        pub const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 0x8A43;
        pub const UNIFORM_BLOCK_BINDING: u32 = 0x8A3F;
        pub const UNIFORM_BLOCK_DATA_SIZE: u32 = 0x8A40;
        pub const UNIFORM_BLOCK_INDEX: u32 = 0x8A3A;
        pub const UNIFORM_BLOCK_NAME_LENGTH: u32 = 0x8A41;
        pub const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 0x8A46;
        pub const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: u32 = 0x8A45;
        pub const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 0x8A44;
        pub const UNIFORM_BUFFER: u32 = 0x8A11;
        pub const UNIFORM_BUFFER_BINDING: u32 = 0x8A28;
        pub const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 0x8A34;
        pub const UNIFORM_BUFFER_SIZE: u32 = 0x8A2A;
        pub const UNIFORM_BUFFER_START: u32 = 0x8A29;
        pub const UNIFORM_IS_ROW_MAJOR: u32 = 0x8A3E;
        pub const UNIFORM_MATRIX_STRIDE: u32 = 0x8A3D;
        pub const UNIFORM_NAME_LENGTH: u32 = 0x8A39;
        pub const UNIFORM_OFFSET: u32 = 0x8A3B;
        pub const UNIFORM_SIZE: u32 = 0x8A38;
        pub const UNIFORM_TYPE: u32 = 0x8A37;
        pub const UNPACK_ALIGNMENT: u32 = 0x0CF5;
        pub const UNPACK_CLIENT_STORAGE_APPLE: u32 = 0x85B2;
        pub const UNPACK_IMAGE_HEIGHT: u32 = 0x806E;
        pub const UNPACK_LSB_FIRST: u32 = 0x0CF1;
        pub const UNPACK_ROW_LENGTH: u32 = 0x0CF2;
        pub const UNPACK_SKIP_IMAGES: u32 = 0x806D;
        pub const UNPACK_SKIP_PIXELS: u32 = 0x0CF4;
        pub const UNPACK_SKIP_ROWS: u32 = 0x0CF3;
        pub const UNPACK_SWAP_BYTES: u32 = 0x0CF0;
        pub const UNSIGNALED: u32 = 0x9118;
        pub const UNSIGNED_BYTE: u32 = 0x1401;
        pub const UNSIGNED_BYTE_2_3_3_REV: u32 = 0x8362;
        pub const UNSIGNED_BYTE_3_3_2: u32 = 0x8032;
        pub const UNSIGNED_INT: u32 = 0x1405;
        pub const UNSIGNED_INT_10F_11F_11F_REV: u32 = 0x8C3B;
        pub const UNSIGNED_INT_10_10_10_2: u32 = 0x8036;
        pub const UNSIGNED_INT_24_8: u32 = 0x84FA;
        pub const UNSIGNED_INT_2_10_10_10_REV: u32 = 0x8368;
        pub const UNSIGNED_INT_5_9_9_9_REV: u32 = 0x8C3E;
        pub const UNSIGNED_INT_8_8_8_8: u32 = 0x8035;
        pub const UNSIGNED_INT_8_8_8_8_REV: u32 = 0x8367;
        pub const UNSIGNED_INT_SAMPLER_1D: u32 = 0x8DD1;
        pub const UNSIGNED_INT_SAMPLER_1D_ARRAY: u32 = 0x8DD6;
        pub const UNSIGNED_INT_SAMPLER_2D: u32 = 0x8DD2;
        pub const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 0x8DD7;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: u32 = 0x910A;
        pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: u32 = 0x910D;
        pub const UNSIGNED_INT_SAMPLER_2D_RECT: u32 = 0x8DD5;
        pub const UNSIGNED_INT_SAMPLER_3D: u32 = 0x8DD3;
        pub const UNSIGNED_INT_SAMPLER_BUFFER: u32 = 0x8DD8;
        pub const UNSIGNED_INT_SAMPLER_CUBE: u32 = 0x8DD4;
        pub const UNSIGNED_INT_VEC2: u32 = 0x8DC6;
        pub const UNSIGNED_INT_VEC3: u32 = 0x8DC7;
        pub const UNSIGNED_INT_VEC4: u32 = 0x8DC8;
        pub const UNSIGNED_NORMALIZED: u32 = 0x8C17;
        pub const UNSIGNED_SHORT: u32 = 0x1403;
        pub const UNSIGNED_SHORT_1_5_5_5_REV: u32 = 0x8366;
        pub const UNSIGNED_SHORT_4_4_4_4: u32 = 0x8033;
        pub const UNSIGNED_SHORT_4_4_4_4_REV: u32 = 0x8365;
        pub const UNSIGNED_SHORT_5_5_5_1: u32 = 0x8034;
        pub const UNSIGNED_SHORT_5_6_5: u32 = 0x8363;
        pub const UNSIGNED_SHORT_5_6_5_REV: u32 = 0x8364;
        pub const UPPER_LEFT: u32 = 0x8CA2;
        pub const V2F: u32 = 0x2A20;
        pub const V3F: u32 = 0x2A21;
        pub const VALIDATE_STATUS: u32 = 0x8B83;
        pub const VENDOR: u32 = 0x1F00;
        pub const VERSION: u32 = 0x1F02;
        pub const VERTEX_ARRAY: u32 = 0x8074;
        pub const VERTEX_ARRAY_BINDING: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BINDING_APPLE: u32 = 0x85B5;
        pub const VERTEX_ARRAY_BUFFER_BINDING: u32 = 0x8896;
        pub const VERTEX_ARRAY_KHR: u32 = 0x8074;
        pub const VERTEX_ARRAY_POINTER: u32 = 0x808E;
        pub const VERTEX_ARRAY_SIZE: u32 = 0x807A;
        pub const VERTEX_ARRAY_STRIDE: u32 = 0x807C;
        pub const VERTEX_ARRAY_TYPE: u32 = 0x807B;
        pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 0x889F;
        pub const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 0x88FE;
        pub const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 0x8622;
        pub const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 0x88FD;
        pub const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 0x886A;
        pub const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 0x8645;
        pub const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 0x8623;
        pub const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 0x8624;
        pub const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 0x8625;
        pub const VERTEX_PROGRAM_POINT_SIZE: u32 = 0x8642;
        pub const VERTEX_PROGRAM_TWO_SIDE: u32 = 0x8643;
        pub const VERTEX_SHADER: u32 = 0x8B31;
        pub const VIEWPORT: u32 = 0x0BA2;
        pub const VIEWPORT_BIT: u32 = 0x00000800;
        pub const WAIT_FAILED: u32 = 0x911D;
        pub const WEIGHT_ARRAY_BUFFER_BINDING: u32 = 0x889E;
        pub const WRITE_ONLY: u32 = 0x88B9;
        pub const XOR: u32 = 0x1506;
        pub const ZERO: u32 = 0;
        pub const ZOOM_X: u32 = 0x0D16;
        pub const ZOOM_Y: u32 = 0x0D17;

        /// Calls the `Gl::get_type` function.
        pub fn get_type(&self)  -> crate::gl::GlType {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getType(&self._0) }) } }
        /// Calls the `Gl::buffer_data_untyped` function.
        pub fn buffer_data_untyped(&self, target: u32, size: isize, data: GlVoidPtrConst, usage: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bufferDataUntyped(&self._0, target, size, data._0, usage) }) } }
        /// Calls the `Gl::buffer_sub_data_untyped` function.
        pub fn buffer_sub_data_untyped(&self, target: u32, offset: isize, size: isize, data: GlVoidPtrConst)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bufferSubDataUntyped(&self._0, target, offset, size, data._0) }) } }
        /// Calls the `Gl::map_buffer` function.
        pub fn map_buffer(&self, target: u32, access: u32)  -> crate::gl::GlVoidPtrMut {  unsafe { core::mem::transmute(unsafe { azul::AzGl_mapBuffer(&self._0, target, access) }) } }
        /// Calls the `Gl::map_buffer_range` function.
        pub fn map_buffer_range(&self, target: u32, offset: isize, length: isize, access: u32)  -> crate::gl::GlVoidPtrMut {  unsafe { core::mem::transmute(unsafe { azul::AzGl_mapBufferRange(&self._0, target, offset, length, access) }) } }
        /// Calls the `Gl::unmap_buffer` function.
        pub fn unmap_buffer(&self, target: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_unmapBuffer(&self._0, target) }) } }
        /// Calls the `Gl::tex_buffer` function.
        pub fn tex_buffer(&self, target: u32, internal_format: u32, buffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texBuffer(&self._0, target, internal_format, buffer) }) } }
        /// Calls the `Gl::shader_source` function.
        pub fn shader_source(&self, shader: u32, strings: StringVec)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_shaderSource(&self._0, shader, strings._0) }) } }
        /// Calls the `Gl::read_buffer` function.
        pub fn read_buffer(&self, mode: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_readBuffer(&self._0, mode) }) } }
        /// Calls the `Gl::read_pixels_into_buffer` function.
        pub fn read_pixels_into_buffer(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32, dst_buffer: U8VecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_readPixelsIntoBuffer(&self._0, x, y, width, height, format, pixel_type, dst_buffer._0) }) } }
        /// Calls the `Gl::read_pixels` function.
        pub fn read_pixels(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32)  -> crate::vec::U8Vec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_readPixels(&self._0, x, y, width, height, format, pixel_type) }) } }
        /// Calls the `Gl::read_pixels_into_pbo` function.
        pub fn read_pixels_into_pbo(&self, x: i32, y: i32, width: i32, height: i32, format: u32, pixel_type: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_readPixelsIntoPbo(&self._0, x, y, width, height, format, pixel_type) }) } }
        /// Calls the `Gl::sample_coverage` function.
        pub fn sample_coverage(&self, value: f32, invert: bool)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_sampleCoverage(&self._0, value, invert) }) } }
        /// Calls the `Gl::polygon_offset` function.
        pub fn polygon_offset(&self, factor: f32, units: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_polygonOffset(&self._0, factor, units) }) } }
        /// Calls the `Gl::pixel_store_i` function.
        pub fn pixel_store_i(&self, name: u32, param: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_pixelStoreI(&self._0, name, param) }) } }
        /// Calls the `Gl::gen_buffers` function.
        pub fn gen_buffers(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genBuffers(&self._0, n) }) } }
        /// Calls the `Gl::gen_renderbuffers` function.
        pub fn gen_renderbuffers(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genRenderbuffers(&self._0, n) }) } }
        /// Calls the `Gl::gen_framebuffers` function.
        pub fn gen_framebuffers(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genFramebuffers(&self._0, n) }) } }
        /// Calls the `Gl::gen_textures` function.
        pub fn gen_textures(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genTextures(&self._0, n) }) } }
        /// Calls the `Gl::gen_vertex_arrays` function.
        pub fn gen_vertex_arrays(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genVertexArrays(&self._0, n) }) } }
        /// Calls the `Gl::gen_queries` function.
        pub fn gen_queries(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genQueries(&self._0, n) }) } }
        /// Calls the `Gl::begin_query` function.
        pub fn begin_query(&self, target: u32, id: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_beginQuery(&self._0, target, id) }) } }
        /// Calls the `Gl::end_query` function.
        pub fn end_query(&self, target: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_endQuery(&self._0, target) }) } }
        /// Calls the `Gl::query_counter` function.
        pub fn query_counter(&self, id: u32, target: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_queryCounter(&self._0, id, target) }) } }
        /// Calls the `Gl::get_query_object_iv` function.
        pub fn get_query_object_iv(&self, id: u32, pname: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getQueryObjectIv(&self._0, id, pname) }) } }
        /// Calls the `Gl::get_query_object_uiv` function.
        pub fn get_query_object_uiv(&self, id: u32, pname: u32)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getQueryObjectUiv(&self._0, id, pname) }) } }
        /// Calls the `Gl::get_query_object_i64v` function.
        pub fn get_query_object_i64v(&self, id: u32, pname: u32)  -> i64 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getQueryObjectI64V(&self._0, id, pname) }) } }
        /// Calls the `Gl::get_query_object_ui64v` function.
        pub fn get_query_object_ui64v(&self, id: u32, pname: u32)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getQueryObjectUi64V(&self._0, id, pname) }) } }
        /// Calls the `Gl::delete_queries` function.
        pub fn delete_queries(&self, queries: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteQueries(&self._0, queries._0) }) } }
        /// Calls the `Gl::delete_vertex_arrays` function.
        pub fn delete_vertex_arrays(&self, vertex_arrays: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteVertexArrays(&self._0, vertex_arrays._0) }) } }
        /// Calls the `Gl::delete_buffers` function.
        pub fn delete_buffers(&self, buffers: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteBuffers(&self._0, buffers._0) }) } }
        /// Calls the `Gl::delete_renderbuffers` function.
        pub fn delete_renderbuffers(&self, renderbuffers: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteRenderbuffers(&self._0, renderbuffers._0) }) } }
        /// Calls the `Gl::delete_framebuffers` function.
        pub fn delete_framebuffers(&self, framebuffers: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteFramebuffers(&self._0, framebuffers._0) }) } }
        /// Calls the `Gl::delete_textures` function.
        pub fn delete_textures(&self, textures: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteTextures(&self._0, textures._0) }) } }
        /// Calls the `Gl::framebuffer_renderbuffer` function.
        pub fn framebuffer_renderbuffer(&self, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_framebufferRenderbuffer(&self._0, target, attachment, renderbuffertarget, renderbuffer) }) } }
        /// Calls the `Gl::renderbuffer_storage` function.
        pub fn renderbuffer_storage(&self, target: u32, internalformat: u32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_renderbufferStorage(&self._0, target, internalformat, width, height) }) } }
        /// Calls the `Gl::depth_func` function.
        pub fn depth_func(&self, func: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_depthFunc(&self._0, func) }) } }
        /// Calls the `Gl::active_texture` function.
        pub fn active_texture(&self, texture: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_activeTexture(&self._0, texture) }) } }
        /// Calls the `Gl::attach_shader` function.
        pub fn attach_shader(&self, program: u32, shader: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_attachShader(&self._0, program, shader) }) } }
        /// Calls the `Gl::bind_attrib_location` function.
        pub fn bind_attrib_location(&self, program: u32, index: u32, name: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindAttribLocation(&self._0, program, index, name._0) }) } }
        /// Calls the `Gl::get_uniform_iv` function.
        pub fn get_uniform_iv(&self, program: u32, location: i32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getUniformIv(&self._0, program, location, result._0) }) } }
        /// Calls the `Gl::get_uniform_fv` function.
        pub fn get_uniform_fv(&self, program: u32, location: i32, result: GLfloatVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getUniformFv(&self._0, program, location, result._0) }) } }
        /// Calls the `Gl::get_uniform_block_index` function.
        pub fn get_uniform_block_index(&self, program: u32, name: Refstr)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getUniformBlockIndex(&self._0, program, name._0) }) } }
        /// Calls the `Gl::get_uniform_indices` function.
        pub fn get_uniform_indices(&self, program: u32, names: RefstrVecRef)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getUniformIndices(&self._0, program, names._0) }) } }
        /// Calls the `Gl::bind_buffer_base` function.
        pub fn bind_buffer_base(&self, target: u32, index: u32, buffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindBufferBase(&self._0, target, index, buffer) }) } }
        /// Calls the `Gl::bind_buffer_range` function.
        pub fn bind_buffer_range(&self, target: u32, index: u32, buffer: u32, offset: isize, size: isize)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindBufferRange(&self._0, target, index, buffer, offset, size) }) } }
        /// Calls the `Gl::uniform_block_binding` function.
        pub fn uniform_block_binding(&self, program: u32, uniform_block_index: u32, uniform_block_binding: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniformBlockBinding(&self._0, program, uniform_block_index, uniform_block_binding) }) } }
        /// Calls the `Gl::bind_buffer` function.
        pub fn bind_buffer(&self, target: u32, buffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindBuffer(&self._0, target, buffer) }) } }
        /// Calls the `Gl::bind_vertex_array` function.
        pub fn bind_vertex_array(&self, vao: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindVertexArray(&self._0, vao) }) } }
        /// Calls the `Gl::bind_renderbuffer` function.
        pub fn bind_renderbuffer(&self, target: u32, renderbuffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindRenderbuffer(&self._0, target, renderbuffer) }) } }
        /// Calls the `Gl::bind_framebuffer` function.
        pub fn bind_framebuffer(&self, target: u32, framebuffer: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindFramebuffer(&self._0, target, framebuffer) }) } }
        /// Calls the `Gl::bind_texture` function.
        pub fn bind_texture(&self, target: u32, texture: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindTexture(&self._0, target, texture) }) } }
        /// Calls the `Gl::draw_buffers` function.
        pub fn draw_buffers(&self, bufs: GLenumVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_drawBuffers(&self._0, bufs._0) }) } }
        /// Calls the `Gl::tex_image_2d` function.
        pub fn tex_image_2d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, border: i32, format: u32, ty: u32, opt_data: OptionU8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texImage2D(&self._0, target, level, internal_format, width, height, border, format, ty, opt_data._0) }) } }
        /// Calls the `Gl::compressed_tex_image_2d` function.
        pub fn compressed_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, width: i32, height: i32, border: i32, data: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_compressedTexImage2D(&self._0, target, level, internal_format, width, height, border, data._0) }) } }
        /// Calls the `Gl::compressed_tex_sub_image_2d` function.
        pub fn compressed_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_compressedTexSubImage2D(&self._0, target, level, xoffset, yoffset, width, height, format, data._0) }) } }
        /// Calls the `Gl::tex_image_3d` function.
        pub fn tex_image_3d(&self, target: u32, level: i32, internal_format: i32, width: i32, height: i32, depth: i32, border: i32, format: u32, ty: u32, opt_data: OptionU8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texImage3D(&self._0, target, level, internal_format, width, height, depth, border, format, ty, opt_data._0) }) } }
        /// Calls the `Gl::copy_tex_image_2d` function.
        pub fn copy_tex_image_2d(&self, target: u32, level: i32, internal_format: u32, x: i32, y: i32, width: i32, height: i32, border: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyTexImage2D(&self._0, target, level, internal_format, x, y, width, height, border) }) } }
        /// Calls the `Gl::copy_tex_sub_image_2d` function.
        pub fn copy_tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyTexSubImage2D(&self._0, target, level, xoffset, yoffset, x, y, width, height) }) } }
        /// Calls the `Gl::copy_tex_sub_image_3d` function.
        pub fn copy_tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, x: i32, y: i32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyTexSubImage3D(&self._0, target, level, xoffset, yoffset, zoffset, x, y, width, height) }) } }
        /// Calls the `Gl::tex_sub_image_2d` function.
        pub fn tex_sub_image_2d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, data: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texSubImage2D(&self._0, target, level, xoffset, yoffset, width, height, format, ty, data._0) }) } }
        /// Calls the `Gl::tex_sub_image_2d_pbo` function.
        pub fn tex_sub_image_2d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, ty: u32, offset: usize)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texSubImage2DPbo(&self._0, target, level, xoffset, yoffset, width, height, format, ty, offset) }) } }
        /// Calls the `Gl::tex_sub_image_3d` function.
        pub fn tex_sub_image_3d(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, data: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texSubImage3D(&self._0, target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, data._0) }) } }
        /// Calls the `Gl::tex_sub_image_3d_pbo` function.
        pub fn tex_sub_image_3d_pbo(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, zoffset: i32, width: i32, height: i32, depth: i32, format: u32, ty: u32, offset: usize)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texSubImage3DPbo(&self._0, target, level, xoffset, yoffset, zoffset, width, height, depth, format, ty, offset) }) } }
        /// Calls the `Gl::tex_storage_2d` function.
        pub fn tex_storage_2d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texStorage2D(&self._0, target, levels, internal_format, width, height) }) } }
        /// Calls the `Gl::tex_storage_3d` function.
        pub fn tex_storage_3d(&self, target: u32, levels: i32, internal_format: u32, width: i32, height: i32, depth: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texStorage3D(&self._0, target, levels, internal_format, width, height, depth) }) } }
        /// Calls the `Gl::get_tex_image_into_buffer` function.
        pub fn get_tex_image_into_buffer(&self, target: u32, level: i32, format: u32, ty: u32, output: U8VecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getTexImageIntoBuffer(&self._0, target, level, format, ty, output._0) }) } }
        /// Calls the `Gl::copy_image_sub_data` function.
        pub fn copy_image_sub_data(&self, src_name: u32, src_target: u32, src_level: i32, src_x: i32, src_y: i32, src_z: i32, dst_name: u32, dst_target: u32, dst_level: i32, dst_x: i32, dst_y: i32, dst_z: i32, src_width: i32, src_height: i32, src_depth: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyImageSubData(&self._0, src_name, src_target, src_level, src_x, src_y, src_z, dst_name, dst_target, dst_level, dst_x, dst_y, dst_z, src_width, src_height, src_depth) }) } }
        /// Calls the `Gl::invalidate_framebuffer` function.
        pub fn invalidate_framebuffer(&self, target: u32, attachments: GLenumVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_invalidateFramebuffer(&self._0, target, attachments._0) }) } }
        /// Calls the `Gl::invalidate_sub_framebuffer` function.
        pub fn invalidate_sub_framebuffer(&self, target: u32, attachments: GLenumVecRef, xoffset: i32, yoffset: i32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_invalidateSubFramebuffer(&self._0, target, attachments._0, xoffset, yoffset, width, height) }) } }
        /// Calls the `Gl::get_integer_v` function.
        pub fn get_integer_v(&self, name: u32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getIntegerV(&self._0, name, result._0) }) } }
        /// Calls the `Gl::get_integer_64v` function.
        pub fn get_integer_64v(&self, name: u32, result: GLint64VecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getInteger64V(&self._0, name, result._0) }) } }
        /// Calls the `Gl::get_integer_iv` function.
        pub fn get_integer_iv(&self, name: u32, index: u32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getIntegerIv(&self._0, name, index, result._0) }) } }
        /// Calls the `Gl::get_integer_64iv` function.
        pub fn get_integer_64iv(&self, name: u32, index: u32, result: GLint64VecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getInteger64Iv(&self._0, name, index, result._0) }) } }
        /// Calls the `Gl::get_boolean_v` function.
        pub fn get_boolean_v(&self, name: u32, result: GLbooleanVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getBooleanV(&self._0, name, result._0) }) } }
        /// Calls the `Gl::get_float_v` function.
        pub fn get_float_v(&self, name: u32, result: GLfloatVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getFloatV(&self._0, name, result._0) }) } }
        /// Calls the `Gl::get_framebuffer_attachment_parameter_iv` function.
        pub fn get_framebuffer_attachment_parameter_iv(&self, target: u32, attachment: u32, pname: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getFramebufferAttachmentParameterIv(&self._0, target, attachment, pname) }) } }
        /// Calls the `Gl::get_renderbuffer_parameter_iv` function.
        pub fn get_renderbuffer_parameter_iv(&self, target: u32, pname: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getRenderbufferParameterIv(&self._0, target, pname) }) } }
        /// Calls the `Gl::get_tex_parameter_iv` function.
        pub fn get_tex_parameter_iv(&self, target: u32, name: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getTexParameterIv(&self._0, target, name) }) } }
        /// Calls the `Gl::get_tex_parameter_fv` function.
        pub fn get_tex_parameter_fv(&self, target: u32, name: u32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getTexParameterFv(&self._0, target, name) }) } }
        /// Calls the `Gl::tex_parameter_i` function.
        pub fn tex_parameter_i(&self, target: u32, pname: u32, param: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texParameterI(&self._0, target, pname, param) }) } }
        /// Calls the `Gl::tex_parameter_f` function.
        pub fn tex_parameter_f(&self, target: u32, pname: u32, param: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_texParameterF(&self._0, target, pname, param) }) } }
        /// Calls the `Gl::framebuffer_texture_2d` function.
        pub fn framebuffer_texture_2d(&self, target: u32, attachment: u32, textarget: u32, texture: u32, level: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_framebufferTexture2D(&self._0, target, attachment, textarget, texture, level) }) } }
        /// Calls the `Gl::framebuffer_texture_layer` function.
        pub fn framebuffer_texture_layer(&self, target: u32, attachment: u32, texture: u32, level: i32, layer: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_framebufferTextureLayer(&self._0, target, attachment, texture, level, layer) }) } }
        /// Calls the `Gl::blit_framebuffer` function.
        pub fn blit_framebuffer(&self, src_x0: i32, src_y0: i32, src_x1: i32, src_y1: i32, dst_x0: i32, dst_y0: i32, dst_x1: i32, dst_y1: i32, mask: u32, filter: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blitFramebuffer(&self._0, src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask, filter) }) } }
        /// Calls the `Gl::vertex_attrib_4f` function.
        pub fn vertex_attrib_4f(&self, index: u32, x: f32, y: f32, z: f32, w: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_vertexAttrib4F(&self._0, index, x, y, z, w) }) } }
        /// Calls the `Gl::vertex_attrib_pointer_f32` function.
        pub fn vertex_attrib_pointer_f32(&self, index: u32, size: i32, normalized: bool, stride: i32, offset: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_vertexAttribPointerF32(&self._0, index, size, normalized, stride, offset) }) } }
        /// Calls the `Gl::vertex_attrib_pointer` function.
        pub fn vertex_attrib_pointer(&self, index: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_vertexAttribPointer(&self._0, index, size, type_, normalized, stride, offset) }) } }
        /// Calls the `Gl::vertex_attrib_i_pointer` function.
        pub fn vertex_attrib_i_pointer(&self, index: u32, size: i32, type_: u32, stride: i32, offset: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_vertexAttribIPointer(&self._0, index, size, type_, stride, offset) }) } }
        /// Calls the `Gl::vertex_attrib_divisor` function.
        pub fn vertex_attrib_divisor(&self, index: u32, divisor: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_vertexAttribDivisor(&self._0, index, divisor) }) } }
        /// Calls the `Gl::viewport` function.
        pub fn viewport(&self, x: i32, y: i32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_viewport(&self._0, x, y, width, height) }) } }
        /// Calls the `Gl::scissor` function.
        pub fn scissor(&self, x: i32, y: i32, width: i32, height: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_scissor(&self._0, x, y, width, height) }) } }
        /// Calls the `Gl::line_width` function.
        pub fn line_width(&self, width: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_lineWidth(&self._0, width) }) } }
        /// Calls the `Gl::use_program` function.
        pub fn use_program(&self, program: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_useProgram(&self._0, program) }) } }
        /// Calls the `Gl::validate_program` function.
        pub fn validate_program(&self, program: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_validateProgram(&self._0, program) }) } }
        /// Calls the `Gl::draw_arrays` function.
        pub fn draw_arrays(&self, mode: u32, first: i32, count: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_drawArrays(&self._0, mode, first, count) }) } }
        /// Calls the `Gl::draw_arrays_instanced` function.
        pub fn draw_arrays_instanced(&self, mode: u32, first: i32, count: i32, primcount: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_drawArraysInstanced(&self._0, mode, first, count, primcount) }) } }
        /// Calls the `Gl::draw_elements` function.
        pub fn draw_elements(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_drawElements(&self._0, mode, count, element_type, indices_offset) }) } }
        /// Calls the `Gl::draw_elements_instanced` function.
        pub fn draw_elements_instanced(&self, mode: u32, count: i32, element_type: u32, indices_offset: u32, primcount: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_drawElementsInstanced(&self._0, mode, count, element_type, indices_offset, primcount) }) } }
        /// Calls the `Gl::blend_color` function.
        pub fn blend_color(&self, r: f32, g: f32, b: f32, a: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendColor(&self._0, r, g, b, a) }) } }
        /// Calls the `Gl::blend_func` function.
        pub fn blend_func(&self, sfactor: u32, dfactor: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendFunc(&self._0, sfactor, dfactor) }) } }
        /// Calls the `Gl::blend_func_separate` function.
        pub fn blend_func_separate(&self, src_rgb: u32, dest_rgb: u32, src_alpha: u32, dest_alpha: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendFuncSeparate(&self._0, src_rgb, dest_rgb, src_alpha, dest_alpha) }) } }
        /// Calls the `Gl::blend_equation` function.
        pub fn blend_equation(&self, mode: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendEquation(&self._0, mode) }) } }
        /// Calls the `Gl::blend_equation_separate` function.
        pub fn blend_equation_separate(&self, mode_rgb: u32, mode_alpha: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendEquationSeparate(&self._0, mode_rgb, mode_alpha) }) } }
        /// Calls the `Gl::color_mask` function.
        pub fn color_mask(&self, r: bool, g: bool, b: bool, a: bool)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_colorMask(&self._0, r, g, b, a) }) } }
        /// Calls the `Gl::cull_face` function.
        pub fn cull_face(&self, mode: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_cullFace(&self._0, mode) }) } }
        /// Calls the `Gl::front_face` function.
        pub fn front_face(&self, mode: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_frontFace(&self._0, mode) }) } }
        /// Calls the `Gl::enable` function.
        pub fn enable(&self, cap: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_enable(&self._0, cap) }) } }
        /// Calls the `Gl::disable` function.
        pub fn disable(&self, cap: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_disable(&self._0, cap) }) } }
        /// Calls the `Gl::hint` function.
        pub fn hint(&self, param_name: u32, param_val: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_hint(&self._0, param_name, param_val) }) } }
        /// Calls the `Gl::is_enabled` function.
        pub fn is_enabled(&self, cap: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_isEnabled(&self._0, cap) }) } }
        /// Calls the `Gl::is_shader` function.
        pub fn is_shader(&self, shader: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_isShader(&self._0, shader) }) } }
        /// Calls the `Gl::is_texture` function.
        pub fn is_texture(&self, texture: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_isTexture(&self._0, texture) }) } }
        /// Calls the `Gl::is_framebuffer` function.
        pub fn is_framebuffer(&self, framebuffer: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_isFramebuffer(&self._0, framebuffer) }) } }
        /// Calls the `Gl::is_renderbuffer` function.
        pub fn is_renderbuffer(&self, renderbuffer: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_isRenderbuffer(&self._0, renderbuffer) }) } }
        /// Calls the `Gl::check_frame_buffer_status` function.
        pub fn check_frame_buffer_status(&self, target: u32)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_checkFrameBufferStatus(&self._0, target) }) } }
        /// Calls the `Gl::enable_vertex_attrib_array` function.
        pub fn enable_vertex_attrib_array(&self, index: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_enableVertexAttribArray(&self._0, index) }) } }
        /// Calls the `Gl::disable_vertex_attrib_array` function.
        pub fn disable_vertex_attrib_array(&self, index: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_disableVertexAttribArray(&self._0, index) }) } }
        /// Calls the `Gl::uniform_1f` function.
        pub fn uniform_1f(&self, location: i32, v0: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform1F(&self._0, location, v0) }) } }
        /// Calls the `Gl::uniform_1fv` function.
        pub fn uniform_1fv(&self, location: i32, values: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform1Fv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_1i` function.
        pub fn uniform_1i(&self, location: i32, v0: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform1I(&self._0, location, v0) }) } }
        /// Calls the `Gl::uniform_1iv` function.
        pub fn uniform_1iv(&self, location: i32, values: I32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform1Iv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_1ui` function.
        pub fn uniform_1ui(&self, location: i32, v0: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform1Ui(&self._0, location, v0) }) } }
        /// Calls the `Gl::uniform_2f` function.
        pub fn uniform_2f(&self, location: i32, v0: f32, v1: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform2F(&self._0, location, v0, v1) }) } }
        /// Calls the `Gl::uniform_2fv` function.
        pub fn uniform_2fv(&self, location: i32, values: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform2Fv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_2i` function.
        pub fn uniform_2i(&self, location: i32, v0: i32, v1: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform2I(&self._0, location, v0, v1) }) } }
        /// Calls the `Gl::uniform_2iv` function.
        pub fn uniform_2iv(&self, location: i32, values: I32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform2Iv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_2ui` function.
        pub fn uniform_2ui(&self, location: i32, v0: u32, v1: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform2Ui(&self._0, location, v0, v1) }) } }
        /// Calls the `Gl::uniform_3f` function.
        pub fn uniform_3f(&self, location: i32, v0: f32, v1: f32, v2: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform3F(&self._0, location, v0, v1, v2) }) } }
        /// Calls the `Gl::uniform_3fv` function.
        pub fn uniform_3fv(&self, location: i32, values: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform3Fv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_3i` function.
        pub fn uniform_3i(&self, location: i32, v0: i32, v1: i32, v2: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform3I(&self._0, location, v0, v1, v2) }) } }
        /// Calls the `Gl::uniform_3iv` function.
        pub fn uniform_3iv(&self, location: i32, values: I32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform3Iv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_3ui` function.
        pub fn uniform_3ui(&self, location: i32, v0: u32, v1: u32, v2: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform3Ui(&self._0, location, v0, v1, v2) }) } }
        /// Calls the `Gl::uniform_4f` function.
        pub fn uniform_4f(&self, location: i32, x: f32, y: f32, z: f32, w: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform4F(&self._0, location, x, y, z, w) }) } }
        /// Calls the `Gl::uniform_4i` function.
        pub fn uniform_4i(&self, location: i32, x: i32, y: i32, z: i32, w: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform4I(&self._0, location, x, y, z, w) }) } }
        /// Calls the `Gl::uniform_4iv` function.
        pub fn uniform_4iv(&self, location: i32, values: I32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform4Iv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_4ui` function.
        pub fn uniform_4ui(&self, location: i32, x: u32, y: u32, z: u32, w: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform4Ui(&self._0, location, x, y, z, w) }) } }
        /// Calls the `Gl::uniform_4fv` function.
        pub fn uniform_4fv(&self, location: i32, values: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniform4Fv(&self._0, location, values._0) }) } }
        /// Calls the `Gl::uniform_matrix_2fv` function.
        pub fn uniform_matrix_2fv(&self, location: i32, transpose: bool, value: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniformMatrix2Fv(&self._0, location, transpose, value._0) }) } }
        /// Calls the `Gl::uniform_matrix_3fv` function.
        pub fn uniform_matrix_3fv(&self, location: i32, transpose: bool, value: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniformMatrix3Fv(&self._0, location, transpose, value._0) }) } }
        /// Calls the `Gl::uniform_matrix_4fv` function.
        pub fn uniform_matrix_4fv(&self, location: i32, transpose: bool, value: F32VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_uniformMatrix4Fv(&self._0, location, transpose, value._0) }) } }
        /// Calls the `Gl::depth_mask` function.
        pub fn depth_mask(&self, flag: bool)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_depthMask(&self._0, flag) }) } }
        /// Calls the `Gl::depth_range` function.
        pub fn depth_range(&self, near: f64, far: f64)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_depthRange(&self._0, near, far) }) } }
        /// Calls the `Gl::get_active_attrib` function.
        pub fn get_active_attrib(&self, program: u32, index: u32)  -> crate::gl::GetActiveAttribReturn {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveAttrib(&self._0, program, index) }) } }
        /// Calls the `Gl::get_active_uniform` function.
        pub fn get_active_uniform(&self, program: u32, index: u32)  -> crate::gl::GetActiveUniformReturn {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveUniform(&self._0, program, index) }) } }
        /// Calls the `Gl::get_active_uniforms_iv` function.
        pub fn get_active_uniforms_iv(&self, program: u32, indices: GLuintVec, pname: u32)  -> crate::vec::GLintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveUniformsIv(&self._0, program, indices._0, pname) }) } }
        /// Calls the `Gl::get_active_uniform_block_i` function.
        pub fn get_active_uniform_block_i(&self, program: u32, index: u32, pname: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveUniformBlockI(&self._0, program, index, pname) }) } }
        /// Calls the `Gl::get_active_uniform_block_iv` function.
        pub fn get_active_uniform_block_iv(&self, program: u32, index: u32, pname: u32)  -> crate::vec::GLintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveUniformBlockIv(&self._0, program, index, pname) }) } }
        /// Calls the `Gl::get_active_uniform_block_name` function.
        pub fn get_active_uniform_block_name(&self, program: u32, index: u32)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getActiveUniformBlockName(&self._0, program, index) }) } }
        /// Calls the `Gl::get_attrib_location` function.
        pub fn get_attrib_location(&self, program: u32, name: Refstr)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getAttribLocation(&self._0, program, name._0) }) } }
        /// Calls the `Gl::get_frag_data_location` function.
        pub fn get_frag_data_location(&self, program: u32, name: Refstr)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getFragDataLocation(&self._0, program, name._0) }) } }
        /// Calls the `Gl::get_uniform_location` function.
        pub fn get_uniform_location(&self, program: u32, name: Refstr)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getUniformLocation(&self._0, program, name._0) }) } }
        /// Calls the `Gl::get_program_info_log` function.
        pub fn get_program_info_log(&self, program: u32)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getProgramInfoLog(&self._0, program) }) } }
        /// Calls the `Gl::get_program_iv` function.
        pub fn get_program_iv(&self, program: u32, pname: u32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getProgramIv(&self._0, program, pname, result._0) }) } }
        /// Calls the `Gl::get_program_binary` function.
        pub fn get_program_binary(&self, program: u32)  -> crate::gl::GetProgramBinaryReturn {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getProgramBinary(&self._0, program) }) } }
        /// Calls the `Gl::program_binary` function.
        pub fn program_binary(&self, program: u32, format: u32, binary: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_programBinary(&self._0, program, format, binary._0) }) } }
        /// Calls the `Gl::program_parameter_i` function.
        pub fn program_parameter_i(&self, program: u32, pname: u32, value: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_programParameterI(&self._0, program, pname, value) }) } }
        /// Calls the `Gl::get_vertex_attrib_iv` function.
        pub fn get_vertex_attrib_iv(&self, index: u32, pname: u32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getVertexAttribIv(&self._0, index, pname, result._0) }) } }
        /// Calls the `Gl::get_vertex_attrib_fv` function.
        pub fn get_vertex_attrib_fv(&self, index: u32, pname: u32, result: GLfloatVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getVertexAttribFv(&self._0, index, pname, result._0) }) } }
        /// Calls the `Gl::get_vertex_attrib_pointer_v` function.
        pub fn get_vertex_attrib_pointer_v(&self, index: u32, pname: u32)  -> isize {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getVertexAttribPointerV(&self._0, index, pname) }) } }
        /// Calls the `Gl::get_buffer_parameter_iv` function.
        pub fn get_buffer_parameter_iv(&self, target: u32, pname: u32)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getBufferParameterIv(&self._0, target, pname) }) } }
        /// Calls the `Gl::get_shader_info_log` function.
        pub fn get_shader_info_log(&self, shader: u32)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getShaderInfoLog(&self._0, shader) }) } }
        /// Calls the `Gl::get_string` function.
        pub fn get_string(&self, which: u32)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getString(&self._0, which) }) } }
        /// Calls the `Gl::get_string_i` function.
        pub fn get_string_i(&self, which: u32, index: u32)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getStringI(&self._0, which, index) }) } }
        /// Calls the `Gl::get_shader_iv` function.
        pub fn get_shader_iv(&self, shader: u32, pname: u32, result: GLintVecRefMut)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getShaderIv(&self._0, shader, pname, result._0) }) } }
        /// Calls the `Gl::get_shader_precision_format` function.
        pub fn get_shader_precision_format(&self, shader_type: u32, precision_type: u32)  -> crate::gl::GlShaderPrecisionFormatReturn {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getShaderPrecisionFormat(&self._0, shader_type, precision_type) }) } }
        /// Calls the `Gl::compile_shader` function.
        pub fn compile_shader(&self, shader: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_compileShader(&self._0, shader) }) } }
        /// Calls the `Gl::create_program` function.
        pub fn create_program(&self)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_createProgram(&self._0) }) } }
        /// Calls the `Gl::delete_program` function.
        pub fn delete_program(&self, program: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteProgram(&self._0, program) }) } }
        /// Calls the `Gl::create_shader` function.
        pub fn create_shader(&self, shader_type: u32)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_createShader(&self._0, shader_type) }) } }
        /// Calls the `Gl::delete_shader` function.
        pub fn delete_shader(&self, shader: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteShader(&self._0, shader) }) } }
        /// Calls the `Gl::detach_shader` function.
        pub fn detach_shader(&self, program: u32, shader: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_detachShader(&self._0, program, shader) }) } }
        /// Calls the `Gl::link_program` function.
        pub fn link_program(&self, program: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_linkProgram(&self._0, program) }) } }
        /// Calls the `Gl::clear_color` function.
        pub fn clear_color(&self, r: f32, g: f32, b: f32, a: f32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_clearColor(&self._0, r, g, b, a) }) } }
        /// Calls the `Gl::clear` function.
        pub fn clear(&self, buffer_mask: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_clear(&self._0, buffer_mask) }) } }
        /// Calls the `Gl::clear_depth` function.
        pub fn clear_depth(&self, depth: f64)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_clearDepth(&self._0, depth) }) } }
        /// Calls the `Gl::clear_stencil` function.
        pub fn clear_stencil(&self, s: i32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_clearStencil(&self._0, s) }) } }
        /// Calls the `Gl::flush` function.
        pub fn flush(&self)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_flush(&self._0) }) } }
        /// Calls the `Gl::finish` function.
        pub fn finish(&self)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_finish(&self._0) }) } }
        /// Calls the `Gl::get_error` function.
        pub fn get_error(&self)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getError(&self._0) }) } }
        /// Calls the `Gl::stencil_mask` function.
        pub fn stencil_mask(&self, mask: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilMask(&self._0, mask) }) } }
        /// Calls the `Gl::stencil_mask_separate` function.
        pub fn stencil_mask_separate(&self, face: u32, mask: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilMaskSeparate(&self._0, face, mask) }) } }
        /// Calls the `Gl::stencil_func` function.
        pub fn stencil_func(&self, func: u32, ref_: i32, mask: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilFunc(&self._0, func, ref_, mask) }) } }
        /// Calls the `Gl::stencil_func_separate` function.
        pub fn stencil_func_separate(&self, face: u32, func: u32, ref_: i32, mask: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilFuncSeparate(&self._0, face, func, ref_, mask) }) } }
        /// Calls the `Gl::stencil_op` function.
        pub fn stencil_op(&self, sfail: u32, dpfail: u32, dppass: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilOp(&self._0, sfail, dpfail, dppass) }) } }
        /// Calls the `Gl::stencil_op_separate` function.
        pub fn stencil_op_separate(&self, face: u32, sfail: u32, dpfail: u32, dppass: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_stencilOpSeparate(&self._0, face, sfail, dpfail, dppass) }) } }
        /// Calls the `Gl::egl_image_target_texture2d_oes` function.
        pub fn egl_image_target_texture2d_oes(&self, target: u32, image: GlVoidPtrConst)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_eglImageTargetTexture2DOes(&self._0, target, image._0) }) } }
        /// Calls the `Gl::generate_mipmap` function.
        pub fn generate_mipmap(&self, target: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_generateMipmap(&self._0, target) }) } }
        /// Calls the `Gl::insert_event_marker_ext` function.
        pub fn insert_event_marker_ext(&self, message: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_insertEventMarkerExt(&self._0, message._0) }) } }
        /// Calls the `Gl::push_group_marker_ext` function.
        pub fn push_group_marker_ext(&self, message: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_pushGroupMarkerExt(&self._0, message._0) }) } }
        /// Calls the `Gl::pop_group_marker_ext` function.
        pub fn pop_group_marker_ext(&self)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_popGroupMarkerExt(&self._0) }) } }
        /// Calls the `Gl::debug_message_insert_khr` function.
        pub fn debug_message_insert_khr(&self, source: u32, type_: u32, id: u32, severity: u32, message: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_debugMessageInsertKhr(&self._0, source, type_, id, severity, message._0) }) } }
        /// Calls the `Gl::push_debug_group_khr` function.
        pub fn push_debug_group_khr(&self, source: u32, id: u32, message: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_pushDebugGroupKhr(&self._0, source, id, message._0) }) } }
        /// Calls the `Gl::pop_debug_group_khr` function.
        pub fn pop_debug_group_khr(&self)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_popDebugGroupKhr(&self._0) }) } }
        /// Calls the `Gl::fence_sync` function.
        pub fn fence_sync(&self, condition: u32, flags: u32)  -> crate::gl::GLsyncPtr {  unsafe { core::mem::transmute(unsafe { azul::AzGl_fenceSync(&self._0, condition, flags) }) } }
        /// Calls the `Gl::client_wait_sync` function.
        pub fn client_wait_sync(&self, sync: GLsyncPtr, flags: u32, timeout: u64)  -> u32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_clientWaitSync(&self._0, sync._0, flags, timeout) }) } }
        /// Calls the `Gl::wait_sync` function.
        pub fn wait_sync(&self, sync: GLsyncPtr, flags: u32, timeout: u64)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_waitSync(&self._0, sync._0, flags, timeout) }) } }
        /// Calls the `Gl::delete_sync` function.
        pub fn delete_sync(&self, sync: GLsyncPtr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteSync(&self._0, sync._0) }) } }
        /// Calls the `Gl::texture_range_apple` function.
        pub fn texture_range_apple(&self, target: u32, data: U8VecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_textureRangeApple(&self._0, target, data._0) }) } }
        /// Calls the `Gl::gen_fences_apple` function.
        pub fn gen_fences_apple(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genFencesApple(&self._0, n) }) } }
        /// Calls the `Gl::delete_fences_apple` function.
        pub fn delete_fences_apple(&self, fences: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteFencesApple(&self._0, fences._0) }) } }
        /// Calls the `Gl::set_fence_apple` function.
        pub fn set_fence_apple(&self, fence: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_setFenceApple(&self._0, fence) }) } }
        /// Calls the `Gl::finish_fence_apple` function.
        pub fn finish_fence_apple(&self, fence: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_finishFenceApple(&self._0, fence) }) } }
        /// Calls the `Gl::test_fence_apple` function.
        pub fn test_fence_apple(&self, fence: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_testFenceApple(&self._0, fence) }) } }
        /// Calls the `Gl::test_object_apple` function.
        pub fn test_object_apple(&self, object: u32, name: u32)  -> u8 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_testObjectApple(&self._0, object, name) }) } }
        /// Calls the `Gl::finish_object_apple` function.
        pub fn finish_object_apple(&self, object: u32, name: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_finishObjectApple(&self._0, object, name) }) } }
        /// Calls the `Gl::get_frag_data_index` function.
        pub fn get_frag_data_index(&self, program: u32, name: Refstr)  -> i32 {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getFragDataIndex(&self._0, program, name._0) }) } }
        /// Calls the `Gl::blend_barrier_khr` function.
        pub fn blend_barrier_khr(&self)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_blendBarrierKhr(&self._0) }) } }
        /// Calls the `Gl::bind_frag_data_location_indexed` function.
        pub fn bind_frag_data_location_indexed(&self, program: u32, color_number: u32, index: u32, name: Refstr)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindFragDataLocationIndexed(&self._0, program, color_number, index, name._0) }) } }
        /// Calls the `Gl::get_debug_messages` function.
        pub fn get_debug_messages(&self)  -> crate::vec::DebugMessageVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_getDebugMessages(&self._0) }) } }
        /// Calls the `Gl::provoking_vertex_angle` function.
        pub fn provoking_vertex_angle(&self, mode: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_provokingVertexAngle(&self._0, mode) }) } }
        /// Calls the `Gl::gen_vertex_arrays_apple` function.
        pub fn gen_vertex_arrays_apple(&self, n: i32)  -> crate::vec::GLuintVec {  unsafe { core::mem::transmute(unsafe { azul::AzGl_genVertexArraysApple(&self._0, n) }) } }
        /// Calls the `Gl::bind_vertex_array_apple` function.
        pub fn bind_vertex_array_apple(&self, vao: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bindVertexArrayApple(&self._0, vao) }) } }
        /// Calls the `Gl::delete_vertex_arrays_apple` function.
        pub fn delete_vertex_arrays_apple(&self, vertex_arrays: GLuintVecRef)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_deleteVertexArraysApple(&self._0, vertex_arrays._0) }) } }
        /// Calls the `Gl::copy_texture_chromium` function.
        pub fn copy_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyTextureChromium(&self._0, source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }) } }
        /// Calls the `Gl::copy_sub_texture_chromium` function.
        pub fn copy_sub_texture_chromium(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, x: i32, y: i32, width: i32, height: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copySubTextureChromium(&self._0, source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, x, y, width, height, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }) } }
        /// Calls the `Gl::egl_image_target_renderbuffer_storage_oes` function.
        pub fn egl_image_target_renderbuffer_storage_oes(&self, target: u32, image: GlVoidPtrConst)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_eglImageTargetRenderbufferStorageOes(&self._0, target, image._0) }) } }
        /// Calls the `Gl::copy_texture_3d_angle` function.
        pub fn copy_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, internal_format: i32, dest_type: u32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copyTexture3DAngle(&self._0, source_id, source_level, dest_target, dest_id, dest_level, internal_format, dest_type, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }) } }
        /// Calls the `Gl::copy_sub_texture_3d_angle` function.
        pub fn copy_sub_texture_3d_angle(&self, source_id: u32, source_level: i32, dest_target: u32, dest_id: u32, dest_level: i32, x_offset: i32, y_offset: i32, z_offset: i32, x: i32, y: i32, z: i32, width: i32, height: i32, depth: i32, unpack_flip_y: u8, unpack_premultiply_alpha: u8, unpack_unmultiply_alpha: u8)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_copySubTexture3DAngle(&self._0, source_id, source_level, dest_target, dest_id, dest_level, x_offset, y_offset, z_offset, x, y, z, width, height, depth, unpack_flip_y, unpack_premultiply_alpha, unpack_unmultiply_alpha) }) } }
        /// Calls the `Gl::buffer_storage` function.
        pub fn buffer_storage(&self, target: u32, size: isize, data: GlVoidPtrConst, flags: u32)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_bufferStorage(&self._0, target, size, data._0, flags) }) } }
        /// Calls the `Gl::flush_mapped_buffer_range` function.
        pub fn flush_mapped_buffer_range(&self, target: u32, offset: isize, length: isize)  {  unsafe { core::mem::transmute(unsafe { azul::AzGl_flushMappedBufferRange(&self._0, target, offset, length) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for Gl { fn clone(&self) -> Self { unsafe { crate::dll::AzGl_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for Gl { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzGl_delete(self) } } } }
    /// `GlShaderPrecisionFormatReturn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGlShaderPrecisionFormatReturn as GlShaderPrecisionFormatReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GlShaderPrecisionFormatReturnCrossCrateImpl { pub _0: azul::AzGlShaderPrecisionFormatReturn }

    #[cfg(feature = "link_static")] pub use GlShaderPrecisionFormatReturnCrossCrateImpl as GlShaderPrecisionFormatReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GlShaderPrecisionFormatReturnCrossCrateImpl { type Target = AzGlShaderPrecisionFormatReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GlShaderPrecisionFormatReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexAttributeType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexAttributeType as VertexAttributeType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexAttributeTypeCrossCrateImpl { pub _0: azul::AzVertexAttributeType }

    #[cfg(feature = "link_static")] pub use VertexAttributeTypeCrossCrateImpl as VertexAttributeType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexAttributeTypeCrossCrateImpl { type Target = AzVertexAttributeType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexAttributeTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexAttribute` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexAttribute as VertexAttribute;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexAttributeCrossCrateImpl { pub _0: azul::AzVertexAttribute }

    #[cfg(feature = "link_static")] pub use VertexAttributeCrossCrateImpl as VertexAttribute;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexAttributeCrossCrateImpl { type Target = AzVertexAttribute; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexAttributeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexLayout` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexLayout as VertexLayout;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexLayoutCrossCrateImpl { pub _0: azul::AzVertexLayout }

    #[cfg(feature = "link_static")] pub use VertexLayoutCrossCrateImpl as VertexLayout;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexLayoutCrossCrateImpl { type Target = AzVertexLayout; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexLayoutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexArrayObject` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexArrayObject as VertexArrayObject;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexArrayObjectCrossCrateImpl { pub _0: azul::AzVertexArrayObject }

    #[cfg(feature = "link_static")] pub use VertexArrayObjectCrossCrateImpl as VertexArrayObject;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexArrayObjectCrossCrateImpl { type Target = AzVertexArrayObject; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexArrayObjectCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl VertexArrayObject {

        /// Creates a new `VertexArrayObject` instance.
        pub fn new(vertex_layout: VertexLayout, vao_id: u32, gl_context: Gl) -> Self { unsafe { crate::dll::AzVertexArrayObject_new(vertex_layout, vao_id, gl_context) } }
    }

    #[cfg(feature = "link_static")]
    impl VertexArrayObjectCrossCrateImpl {

        /// Creates a new `VertexArrayObject` instance.
        pub fn new(vertex_layout: VertexLayout, vao_id: u32, gl_context: Gl) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzVertexArrayObject_new(vertex_layout._0, vao_id, gl_context._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for VertexArrayObject { fn clone(&self) -> Self { unsafe { crate::dll::AzVertexArrayObject_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for VertexArrayObject { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzVertexArrayObject_delete(self) } } } }
    /// `IndexBufferFormat` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIndexBufferFormat as IndexBufferFormat;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IndexBufferFormatCrossCrateImpl { pub _0: azul::AzIndexBufferFormat }

    #[cfg(feature = "link_static")] pub use IndexBufferFormatCrossCrateImpl as IndexBufferFormat;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IndexBufferFormatCrossCrateImpl { type Target = AzIndexBufferFormat; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IndexBufferFormatCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexBuffer` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexBuffer as VertexBuffer;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexBufferCrossCrateImpl { pub _0: azul::AzVertexBuffer }

    #[cfg(feature = "link_static")] pub use VertexBufferCrossCrateImpl as VertexBuffer;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexBufferCrossCrateImpl { type Target = AzVertexBuffer; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexBufferCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl VertexBuffer {

        /// Creates a new `VertexBuffer` instance.
        pub fn new(vertex_buffer_id: u32, vertex_buffer_len: usize, vao: VertexArrayObject, index_buffer_id: u32, index_buffer_len: usize, index_buffer_format: IndexBufferFormat) -> Self { unsafe { crate::dll::AzVertexBuffer_new(vertex_buffer_id, vertex_buffer_len, vao, index_buffer_id, index_buffer_len, index_buffer_format) } }
    }

    #[cfg(feature = "link_static")]
    impl VertexBufferCrossCrateImpl {

        /// Creates a new `VertexBuffer` instance.
        pub fn new(vertex_buffer_id: u32, vertex_buffer_len: usize, vao: VertexArrayObject, index_buffer_id: u32, index_buffer_len: usize, index_buffer_format: IndexBufferFormat) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzVertexBuffer_new(vertex_buffer_id, vertex_buffer_len, vao._0, index_buffer_id, index_buffer_len, index_buffer_format._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for VertexBuffer { fn clone(&self) -> Self { unsafe { crate::dll::AzVertexBuffer_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for VertexBuffer { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzVertexBuffer_delete(self) } } } }
    /// `GlType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGlType as GlType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GlTypeCrossCrateImpl { pub _0: azul::AzGlType }

    #[cfg(feature = "link_static")] pub use GlTypeCrossCrateImpl as GlType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GlTypeCrossCrateImpl { type Target = AzGlType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GlTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DebugMessage` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDebugMessage as DebugMessage;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DebugMessageCrossCrateImpl { pub _0: azul::AzDebugMessage }

    #[cfg(feature = "link_static")] pub use DebugMessageCrossCrateImpl as DebugMessage;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DebugMessageCrossCrateImpl { type Target = AzDebugMessage; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DebugMessageCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[u8]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU8VecRef as U8VecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U8VecRefCrossCrateImpl { pub _0: azul::AzU8VecRef }

    #[cfg(feature = "link_static")] pub use U8VecRefCrossCrateImpl as U8VecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U8VecRefCrossCrateImpl { type Target = AzU8VecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U8VecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&mut [u8]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU8VecRefMut as U8VecRefMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U8VecRefMutCrossCrateImpl { pub _0: azul::AzU8VecRefMut }

    #[cfg(feature = "link_static")] pub use U8VecRefMutCrossCrateImpl as U8VecRefMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U8VecRefMutCrossCrateImpl { type Target = AzU8VecRefMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U8VecRefMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[f32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzF32VecRef as F32VecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct F32VecRefCrossCrateImpl { pub _0: azul::AzF32VecRef }

    #[cfg(feature = "link_static")] pub use F32VecRefCrossCrateImpl as F32VecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for F32VecRefCrossCrateImpl { type Target = AzF32VecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for F32VecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[i32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzI32VecRef as I32VecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct I32VecRefCrossCrateImpl { pub _0: azul::AzI32VecRef }

    #[cfg(feature = "link_static")] pub use I32VecRefCrossCrateImpl as I32VecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for I32VecRefCrossCrateImpl { type Target = AzI32VecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for I32VecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[GLuint]` aka `&[u32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLuintVecRef as GLuintVecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLuintVecRefCrossCrateImpl { pub _0: azul::AzGLuintVecRef }

    #[cfg(feature = "link_static")] pub use GLuintVecRefCrossCrateImpl as GLuintVecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLuintVecRefCrossCrateImpl { type Target = AzGLuintVecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLuintVecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[GLenum]` aka `&[u32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLenumVecRef as GLenumVecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLenumVecRefCrossCrateImpl { pub _0: azul::AzGLenumVecRef }

    #[cfg(feature = "link_static")] pub use GLenumVecRefCrossCrateImpl as GLenumVecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLenumVecRefCrossCrateImpl { type Target = AzGLenumVecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLenumVecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&mut [GLint]` aka `&mut [i32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLintVecRefMut as GLintVecRefMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLintVecRefMutCrossCrateImpl { pub _0: azul::AzGLintVecRefMut }

    #[cfg(feature = "link_static")] pub use GLintVecRefMutCrossCrateImpl as GLintVecRefMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLintVecRefMutCrossCrateImpl { type Target = AzGLintVecRefMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLintVecRefMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&mut [GLint64]` aka `&mut [i64]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLint64VecRefMut as GLint64VecRefMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLint64VecRefMutCrossCrateImpl { pub _0: azul::AzGLint64VecRefMut }

    #[cfg(feature = "link_static")] pub use GLint64VecRefMutCrossCrateImpl as GLint64VecRefMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLint64VecRefMutCrossCrateImpl { type Target = AzGLint64VecRefMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLint64VecRefMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&mut [GLboolean]` aka `&mut [u8]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLbooleanVecRefMut as GLbooleanVecRefMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLbooleanVecRefMutCrossCrateImpl { pub _0: azul::AzGLbooleanVecRefMut }

    #[cfg(feature = "link_static")] pub use GLbooleanVecRefMutCrossCrateImpl as GLbooleanVecRefMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLbooleanVecRefMutCrossCrateImpl { type Target = AzGLbooleanVecRefMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLbooleanVecRefMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&mut [GLfloat]` aka `&mut [f32]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLfloatVecRefMut as GLfloatVecRefMut;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLfloatVecRefMutCrossCrateImpl { pub _0: azul::AzGLfloatVecRefMut }

    #[cfg(feature = "link_static")] pub use GLfloatVecRefMutCrossCrateImpl as GLfloatVecRefMut;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLfloatVecRefMutCrossCrateImpl { type Target = AzGLfloatVecRefMut; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLfloatVecRefMutCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&[Refstr]` aka `&mut [&str]`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRefstrVecRef as RefstrVecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RefstrVecRefCrossCrateImpl { pub _0: azul::AzRefstrVecRef }

    #[cfg(feature = "link_static")] pub use RefstrVecRefCrossCrateImpl as RefstrVecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RefstrVecRefCrossCrateImpl { type Target = AzRefstrVecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RefstrVecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `&str`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRefstr as Refstr;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RefstrCrossCrateImpl { pub _0: azul::AzRefstr }

    #[cfg(feature = "link_static")] pub use RefstrCrossCrateImpl as Refstr;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RefstrCrossCrateImpl { type Target = AzRefstr; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RefstrCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `(U8Vec, u32)`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGetProgramBinaryReturn as GetProgramBinaryReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GetProgramBinaryReturnCrossCrateImpl { pub _0: azul::AzGetProgramBinaryReturn }

    #[cfg(feature = "link_static")] pub use GetProgramBinaryReturnCrossCrateImpl as GetProgramBinaryReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GetProgramBinaryReturnCrossCrateImpl { type Target = AzGetProgramBinaryReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GetProgramBinaryReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `(i32, u32, AzString)`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGetActiveAttribReturn as GetActiveAttribReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GetActiveAttribReturnCrossCrateImpl { pub _0: azul::AzGetActiveAttribReturn }

    #[cfg(feature = "link_static")] pub use GetActiveAttribReturnCrossCrateImpl as GetActiveAttribReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GetActiveAttribReturnCrossCrateImpl { type Target = AzGetActiveAttribReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GetActiveAttribReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// C-ABI stable reexport of `*const gleam::gl::GLsync`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLsyncPtr as GLsyncPtr;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLsyncPtrCrossCrateImpl { pub _0: azul::AzGLsyncPtr }

    #[cfg(feature = "link_static")] pub use GLsyncPtrCrossCrateImpl as GLsyncPtr;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLsyncPtrCrossCrateImpl { type Target = AzGLsyncPtr; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLsyncPtrCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))] impl Clone for GLsyncPtr { fn clone(&self) -> Self { unsafe { crate::dll::AzGLsyncPtr_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for GLsyncPtr { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzGLsyncPtr_delete(self) } } } }
    /// C-ABI stable reexport of `(i32, u32, AzString)`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGetActiveUniformReturn as GetActiveUniformReturn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GetActiveUniformReturnCrossCrateImpl { pub _0: azul::AzGetActiveUniformReturn }

    #[cfg(feature = "link_static")] pub use GetActiveUniformReturnCrossCrateImpl as GetActiveUniformReturn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GetActiveUniformReturnCrossCrateImpl { type Target = AzGetActiveUniformReturn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GetActiveUniformReturnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextureFlags` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextureFlags as TextureFlags;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextureFlagsCrossCrateImpl { pub _0: azul::AzTextureFlags }

    #[cfg(feature = "link_static")] pub use TextureFlagsCrossCrateImpl as TextureFlags;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextureFlagsCrossCrateImpl { type Target = AzTextureFlags; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextureFlagsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TextureFlags {

        /// Default texture flags (not opaque, not a video texture)
        pub fn default() -> Self { unsafe { crate::dll::AzTextureFlags_default() } }
    }

    #[cfg(feature = "link_static")]
    impl TextureFlagsCrossCrateImpl {

        /// Default texture flags (not opaque, not a video texture)
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTextureFlags_default() }) } }
    }

}

pub mod image {
    #![allow(dead_code, unused_imports)]
    //! Struct definitions for image loading
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::gl::{Texture, U8VecRef};
    use crate::callbacks::{RefAny, RenderImageCallbackType};
    use crate::window::LayoutSize;
    use crate::svg::{SvgNode, SvgStyle};
    /// `ImageRef` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzImageRef as ImageRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ImageRefCrossCrateImpl { pub _0: azul::AzImageRef }

    #[cfg(feature = "link_static")] pub use ImageRefCrossCrateImpl as ImageRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ImageRefCrossCrateImpl { type Target = AzImageRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ImageRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ImageRef {

        /// Creates an "invalid" image with a width and height that reserves an image key, but does not render anything
        pub fn invalid(width: usize, height: usize, format: RawImageFormat) -> Self { unsafe { crate::dll::AzImageRef_invalid(width, height, format) } }
        /// Creates an image reference from a CPU-backed buffer
        pub fn raw_image(data: RawImage) ->  crate::option::OptionImageRef { unsafe { crate::dll::AzImageRef_rawImage(data) } }
        /// Creates an image reference from an OpenGL texture
        pub fn gl_texture(texture: Texture) -> Self { unsafe { crate::dll::AzImageRef_glTexture(texture) } }
        /// Creates an image reference from a callback that is going to be rendered with the given nodes computed size
        pub fn callback(data: RefAny, callback: RenderImageCallbackType) -> Self { unsafe { crate::dll::AzImageRef_callback(data, callback) } }
        /// Creates a new copy of the image bytes instead of shallow-copying the reference
        pub fn clone_bytes(&self)  -> crate::image::ImageRef { unsafe { crate::dll::AzImageRef_cloneBytes(self) } }
        /// Returns whether the image is a null (invalid) image
        pub fn is_invalid(&self)  -> bool { unsafe { crate::dll::AzImageRef_isInvalid(self) } }
        /// Returns whether the image is a GL texture
        pub fn is_gl_texture(&self)  -> bool { unsafe { crate::dll::AzImageRef_isGlTexture(self) } }
        /// Returns whether the image is a raw (CPU-decoded) image
        pub fn is_raw_image(&self)  -> bool { unsafe { crate::dll::AzImageRef_isRawImage(self) } }
        /// Returns whether the image is a `RenderImageCallback`
        pub fn is_callback(&self)  -> bool { unsafe { crate::dll::AzImageRef_isCallback(self) } }
        /// If the image is a RawImage, returns a COPY of the internal image bytes (useful for encoding the RawImage / exporting the ImageRef to a file)
        pub fn get_raw_image(&self)  -> crate::option::OptionRawImage { unsafe { crate::dll::AzImageRef_getRawImage(self) } }
        /// Returns the hash of the ImageRef (fast)
        pub fn get_hash(&self)  -> u64 { unsafe { crate::dll::AzImageRef_getHash(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ImageRefCrossCrateImpl {

        /// Creates an "invalid" image with a width and height that reserves an image key, but does not render anything
        pub fn invalid(width: usize, height: usize, format: RawImageFormat) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzImageRef_invalid(width, height, format._0) }) } }
        /// Creates an image reference from a CPU-backed buffer
        pub fn raw_image(data: RawImage) ->  crate::option::OptionImageRef { unsafe { core::mem::transmute(unsafe { azul::AzImageRef_rawImage(data._0) }) } }
        /// Creates an image reference from an OpenGL texture
        pub fn gl_texture(texture: Texture) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzImageRef_glTexture(texture._0) }) } }
        /// Creates an image reference from a callback that is going to be rendered with the given nodes computed size
        pub fn callback(data: RefAny, callback: RenderImageCallbackType) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzImageRef_callback(data._0, callback._0) }) } }
        /// Creates a new copy of the image bytes instead of shallow-copying the reference
        pub fn clone_bytes(&self)  -> crate::image::ImageRef {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_cloneBytes(&self._0) }) } }
        /// Returns whether the image is a null (invalid) image
        pub fn is_invalid(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_isInvalid(&self._0) }) } }
        /// Returns whether the image is a GL texture
        pub fn is_gl_texture(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_isGlTexture(&self._0) }) } }
        /// Returns whether the image is a raw (CPU-decoded) image
        pub fn is_raw_image(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_isRawImage(&self._0) }) } }
        /// Returns whether the image is a `RenderImageCallback`
        pub fn is_callback(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_isCallback(&self._0) }) } }
        /// If the image is a RawImage, returns a COPY of the internal image bytes (useful for encoding the RawImage / exporting the ImageRef to a file)
        pub fn get_raw_image(&self)  -> crate::option::OptionRawImage {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_getRawImage(&self._0) }) } }
        /// Returns the hash of the ImageRef (fast)
        pub fn get_hash(&self)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzImageRef_getHash(&self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for ImageRef { fn clone(&self) -> Self { unsafe { crate::dll::AzImageRef_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for ImageRef { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzImageRef_delete(self) } } } }
    /// `RawImage` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRawImage as RawImage;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RawImageCrossCrateImpl { pub _0: azul::AzRawImage }

    #[cfg(feature = "link_static")] pub use RawImageCrossCrateImpl as RawImage;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RawImageCrossCrateImpl { type Target = AzRawImage; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RawImageCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl RawImage {

        /// Returns a zero-sized image
        pub fn empty() -> Self { unsafe { crate::dll::AzRawImage_empty() } }
        /// Allocates a width * height, single-channel image with zeroed bytes
        pub fn allocate_clip_mask(size: LayoutSize) -> Self { unsafe { crate::dll::AzRawImage_allocateClipMask(size) } }
        /// Decodes a RawImage from any supported image format - automatically guesses the format based on magic header
        pub fn decode_image_bytes_any(bytes: U8VecRef) ->  crate::error::ResultRawImageDecodeImageError { unsafe { crate::dll::AzRawImage_decodeImageBytesAny(bytes) } }
        /// Calls the `RawImage::draw_clip_mask` function.
        pub fn draw_clip_mask(&mut self, node: SvgNode, style: SvgStyle)  -> bool { unsafe { crate::dll::AzRawImage_drawClipMask(self, node, style) } }
        /// Encodes the RawImage in the BMP image format
        pub fn encode_bmp(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodeBmp(self) } }
        /// Encodes the RawImage in the PNG image format
        pub fn encode_png(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodePng(self) } }
        /// Encodes the RawImage in the JPG image format
        pub fn encode_jpeg(&self, quality: u8)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodeJpeg(self, quality) } }
        /// Encodes the RawImage in the TGA image format
        pub fn encode_tga(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodeTga(self) } }
        /// Encodes the RawImage in the PNM image format
        pub fn encode_pnm(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodePnm(self) } }
        /// Encodes the RawImage in the GIF image format
        pub fn encode_gif(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodeGif(self) } }
        /// Encodes the RawImage in the TIFF image format
        pub fn encode_tiff(&self)  -> crate::error::ResultU8VecEncodeImageError { unsafe { crate::dll::AzRawImage_encodeTiff(self) } }
    }

    #[cfg(feature = "link_static")]
    impl RawImageCrossCrateImpl {

        /// Returns a zero-sized image
        pub fn empty() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzRawImage_empty() }) } }
        /// Allocates a width * height, single-channel image with zeroed bytes
        pub fn allocate_clip_mask(size: LayoutSize) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzRawImage_allocateClipMask(size._0) }) } }
        /// Decodes a RawImage from any supported image format - automatically guesses the format based on magic header
        pub fn decode_image_bytes_any(bytes: U8VecRef) ->  crate::error::ResultRawImageDecodeImageError { unsafe { core::mem::transmute(unsafe { azul::AzRawImage_decodeImageBytesAny(bytes._0) }) } }
        /// Calls the `RawImage::draw_clip_mask` function.
        pub fn draw_clip_mask(&mut self, node: SvgNode, style: SvgStyle)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_drawClipMask(&mut self._0, node._0, style._0) }) } }
        /// Encodes the RawImage in the BMP image format
        pub fn encode_bmp(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodeBmp(&self._0) }) } }
        /// Encodes the RawImage in the PNG image format
        pub fn encode_png(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodePng(&self._0) }) } }
        /// Encodes the RawImage in the JPG image format
        pub fn encode_jpeg(&self, quality: u8)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodeJpeg(&self._0, quality) }) } }
        /// Encodes the RawImage in the TGA image format
        pub fn encode_tga(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodeTga(&self._0) }) } }
        /// Encodes the RawImage in the PNM image format
        pub fn encode_pnm(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodePnm(&self._0) }) } }
        /// Encodes the RawImage in the GIF image format
        pub fn encode_gif(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodeGif(&self._0) }) } }
        /// Encodes the RawImage in the TIFF image format
        pub fn encode_tiff(&self)  -> crate::error::ResultU8VecEncodeImageError {  unsafe { core::mem::transmute(unsafe { azul::AzRawImage_encodeTiff(&self._0) }) } }
    }

    /// `ImageMask` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzImageMask as ImageMask;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ImageMaskCrossCrateImpl { pub _0: azul::AzImageMask }

    #[cfg(feature = "link_static")] pub use ImageMaskCrossCrateImpl as ImageMask;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ImageMaskCrossCrateImpl { type Target = AzImageMask; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ImageMaskCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RawImageFormat` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRawImageFormat as RawImageFormat;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RawImageFormatCrossCrateImpl { pub _0: azul::AzRawImageFormat }

    #[cfg(feature = "link_static")] pub use RawImageFormatCrossCrateImpl as RawImageFormat;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RawImageFormatCrossCrateImpl { type Target = AzRawImageFormat; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RawImageFormatCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `EncodeImageError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzEncodeImageError as EncodeImageError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct EncodeImageErrorCrossCrateImpl { pub _0: azul::AzEncodeImageError }

    #[cfg(feature = "link_static")] pub use EncodeImageErrorCrossCrateImpl as EncodeImageError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for EncodeImageErrorCrossCrateImpl { type Target = AzEncodeImageError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for EncodeImageErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DecodeImageError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDecodeImageError as DecodeImageError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DecodeImageErrorCrossCrateImpl { pub _0: azul::AzDecodeImageError }

    #[cfg(feature = "link_static")] pub use DecodeImageErrorCrossCrateImpl as DecodeImageError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DecodeImageErrorCrossCrateImpl { type Target = AzDecodeImageError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DecodeImageErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `RawImageData` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzRawImageData as RawImageData;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct RawImageDataCrossCrateImpl { pub _0: azul::AzRawImageData }

    #[cfg(feature = "link_static")] pub use RawImageDataCrossCrateImpl as RawImageData;

    #[cfg(feature = "link_static")] impl core::ops::Deref for RawImageDataCrossCrateImpl { type Target = AzRawImageData; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for RawImageDataCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod font {
    #![allow(dead_code, unused_imports)]
    //! Font decoding / parsing module
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::gl::Refstr;
    use crate::callbacks::ResolvedTextLayoutOptions;
    /// `ParsedFontDestructorFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzParsedFontDestructorFnType as ParsedFontDestructorFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ParsedFontDestructorFnTypeCrossCrateImpl { pub _0: azul::AzParsedFontDestructorFnType }

    #[cfg(feature = "link_static")] pub use ParsedFontDestructorFnTypeCrossCrateImpl as ParsedFontDestructorFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ParsedFontDestructorFnTypeCrossCrateImpl { type Target = AzParsedFontDestructorFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ParsedFontDestructorFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FontMetrics` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFontMetrics as FontMetrics;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FontMetricsCrossCrateImpl { pub _0: azul::AzFontMetrics }

    #[cfg(feature = "link_static")] pub use FontMetricsCrossCrateImpl as FontMetrics;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FontMetricsCrossCrateImpl { type Target = AzFontMetrics; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FontMetricsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl FontMetrics {

        /// Returns a FontMetrics struct with all fields set to 0
        pub fn zero() -> Self { unsafe { crate::dll::AzFontMetrics_zero() } }
        /// If set, use `OS/2.sTypoAscender - OS/2.sTypoDescender + OS/2.sTypoLineGap` to calculate the height.
        pub fn use_typo_metrics(&self)  -> bool { unsafe { crate::dll::AzFontMetrics_useTypoMetrics(self) } }
        /// Calls the `FontMetrics::get_ascender` function.
        pub fn get_ascender(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getAscender(self, target_font_size) } }
        /// Calls the `FontMetrics::get_descender` function.
        pub fn get_descender(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getDescender(self, target_font_size) } }
        /// Calls the `FontMetrics::get_line_gap` function.
        pub fn get_line_gap(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getLineGap(self, target_font_size) } }
        /// Calls the `FontMetrics::get_x_min` function.
        pub fn get_x_min(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getXMin(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_min` function.
        pub fn get_y_min(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYMin(self, target_font_size) } }
        /// Calls the `FontMetrics::get_x_max` function.
        pub fn get_x_max(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getXMax(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_max` function.
        pub fn get_y_max(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYMax(self, target_font_size) } }
        /// Calls the `FontMetrics::get_advance_width_max` function.
        pub fn get_advance_width_max(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getAdvanceWidthMax(self, target_font_size) } }
        /// Calls the `FontMetrics::get_min_left_side_bearing` function.
        pub fn get_min_left_side_bearing(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getMinLeftSideBearing(self, target_font_size) } }
        /// Calls the `FontMetrics::get_min_right_side_bearing` function.
        pub fn get_min_right_side_bearing(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getMinRightSideBearing(self, target_font_size) } }
        /// Calls the `FontMetrics::get_x_max_extent` function.
        pub fn get_x_max_extent(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getXMaxExtent(self, target_font_size) } }
        /// Calls the `FontMetrics::get_x_avg_char_width` function.
        pub fn get_x_avg_char_width(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getXAvgCharWidth(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_subscript_x_size` function.
        pub fn get_y_subscript_x_size(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSubscriptXSize(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_subscript_y_size` function.
        pub fn get_y_subscript_y_size(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSubscriptYSize(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_subscript_x_offset` function.
        pub fn get_y_subscript_x_offset(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSubscriptXOffset(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_subscript_y_offset` function.
        pub fn get_y_subscript_y_offset(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSubscriptYOffset(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_superscript_x_size` function.
        pub fn get_y_superscript_x_size(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSuperscriptXSize(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_superscript_y_size` function.
        pub fn get_y_superscript_y_size(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSuperscriptYSize(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_superscript_x_offset` function.
        pub fn get_y_superscript_x_offset(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSuperscriptXOffset(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_superscript_y_offset` function.
        pub fn get_y_superscript_y_offset(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYSuperscriptYOffset(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_strikeout_size` function.
        pub fn get_y_strikeout_size(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYStrikeoutSize(self, target_font_size) } }
        /// Calls the `FontMetrics::get_y_strikeout_position` function.
        pub fn get_y_strikeout_position(&self, target_font_size: f32)  -> f32 { unsafe { crate::dll::AzFontMetrics_getYStrikeoutPosition(self, target_font_size) } }
    }

    #[cfg(feature = "link_static")]
    impl FontMetricsCrossCrateImpl {

        /// Returns a FontMetrics struct with all fields set to 0
        pub fn zero() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_zero() }) } }
        /// If set, use `OS/2.sTypoAscender - OS/2.sTypoDescender + OS/2.sTypoLineGap` to calculate the height.
        pub fn use_typo_metrics(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_useTypoMetrics(&self._0) }) } }
        /// Calls the `FontMetrics::get_ascender` function.
        pub fn get_ascender(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getAscender(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_descender` function.
        pub fn get_descender(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getDescender(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_line_gap` function.
        pub fn get_line_gap(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getLineGap(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_x_min` function.
        pub fn get_x_min(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getXMin(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_min` function.
        pub fn get_y_min(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYMin(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_x_max` function.
        pub fn get_x_max(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getXMax(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_max` function.
        pub fn get_y_max(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYMax(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_advance_width_max` function.
        pub fn get_advance_width_max(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getAdvanceWidthMax(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_min_left_side_bearing` function.
        pub fn get_min_left_side_bearing(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getMinLeftSideBearing(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_min_right_side_bearing` function.
        pub fn get_min_right_side_bearing(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getMinRightSideBearing(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_x_max_extent` function.
        pub fn get_x_max_extent(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getXMaxExtent(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_x_avg_char_width` function.
        pub fn get_x_avg_char_width(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getXAvgCharWidth(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_subscript_x_size` function.
        pub fn get_y_subscript_x_size(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSubscriptXSize(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_subscript_y_size` function.
        pub fn get_y_subscript_y_size(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSubscriptYSize(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_subscript_x_offset` function.
        pub fn get_y_subscript_x_offset(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSubscriptXOffset(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_subscript_y_offset` function.
        pub fn get_y_subscript_y_offset(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSubscriptYOffset(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_superscript_x_size` function.
        pub fn get_y_superscript_x_size(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSuperscriptXSize(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_superscript_y_size` function.
        pub fn get_y_superscript_y_size(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSuperscriptYSize(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_superscript_x_offset` function.
        pub fn get_y_superscript_x_offset(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSuperscriptXOffset(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_superscript_y_offset` function.
        pub fn get_y_superscript_y_offset(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYSuperscriptYOffset(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_strikeout_size` function.
        pub fn get_y_strikeout_size(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYStrikeoutSize(&self._0, target_font_size) }) } }
        /// Calls the `FontMetrics::get_y_strikeout_position` function.
        pub fn get_y_strikeout_position(&self, target_font_size: f32)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzFontMetrics_getYStrikeoutPosition(&self._0, target_font_size) }) } }
    }

    /// Source data of a font file (bytes)
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFontSource as FontSource;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FontSourceCrossCrateImpl { pub _0: azul::AzFontSource }

    #[cfg(feature = "link_static")] pub use FontSourceCrossCrateImpl as FontSource;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FontSourceCrossCrateImpl { type Target = AzFontSource; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FontSourceCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Atomically reference-counted parsed font data
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFontRef as FontRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FontRefCrossCrateImpl { pub _0: azul::AzFontRef }

    #[cfg(feature = "link_static")] pub use FontRefCrossCrateImpl as FontRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FontRefCrossCrateImpl { type Target = AzFontRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FontRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl FontRef {

        /// Parses a new font from bytes. Returns `None` if the font could not be parsed correctly.
        pub fn parse(source: FontSource) ->  crate::option::OptionFontRef { unsafe { crate::dll::AzFontRef_parse(source) } }
        /// Returns the font bytes of the underlying font source
        pub fn get_bytes(&self)  -> crate::vec::U8Vec { unsafe { crate::dll::AzFontRef_getBytes(self) } }
        /// Returns the font metrics of the parsed font
        pub fn get_font_metrics(&self)  -> crate::font::FontMetrics { unsafe { crate::dll::AzFontRef_getFontMetrics(self) } }
        /// Returns the text layout of the shaped text
        pub fn shape_text(&self, text: Refstr, options: ResolvedTextLayoutOptions)  -> crate::callbacks::InlineText { unsafe { crate::dll::AzFontRef_shapeText(self, text, options) } }
        /// Returns the hash of the FontRef (fast)
        pub fn get_hash(&self)  -> u64 { unsafe { crate::dll::AzFontRef_getHash(self) } }
    }

    #[cfg(feature = "link_static")]
    impl FontRefCrossCrateImpl {

        /// Parses a new font from bytes. Returns `None` if the font could not be parsed correctly.
        pub fn parse(source: FontSource) ->  crate::option::OptionFontRef { unsafe { core::mem::transmute(unsafe { azul::AzFontRef_parse(source._0) }) } }
        /// Returns the font bytes of the underlying font source
        pub fn get_bytes(&self)  -> crate::vec::U8Vec {  unsafe { core::mem::transmute(unsafe { azul::AzFontRef_getBytes(&self._0) }) } }
        /// Returns the font metrics of the parsed font
        pub fn get_font_metrics(&self)  -> crate::font::FontMetrics {  unsafe { core::mem::transmute(unsafe { azul::AzFontRef_getFontMetrics(&self._0) }) } }
        /// Returns the text layout of the shaped text
        pub fn shape_text(&self, text: Refstr, options: ResolvedTextLayoutOptions)  -> crate::callbacks::InlineText {  unsafe { core::mem::transmute(unsafe { azul::AzFontRef_shapeText(&self._0, text._0, options._0) }) } }
        /// Returns the hash of the FontRef (fast)
        pub fn get_hash(&self)  -> u64 {  unsafe { core::mem::transmute(unsafe { azul::AzFontRef_getHash(&self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for FontRef { fn clone(&self) -> Self { unsafe { crate::dll::AzFontRef_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for FontRef { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzFontRef_delete(self) } } } }
}

pub mod svg {
    #![allow(dead_code, unused_imports)]
    //! SVG parsing and rendering functions
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::str::String;
    use crate::gl::{Gl, U8VecRef};
    /// `Svg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvg as Svg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgCrossCrateImpl { pub _0: azul::AzSvg }

    #[cfg(feature = "link_static")] pub use SvgCrossCrateImpl as Svg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgCrossCrateImpl { type Target = AzSvg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Svg {

        /// Creates a new `Svg` instance.
        pub fn from_string(svg_string: String, parse_options: SvgParseOptions) ->  crate::error::ResultSvgSvgParseError { unsafe { crate::dll::AzSvg_fromString(svg_string, parse_options) } }
        /// Creates a new `Svg` instance.
        pub fn from_bytes(svg_bytes: U8VecRef, parse_options: SvgParseOptions) ->  crate::error::ResultSvgSvgParseError { unsafe { crate::dll::AzSvg_fromBytes(svg_bytes, parse_options) } }
        /// Calls the `Svg::get_root` function.
        pub fn get_root(&self)  -> crate::svg::SvgXmlNode { unsafe { crate::dll::AzSvg_getRoot(self) } }
        /// Calls the `Svg::render` function.
        pub fn render(&self, options: SvgRenderOptions)  -> crate::option::OptionRawImage { unsafe { crate::dll::AzSvg_render(self, options) } }
        /// Calls the `Svg::to_string` function.
        pub fn to_string(&self, options: SvgStringFormatOptions)  -> crate::str::String { unsafe { crate::dll::AzSvg_toString(self, options) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgCrossCrateImpl {

        /// Creates a new `Svg` instance.
        pub fn from_string(svg_string: String, parse_options: SvgParseOptions) ->  crate::error::ResultSvgSvgParseError { unsafe { core::mem::transmute(unsafe { azul::AzSvg_fromString(svg_string._0, parse_options._0) }) } }
        /// Creates a new `Svg` instance.
        pub fn from_bytes(svg_bytes: U8VecRef, parse_options: SvgParseOptions) ->  crate::error::ResultSvgSvgParseError { unsafe { core::mem::transmute(unsafe { azul::AzSvg_fromBytes(svg_bytes._0, parse_options._0) }) } }
        /// Calls the `Svg::get_root` function.
        pub fn get_root(&self)  -> crate::svg::SvgXmlNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvg_getRoot(&self._0) }) } }
        /// Calls the `Svg::render` function.
        pub fn render(&self, options: SvgRenderOptions)  -> crate::option::OptionRawImage {  unsafe { core::mem::transmute(unsafe { azul::AzSvg_render(&self._0, options._0) }) } }
        /// Calls the `Svg::to_string` function.
        pub fn to_string(&self, options: SvgStringFormatOptions)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzSvg_toString(&self._0, options._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for Svg { fn clone(&self) -> Self { unsafe { crate::dll::AzSvg_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for Svg { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzSvg_delete(self) } } } }
    /// `SvgXmlNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgXmlNode as SvgXmlNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgXmlNodeCrossCrateImpl { pub _0: azul::AzSvgXmlNode }

    #[cfg(feature = "link_static")] pub use SvgXmlNodeCrossCrateImpl as SvgXmlNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgXmlNodeCrossCrateImpl { type Target = AzSvgXmlNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgXmlNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgXmlNode {

        /// Creates a new `SvgXmlNode` instance.
        pub fn parse_from(svg_bytes: U8VecRef, parse_options: SvgParseOptions) ->  crate::error::ResultSvgXmlNodeSvgParseError { unsafe { crate::dll::AzSvgXmlNode_parseFrom(svg_bytes, parse_options) } }
        /// Calls the `SvgXmlNode::render` function.
        pub fn render(&self, options: SvgRenderOptions)  -> crate::option::OptionRawImage { unsafe { crate::dll::AzSvgXmlNode_render(self, options) } }
        /// Calls the `SvgXmlNode::to_string` function.
        pub fn to_string(&self, options: SvgStringFormatOptions)  -> crate::str::String { unsafe { crate::dll::AzSvgXmlNode_toString(self, options) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgXmlNodeCrossCrateImpl {

        /// Creates a new `SvgXmlNode` instance.
        pub fn parse_from(svg_bytes: U8VecRef, parse_options: SvgParseOptions) ->  crate::error::ResultSvgXmlNodeSvgParseError { unsafe { core::mem::transmute(unsafe { azul::AzSvgXmlNode_parseFrom(svg_bytes._0, parse_options._0) }) } }
        /// Calls the `SvgXmlNode::render` function.
        pub fn render(&self, options: SvgRenderOptions)  -> crate::option::OptionRawImage {  unsafe { core::mem::transmute(unsafe { azul::AzSvgXmlNode_render(&self._0, options._0) }) } }
        /// Calls the `SvgXmlNode::to_string` function.
        pub fn to_string(&self, options: SvgStringFormatOptions)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzSvgXmlNode_toString(&self._0, options._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for SvgXmlNode { fn clone(&self) -> Self { unsafe { crate::dll::AzSvgXmlNode_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for SvgXmlNode { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzSvgXmlNode_delete(self) } } } }
    /// `SvgMultiPolygon` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgMultiPolygon as SvgMultiPolygon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgMultiPolygonCrossCrateImpl { pub _0: azul::AzSvgMultiPolygon }

    #[cfg(feature = "link_static")] pub use SvgMultiPolygonCrossCrateImpl as SvgMultiPolygon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgMultiPolygonCrossCrateImpl { type Target = AzSvgMultiPolygon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgMultiPolygonCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgMultiPolygon {

        /// Returns the bounds of the polygon
        pub fn get_bounds(&self)  -> crate::svg::SvgRect { unsafe { crate::dll::AzSvgMultiPolygon_getBounds(self) } }
        /// Returns the bounds of the polygon
        pub fn contains_point(&self, point: SvgPoint, fill_rule: SvgFillRule, tolerance: f32)  -> bool { unsafe { crate::dll::AzSvgMultiPolygon_containsPoint(self, point, fill_rule, tolerance) } }
        /// Calls the `SvgMultiPolygon::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgMultiPolygon_tessellateFill(self, fill_style) } }
        /// Calls the `SvgMultiPolygon::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgMultiPolygon_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgMultiPolygonCrossCrateImpl {

        /// Returns the bounds of the polygon
        pub fn get_bounds(&self)  -> crate::svg::SvgRect {  unsafe { core::mem::transmute(unsafe { azul::AzSvgMultiPolygon_getBounds(&self._0) }) } }
        /// Returns the bounds of the polygon
        pub fn contains_point(&self, point: SvgPoint, fill_rule: SvgFillRule, tolerance: f32)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzSvgMultiPolygon_containsPoint(&self._0, point._0, fill_rule._0, tolerance) }) } }
        /// Calls the `SvgMultiPolygon::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgMultiPolygon_tessellateFill(&self._0, fill_style._0) }) } }
        /// Calls the `SvgMultiPolygon::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgMultiPolygon_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgNode as SvgNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgNodeCrossCrateImpl { pub _0: azul::AzSvgNode }

    #[cfg(feature = "link_static")] pub use SvgNodeCrossCrateImpl as SvgNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgNodeCrossCrateImpl { type Target = AzSvgNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgNode {

        /// Calls the `SvgNode::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgNode_tessellateFill(self, fill_style) } }
        /// Calls the `SvgNode::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgNode_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgNodeCrossCrateImpl {

        /// Calls the `SvgNode::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgNode_tessellateFill(&self._0, fill_style._0) }) } }
        /// Calls the `SvgNode::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgNode_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgStyledNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgStyledNode as SvgStyledNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgStyledNodeCrossCrateImpl { pub _0: azul::AzSvgStyledNode }

    #[cfg(feature = "link_static")] pub use SvgStyledNodeCrossCrateImpl as SvgStyledNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgStyledNodeCrossCrateImpl { type Target = AzSvgStyledNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgStyledNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgStyledNode {

        /// Calls the `SvgStyledNode::tessellate` function.
        pub fn tessellate(&self)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgStyledNode_tessellate(self) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgStyledNodeCrossCrateImpl {

        /// Calls the `SvgStyledNode::tessellate` function.
        pub fn tessellate(&self)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgStyledNode_tessellate(&self._0) }) } }
    }

    /// `SvgCircle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgCircle as SvgCircle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgCircleCrossCrateImpl { pub _0: azul::AzSvgCircle }

    #[cfg(feature = "link_static")] pub use SvgCircleCrossCrateImpl as SvgCircle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgCircleCrossCrateImpl { type Target = AzSvgCircle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgCircleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgCircle {

        /// Calls the `SvgCircle::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgCircle_tessellateFill(self, fill_style) } }
        /// Calls the `SvgCircle::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgCircle_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgCircleCrossCrateImpl {

        /// Calls the `SvgCircle::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCircle_tessellateFill(&self._0, fill_style._0) }) } }
        /// Calls the `SvgCircle::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCircle_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgPath` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPath as SvgPath;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathCrossCrateImpl { pub _0: azul::AzSvgPath }

    #[cfg(feature = "link_static")] pub use SvgPathCrossCrateImpl as SvgPath;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathCrossCrateImpl { type Target = AzSvgPath; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgPath {

        /// Returns whether the path is closed
        pub fn is_closed(&self)  -> bool { unsafe { crate::dll::AzSvgPath_isClosed(self) } }
        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  { unsafe { crate::dll::AzSvgPath_reverse(self) } }
        /// Adds a path to the end of the current path
        pub fn join_with(&mut self, path: SvgPath)  { unsafe { crate::dll::AzSvgPath_joinWith(self, path) } }
        /// Calls the `SvgPath::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgPath_tessellateFill(self, fill_style) } }
        /// Calls the `SvgPath::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgPath_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgPathCrossCrateImpl {

        /// Returns whether the path is closed
        pub fn is_closed(&self)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPath_isClosed(&self._0) }) } }
        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPath_reverse(&mut self._0) }) } }
        /// Adds a path to the end of the current path
        pub fn join_with(&mut self, path: SvgPath)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPath_joinWith(&mut self._0, path._0) }) } }
        /// Calls the `SvgPath::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPath_tessellateFill(&self._0, fill_style._0) }) } }
        /// Calls the `SvgPath::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPath_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgPathElement` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathElement as SvgPathElement;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathElementCrossCrateImpl { pub _0: azul::AzSvgPathElement }

    #[cfg(feature = "link_static")] pub use SvgPathElementCrossCrateImpl as SvgPathElement;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathElementCrossCrateImpl { type Target = AzSvgPathElement; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathElementCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgPathElement {

        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  { unsafe { crate::dll::AzSvgPathElement_reverse(self) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgPathElement_getStart(self) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgPathElement_getEnd(self) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect { unsafe { crate::dll::AzSvgPathElement_getBounds(self) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 { unsafe { crate::dll::AzSvgPathElement_getLength(self) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 { unsafe { crate::dll::AzSvgPathElement_getTAtOffset(self, offset) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgPathElement_getXAtT(self, t) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgPathElement_getYAtT(self, t) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgPathElement_getTangentVectorAtT(self, t) } }
        /// Calls the `SvgPathElement::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgPathElement_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgPathElementCrossCrateImpl {

        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_reverse(&mut self._0) }) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getStart(&self._0) }) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getEnd(&self._0) }) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getBounds(&self._0) }) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getLength(&self._0) }) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getTAtOffset(&self._0, offset) }) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getXAtT(&self._0, t) }) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getYAtT(&self._0, t) }) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_getTangentVectorAtT(&self._0, t) }) } }
        /// Calls the `SvgPathElement::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgPathElement_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgPoint` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPoint as SvgPoint;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPointCrossCrateImpl { pub _0: azul::AzSvgPoint }

    #[cfg(feature = "link_static")] pub use SvgPointCrossCrateImpl as SvgPoint;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPointCrossCrateImpl { type Target = AzSvgPoint; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPointCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgVector` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgVector as SvgVector;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgVectorCrossCrateImpl { pub _0: azul::AzSvgVector }

    #[cfg(feature = "link_static")] pub use SvgVectorCrossCrateImpl as SvgVector;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgVectorCrossCrateImpl { type Target = AzSvgVector; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgVectorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgVector {

        /// Returns the angle of this vector in degrees
        pub fn angle_degrees(&self)  -> f64 { unsafe { crate::dll::AzSvgVector_angleDegrees(self) } }
        /// Normalizes the vector, returning the normalized vector
        pub fn normalize(&self)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgVector_normalize(self) } }
        /// Rotates the vector 90 degrees counter clockwise, returning the rotated vector
        pub fn rotate_90deg_ccw(&self)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgVector_rotate90DegCcw(self) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgVectorCrossCrateImpl {

        /// Returns the angle of this vector in degrees
        pub fn angle_degrees(&self)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgVector_angleDegrees(&self._0) }) } }
        /// Normalizes the vector, returning the normalized vector
        pub fn normalize(&self)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgVector_normalize(&self._0) }) } }
        /// Rotates the vector 90 degrees counter clockwise, returning the rotated vector
        pub fn rotate_90deg_ccw(&self)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgVector_rotate90DegCcw(&self._0) }) } }
    }

    /// `SvgLine` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgLine as SvgLine;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgLineCrossCrateImpl { pub _0: azul::AzSvgLine }

    #[cfg(feature = "link_static")] pub use SvgLineCrossCrateImpl as SvgLine;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgLineCrossCrateImpl { type Target = AzSvgLine; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgLineCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgLine {

        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  { unsafe { crate::dll::AzSvgLine_reverse(self) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgLine_getStart(self) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgLine_getEnd(self) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect { unsafe { crate::dll::AzSvgLine_getBounds(self) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 { unsafe { crate::dll::AzSvgLine_getLength(self) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 { unsafe { crate::dll::AzSvgLine_getTAtOffset(self, offset) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgLine_getXAtT(self, t) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgLine_getYAtT(self, t) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgLine_getTangentVectorAtT(self, t) } }
        /// Calls the `SvgLine::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgLine_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgLineCrossCrateImpl {

        /// Reverses the order of points in the path so that the path runs in the opposite direction afterwards
        pub fn reverse(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_reverse(&mut self._0) }) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getStart(&self._0) }) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getEnd(&self._0) }) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getBounds(&self._0) }) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getLength(&self._0) }) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getTAtOffset(&self._0, offset) }) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getXAtT(&self._0, t) }) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getYAtT(&self._0, t) }) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_getTangentVectorAtT(&self._0, t) }) } }
        /// Calls the `SvgLine::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgLine_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgQuadraticCurve` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgQuadraticCurve as SvgQuadraticCurve;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgQuadraticCurveCrossCrateImpl { pub _0: azul::AzSvgQuadraticCurve }

    #[cfg(feature = "link_static")] pub use SvgQuadraticCurveCrossCrateImpl as SvgQuadraticCurve;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgQuadraticCurveCrossCrateImpl { type Target = AzSvgQuadraticCurve; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgQuadraticCurveCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgQuadraticCurve {

        /// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
        pub fn reverse(&mut self)  { unsafe { crate::dll::AzSvgQuadraticCurve_reverse(self) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgQuadraticCurve_getStart(self) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgQuadraticCurve_getEnd(self) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect { unsafe { crate::dll::AzSvgQuadraticCurve_getBounds(self) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 { unsafe { crate::dll::AzSvgQuadraticCurve_getLength(self) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 { unsafe { crate::dll::AzSvgQuadraticCurve_getTAtOffset(self, offset) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgQuadraticCurve_getXAtT(self, t) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgQuadraticCurve_getYAtT(self, t) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgQuadraticCurve_getTangentVectorAtT(self, t) } }
        /// Calls the `SvgQuadraticCurve::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgQuadraticCurve_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgQuadraticCurveCrossCrateImpl {

        /// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
        pub fn reverse(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_reverse(&mut self._0) }) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getStart(&self._0) }) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getEnd(&self._0) }) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getBounds(&self._0) }) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getLength(&self._0) }) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getTAtOffset(&self._0, offset) }) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getXAtT(&self._0, t) }) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getYAtT(&self._0, t) }) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_getTangentVectorAtT(&self._0, t) }) } }
        /// Calls the `SvgQuadraticCurve::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgQuadraticCurve_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgCubicCurve` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgCubicCurve as SvgCubicCurve;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgCubicCurveCrossCrateImpl { pub _0: azul::AzSvgCubicCurve }

    #[cfg(feature = "link_static")] pub use SvgCubicCurveCrossCrateImpl as SvgCubicCurve;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgCubicCurveCrossCrateImpl { type Target = AzSvgCubicCurve; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgCubicCurveCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgCubicCurve {

        /// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
        pub fn reverse(&mut self)  { unsafe { crate::dll::AzSvgCubicCurve_reverse(self) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgCubicCurve_getStart(self) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgCubicCurve_getEnd(self) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect { unsafe { crate::dll::AzSvgCubicCurve_getBounds(self) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 { unsafe { crate::dll::AzSvgCubicCurve_getLength(self) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 { unsafe { crate::dll::AzSvgCubicCurve_getTAtOffset(self, offset) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgCubicCurve_getXAtT(self, t) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 { unsafe { crate::dll::AzSvgCubicCurve_getYAtT(self, t) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector { unsafe { crate::dll::AzSvgCubicCurve_getTangentVectorAtT(self, t) } }
        /// Calls the `SvgCubicCurve::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgCubicCurve_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgCubicCurveCrossCrateImpl {

        /// Reverses the order of points in the curve so that the curve runs in the opposite direction afterwards
        pub fn reverse(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_reverse(&mut self._0) }) } }
        /// Returns the starting point of this item
        pub fn get_start(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getStart(&self._0) }) } }
        /// Returns the ending point of this item
        pub fn get_end(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getEnd(&self._0) }) } }
        /// Returns the bounding box of this item
        pub fn get_bounds(&self)  -> crate::svg::SvgRect {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getBounds(&self._0) }) } }
        /// Returns the length of the line or curve
        pub fn get_length(&self)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getLength(&self._0) }) } }
        /// Returns the interpolation value t (between 0 and 1) at the given offset from the line or curve start
        pub fn get_t_at_offset(&self, offset: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getTAtOffset(&self._0, offset) }) } }
        /// Returns the point on the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_x_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getXAtT(&self._0, t) }) } }
        /// Returns the y position of the line or curve at t
        pub fn get_y_at_t(&self, t: f64)  -> f64 {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getYAtT(&self._0, t) }) } }
        /// Returns the angle in DEGREES of the line or curve at t (t = interpolation value between 0 and 1)
        pub fn get_tangent_vector_at_t(&self, t: f64)  -> crate::svg::SvgVector {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_getTangentVectorAtT(&self._0, t) }) } }
        /// Calls the `SvgCubicCurve::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgCubicCurve_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgRect` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgRect as SvgRect;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgRectCrossCrateImpl { pub _0: azul::AzSvgRect }

    #[cfg(feature = "link_static")] pub use SvgRectCrossCrateImpl as SvgRect;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgRectCrossCrateImpl { type Target = AzSvgRect; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgRectCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgRect {

        /// Calls the `SvgRect::get_center` function.
        pub fn get_center(&self)  -> crate::svg::SvgPoint { unsafe { crate::dll::AzSvgRect_getCenter(self) } }
        /// Calls the `SvgRect::contains_point` function.
        pub fn contains_point(&self, point: SvgPoint)  -> bool { unsafe { crate::dll::AzSvgRect_containsPoint(self, point) } }
        /// Calls the `SvgRect::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgRect_tessellateFill(self, fill_style) } }
        /// Calls the `SvgRect::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode { unsafe { crate::dll::AzSvgRect_tessellateStroke(self, stroke_style) } }
    }

    #[cfg(feature = "link_static")]
    impl SvgRectCrossCrateImpl {

        /// Calls the `SvgRect::get_center` function.
        pub fn get_center(&self)  -> crate::svg::SvgPoint {  unsafe { core::mem::transmute(unsafe { azul::AzSvgRect_getCenter(&self._0) }) } }
        /// Calls the `SvgRect::contains_point` function.
        pub fn contains_point(&self, point: SvgPoint)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzSvgRect_containsPoint(&self._0, point._0) }) } }
        /// Calls the `SvgRect::tessellate_fill` function.
        pub fn tessellate_fill(&self, fill_style: SvgFillStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgRect_tessellateFill(&self._0, fill_style._0) }) } }
        /// Calls the `SvgRect::tessellate_stroke` function.
        pub fn tessellate_stroke(&self, stroke_style: SvgStrokeStyle)  -> crate::svg::TessellatedSvgNode {  unsafe { core::mem::transmute(unsafe { azul::AzSvgRect_tessellateStroke(&self._0, stroke_style._0) }) } }
    }

    /// `SvgVertex` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgVertex as SvgVertex;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgVertexCrossCrateImpl { pub _0: azul::AzSvgVertex }

    #[cfg(feature = "link_static")] pub use SvgVertexCrossCrateImpl as SvgVertex;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgVertexCrossCrateImpl { type Target = AzSvgVertex; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgVertexCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TessellatedSvgNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedSvgNode as TessellatedSvgNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TessellatedSvgNodeCrossCrateImpl { pub _0: azul::AzTessellatedSvgNode }

    #[cfg(feature = "link_static")] pub use TessellatedSvgNodeCrossCrateImpl as TessellatedSvgNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedSvgNodeCrossCrateImpl { type Target = AzTessellatedSvgNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedSvgNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TessellatedSvgNode {

        /// Returns an empty buffer vertices / indices
        pub fn empty() -> Self { unsafe { crate::dll::AzTessellatedSvgNode_empty() } }
        /// Creates a new TessellatedSvgNode by joining all the given nodes together into one array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting buffer can be drawn in one draw call).
        pub fn from_nodes(nodes: TessellatedSvgNodeVecRef) -> Self { unsafe { crate::dll::AzTessellatedSvgNode_fromNodes(nodes) } }
    }

    #[cfg(feature = "link_static")]
    impl TessellatedSvgNodeCrossCrateImpl {

        /// Returns an empty buffer vertices / indices
        pub fn empty() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTessellatedSvgNode_empty() }) } }
        /// Creates a new TessellatedSvgNode by joining all the given nodes together into one array and inserting a `GL_RESTART_INDEX` (`u32::MAX`) into the indices (so that the resulting buffer can be drawn in one draw call).
        pub fn from_nodes(nodes: TessellatedSvgNodeVecRef) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTessellatedSvgNode_fromNodes(nodes._0) }) } }
    }

    /// Rust wrapper over a `&[TessellatedSvgNode]` or `&Vec<TessellatedSvgNode>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedSvgNodeVecRef as TessellatedSvgNodeVecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TessellatedSvgNodeVecRefCrossCrateImpl { pub _0: azul::AzTessellatedSvgNodeVecRef }

    #[cfg(feature = "link_static")] pub use TessellatedSvgNodeVecRefCrossCrateImpl as TessellatedSvgNodeVecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedSvgNodeVecRefCrossCrateImpl { type Target = AzTessellatedSvgNodeVecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedSvgNodeVecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TessellatedGPUSvgNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedGPUSvgNode as TessellatedGPUSvgNode;

    #[cfg(feature = "link_static")] #[repr(transparent)] #[derive(Debug)] pub struct TessellatedGPUSvgNodeCrossCrateImpl { pub _0: azul::AzTessellatedGPUSvgNode }

    #[cfg(feature = "link_static")] pub use TessellatedGPUSvgNodeCrossCrateImpl as TessellatedGPUSvgNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedGPUSvgNodeCrossCrateImpl { type Target = AzTessellatedGPUSvgNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedGPUSvgNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TessellatedGPUSvgNode {

        /// Creates a new `TessellatedGPUSvgNode` instance.
        pub fn new(tessellated_node: *const AzTessellatedSvgNode, gl: Gl) -> Self { unsafe { crate::dll::AzTessellatedGPUSvgNode_new(tessellated_node, gl) } }
    }

    #[cfg(feature = "link_static")]
    impl TessellatedGPUSvgNodeCrossCrateImpl {

        /// Creates a new `TessellatedGPUSvgNode` instance.
        pub fn new(tessellated_node: *const AzTessellatedSvgNode, gl: Gl) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTessellatedGPUSvgNode_new(unsafe { core::mem::transmute(tessellated_node) }, gl._0) }) } }
    }

    /// `SvgParseOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgParseOptions as SvgParseOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgParseOptionsCrossCrateImpl { pub _0: azul::AzSvgParseOptions }

    #[cfg(feature = "link_static")] pub use SvgParseOptionsCrossCrateImpl as SvgParseOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgParseOptionsCrossCrateImpl { type Target = AzSvgParseOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgParseOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgParseOptions {

        /// Creates a new `SvgParseOptions` instance.
        pub fn default() -> Self { unsafe { crate::dll::AzSvgParseOptions_default() } }
    }

    #[cfg(feature = "link_static")]
    impl SvgParseOptionsCrossCrateImpl {

        /// Creates a new `SvgParseOptions` instance.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzSvgParseOptions_default() }) } }
    }

    /// `ShapeRendering` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzShapeRendering as ShapeRendering;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ShapeRenderingCrossCrateImpl { pub _0: azul::AzShapeRendering }

    #[cfg(feature = "link_static")] pub use ShapeRenderingCrossCrateImpl as ShapeRendering;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ShapeRenderingCrossCrateImpl { type Target = AzShapeRendering; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ShapeRenderingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TextRendering` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTextRendering as TextRendering;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TextRenderingCrossCrateImpl { pub _0: azul::AzTextRendering }

    #[cfg(feature = "link_static")] pub use TextRenderingCrossCrateImpl as TextRendering;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TextRenderingCrossCrateImpl { type Target = AzTextRendering; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TextRenderingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ImageRendering` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzImageRendering as ImageRendering;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ImageRenderingCrossCrateImpl { pub _0: azul::AzImageRendering }

    #[cfg(feature = "link_static")] pub use ImageRenderingCrossCrateImpl as ImageRendering;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ImageRenderingCrossCrateImpl { type Target = AzImageRendering; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ImageRenderingCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FontDatabase` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFontDatabase as FontDatabase;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FontDatabaseCrossCrateImpl { pub _0: azul::AzFontDatabase }

    #[cfg(feature = "link_static")] pub use FontDatabaseCrossCrateImpl as FontDatabase;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FontDatabaseCrossCrateImpl { type Target = AzFontDatabase; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FontDatabaseCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgRenderOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgRenderOptions as SvgRenderOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgRenderOptionsCrossCrateImpl { pub _0: azul::AzSvgRenderOptions }

    #[cfg(feature = "link_static")] pub use SvgRenderOptionsCrossCrateImpl as SvgRenderOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgRenderOptionsCrossCrateImpl { type Target = AzSvgRenderOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgRenderOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgRenderOptions {

        /// Creates a new `SvgRenderOptions` instance.
        pub fn default() -> Self { unsafe { crate::dll::AzSvgRenderOptions_default() } }
    }

    #[cfg(feature = "link_static")]
    impl SvgRenderOptionsCrossCrateImpl {

        /// Creates a new `SvgRenderOptions` instance.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzSvgRenderOptions_default() }) } }
    }

    /// `SvgStringFormatOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgStringFormatOptions as SvgStringFormatOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgStringFormatOptionsCrossCrateImpl { pub _0: azul::AzSvgStringFormatOptions }

    #[cfg(feature = "link_static")] pub use SvgStringFormatOptionsCrossCrateImpl as SvgStringFormatOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgStringFormatOptionsCrossCrateImpl { type Target = AzSvgStringFormatOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgStringFormatOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Indent` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIndent as Indent;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IndentCrossCrateImpl { pub _0: azul::AzIndent }

    #[cfg(feature = "link_static")] pub use IndentCrossCrateImpl as Indent;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IndentCrossCrateImpl { type Target = AzIndent; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IndentCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgFitTo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgFitTo as SvgFitTo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgFitToCrossCrateImpl { pub _0: azul::AzSvgFitTo }

    #[cfg(feature = "link_static")] pub use SvgFitToCrossCrateImpl as SvgFitTo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgFitToCrossCrateImpl { type Target = AzSvgFitTo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgFitToCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgStyle as SvgStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgStyleCrossCrateImpl { pub _0: azul::AzSvgStyle }

    #[cfg(feature = "link_static")] pub use SvgStyleCrossCrateImpl as SvgStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgStyleCrossCrateImpl { type Target = AzSvgStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgFillRule` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgFillRule as SvgFillRule;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgFillRuleCrossCrateImpl { pub _0: azul::AzSvgFillRule }

    #[cfg(feature = "link_static")] pub use SvgFillRuleCrossCrateImpl as SvgFillRule;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgFillRuleCrossCrateImpl { type Target = AzSvgFillRule; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgFillRuleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgTransform` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgTransform as SvgTransform;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgTransformCrossCrateImpl { pub _0: azul::AzSvgTransform }

    #[cfg(feature = "link_static")] pub use SvgTransformCrossCrateImpl as SvgTransform;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgTransformCrossCrateImpl { type Target = AzSvgTransform; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgTransformCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgFillStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgFillStyle as SvgFillStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgFillStyleCrossCrateImpl { pub _0: azul::AzSvgFillStyle }

    #[cfg(feature = "link_static")] pub use SvgFillStyleCrossCrateImpl as SvgFillStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgFillStyleCrossCrateImpl { type Target = AzSvgFillStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgFillStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgFillStyle {

        /// Creates a new `SvgFillStyle` instance.
        pub fn default() -> Self { unsafe { crate::dll::AzSvgFillStyle_default() } }
    }

    #[cfg(feature = "link_static")]
    impl SvgFillStyleCrossCrateImpl {

        /// Creates a new `SvgFillStyle` instance.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzSvgFillStyle_default() }) } }
    }

    /// `SvgStrokeStyle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgStrokeStyle as SvgStrokeStyle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgStrokeStyleCrossCrateImpl { pub _0: azul::AzSvgStrokeStyle }

    #[cfg(feature = "link_static")] pub use SvgStrokeStyleCrossCrateImpl as SvgStrokeStyle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgStrokeStyleCrossCrateImpl { type Target = AzSvgStrokeStyle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgStrokeStyleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SvgStrokeStyle {

        /// Creates a new `SvgStrokeStyle` instance.
        pub fn default() -> Self { unsafe { crate::dll::AzSvgStrokeStyle_default() } }
    }

    #[cfg(feature = "link_static")]
    impl SvgStrokeStyleCrossCrateImpl {

        /// Creates a new `SvgStrokeStyle` instance.
        pub fn default() -> Self { unsafe { core::mem::transmute(unsafe { azul::AzSvgStrokeStyle_default() }) } }
    }

    /// `SvgLineJoin` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgLineJoin as SvgLineJoin;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgLineJoinCrossCrateImpl { pub _0: azul::AzSvgLineJoin }

    #[cfg(feature = "link_static")] pub use SvgLineJoinCrossCrateImpl as SvgLineJoin;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgLineJoinCrossCrateImpl { type Target = AzSvgLineJoin; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgLineJoinCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgLineCap` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgLineCap as SvgLineCap;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgLineCapCrossCrateImpl { pub _0: azul::AzSvgLineCap }

    #[cfg(feature = "link_static")] pub use SvgLineCapCrossCrateImpl as SvgLineCap;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgLineCapCrossCrateImpl { type Target = AzSvgLineCap; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgLineCapCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgDashPattern` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgDashPattern as SvgDashPattern;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgDashPatternCrossCrateImpl { pub _0: azul::AzSvgDashPattern }

    #[cfg(feature = "link_static")] pub use SvgDashPatternCrossCrateImpl as SvgDashPattern;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgDashPatternCrossCrateImpl { type Target = AzSvgDashPattern; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgDashPatternCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod xml {
    #![allow(dead_code, unused_imports)]
    //! XML parsing / decoding module
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::gl::Refstr;
    /// `Xml` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXml as Xml;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlCrossCrateImpl { pub _0: azul::AzXml }

    #[cfg(feature = "link_static")] pub use XmlCrossCrateImpl as Xml;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlCrossCrateImpl { type Target = AzXml; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Xml {

        /// Parses an XML document with one or more root nodes
        pub fn from_str(xml_string: Refstr) ->  crate::error::ResultXmlXmlError { unsafe { crate::dll::AzXml_fromStr(xml_string) } }
    }

    #[cfg(feature = "link_static")]
    impl XmlCrossCrateImpl {

        /// Parses an XML document with one or more root nodes
        pub fn from_str(xml_string: Refstr) ->  crate::error::ResultXmlXmlError { unsafe { core::mem::transmute(unsafe { azul::AzXml_fromStr(xml_string._0) }) } }
    }

    /// `XmlNode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlNode as XmlNode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlNodeCrossCrateImpl { pub _0: azul::AzXmlNode }

    #[cfg(feature = "link_static")] pub use XmlNodeCrossCrateImpl as XmlNode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlNodeCrossCrateImpl { type Target = AzXmlNode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlNodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod fs {
    #![allow(dead_code, unused_imports)]
    //! Filesystem / file input and output module
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::str::String;
    use crate::gl::{Refstr, U8VecRef};
    /// **Reference-counted** file handle
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFile as File;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileCrossCrateImpl { pub _0: azul::AzFile }

    #[cfg(feature = "link_static")] pub use FileCrossCrateImpl as File;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileCrossCrateImpl { type Target = AzFile; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl File {

        /// Opens a file at the given path. If the file exists, replaces it with a new file
        pub fn open(path: String) ->  crate::option::OptionFile { unsafe { crate::dll::AzFile_open(path) } }
        /// Creates a file at the given path. If the file exists, replaces it with a new file
        pub fn create(path: String) ->  crate::option::OptionFile { unsafe { crate::dll::AzFile_create(path) } }
        /// Reads the file to a UTF8-encoded String, returns None if the file can't be decoded correctly
        pub fn read_to_string(&mut self)  -> crate::option::OptionString { unsafe { crate::dll::AzFile_readToString(self) } }
        /// Reads the file as bytes, returns None if the file can't be decoded correctly
        pub fn read_to_bytes(&mut self)  -> crate::option::OptionU8Vec { unsafe { crate::dll::AzFile_readToBytes(self) } }
        /// Writes a string to the file, synchronizes the results before returning
        pub fn write_string(&mut self, bytes: Refstr)  -> bool { unsafe { crate::dll::AzFile_writeString(self, bytes) } }
        /// Writes some bytes to the file, synchronizes the results before returning
        pub fn write_bytes(&mut self, bytes: U8VecRef)  -> bool { unsafe { crate::dll::AzFile_writeBytes(self, bytes) } }
        /// Destructor, closes the file handle
        pub fn close(&mut self)  { unsafe { crate::dll::AzFile_close(self) } }
    }

    #[cfg(feature = "link_static")]
    impl FileCrossCrateImpl {

        /// Opens a file at the given path. If the file exists, replaces it with a new file
        pub fn open(path: String) ->  crate::option::OptionFile { unsafe { core::mem::transmute(unsafe { azul::AzFile_open(path._0) }) } }
        /// Creates a file at the given path. If the file exists, replaces it with a new file
        pub fn create(path: String) ->  crate::option::OptionFile { unsafe { core::mem::transmute(unsafe { azul::AzFile_create(path._0) }) } }
        /// Reads the file to a UTF8-encoded String, returns None if the file can't be decoded correctly
        pub fn read_to_string(&mut self)  -> crate::option::OptionString {  unsafe { core::mem::transmute(unsafe { azul::AzFile_readToString(&mut self._0) }) } }
        /// Reads the file as bytes, returns None if the file can't be decoded correctly
        pub fn read_to_bytes(&mut self)  -> crate::option::OptionU8Vec {  unsafe { core::mem::transmute(unsafe { azul::AzFile_readToBytes(&mut self._0) }) } }
        /// Writes a string to the file, synchronizes the results before returning
        pub fn write_string(&mut self, bytes: Refstr)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzFile_writeString(&mut self._0, bytes._0) }) } }
        /// Writes some bytes to the file, synchronizes the results before returning
        pub fn write_bytes(&mut self, bytes: U8VecRef)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzFile_writeBytes(&mut self._0, bytes._0) }) } }
        /// Destructor, closes the file handle
        pub fn close(&mut self)  {  unsafe { core::mem::transmute(unsafe { azul::AzFile_close(&mut self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for File { fn clone(&self) -> Self { unsafe { crate::dll::AzFile_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for File { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzFile_delete(self) } } } }
}

pub mod dialog {
    #![allow(dead_code, unused_imports)]
    //! Interface for system file selection dialogs / popup message boxes, etc.
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::str::String;
    use crate::option::{OptionColorU, OptionFileTypeList, OptionString};
    /// `MsgBox` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMsgBox as MsgBox;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MsgBoxCrossCrateImpl { pub _0: azul::AzMsgBox }

    #[cfg(feature = "link_static")] pub use MsgBoxCrossCrateImpl as MsgBox;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MsgBoxCrossCrateImpl { type Target = AzMsgBox; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MsgBoxCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl MsgBox {

        /// Opens an informational message box with only an "OK" button
        pub fn ok(icon: MsgBoxIcon, title: String, message: String) -> bool { unsafe { crate::dll::AzMsgBox_ok(icon, title, message) } }
        /// Shorthand for `MsgBox::ok("Info", $message, Icon::Info)`
        pub fn info(message: String) -> bool { unsafe { crate::dll::AzMsgBox_info(message) } }
        /// Shorthand for `MsgBox::ok("Warning", $message, Icon::Warning)`
        pub fn warning(message: String) -> bool { unsafe { crate::dll::AzMsgBox_warning(message) } }
        /// Shorthand for `MsgBox::ok("Error", $message, Icon::Error)`
        pub fn error(message: String) -> bool { unsafe { crate::dll::AzMsgBox_error(message) } }
        /// Shorthand for `MsgBox::ok("Question", $message, Icon::Question)`
        pub fn question(message: String) -> bool { unsafe { crate::dll::AzMsgBox_question(message) } }
        /// Opens a ok / cancel message box. Blocks the current thread.
        pub fn ok_cancel(icon: MsgBoxIcon, title: String, message: String, default_value: MsgBoxOkCancel) ->  crate::dialog::MsgBoxOkCancel { unsafe { crate::dll::AzMsgBox_okCancel(icon, title, message, default_value) } }
        /// Opens a yes / no message box. Blocks the current thread.
        pub fn yes_no(icon: MsgBoxIcon, title: String, message: String, default_value: MsgBoxYesNo) ->  crate::dialog::MsgBoxYesNo { unsafe { crate::dll::AzMsgBox_yesNo(icon, title, message, default_value) } }
    }

    #[cfg(feature = "link_static")]
    impl MsgBoxCrossCrateImpl {

        /// Opens an informational message box with only an "OK" button
        pub fn ok(icon: MsgBoxIcon, title: String, message: String) -> bool { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_ok(icon._0, title._0, message._0) }) } }
        /// Shorthand for `MsgBox::ok("Info", $message, Icon::Info)`
        pub fn info(message: String) -> bool { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_info(message._0) }) } }
        /// Shorthand for `MsgBox::ok("Warning", $message, Icon::Warning)`
        pub fn warning(message: String) -> bool { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_warning(message._0) }) } }
        /// Shorthand for `MsgBox::ok("Error", $message, Icon::Error)`
        pub fn error(message: String) -> bool { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_error(message._0) }) } }
        /// Shorthand for `MsgBox::ok("Question", $message, Icon::Question)`
        pub fn question(message: String) -> bool { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_question(message._0) }) } }
        /// Opens a ok / cancel message box. Blocks the current thread.
        pub fn ok_cancel(icon: MsgBoxIcon, title: String, message: String, default_value: MsgBoxOkCancel) ->  crate::dialog::MsgBoxOkCancel { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_okCancel(icon._0, title._0, message._0, default_value._0) }) } }
        /// Opens a yes / no message box. Blocks the current thread.
        pub fn yes_no(icon: MsgBoxIcon, title: String, message: String, default_value: MsgBoxYesNo) ->  crate::dialog::MsgBoxYesNo { unsafe { core::mem::transmute(unsafe { azul::AzMsgBox_yesNo(icon._0, title._0, message._0, default_value._0) }) } }
    }

    /// Type of message box icon
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMsgBoxIcon as MsgBoxIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MsgBoxIconCrossCrateImpl { pub _0: azul::AzMsgBoxIcon }

    #[cfg(feature = "link_static")] pub use MsgBoxIconCrossCrateImpl as MsgBoxIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MsgBoxIconCrossCrateImpl { type Target = AzMsgBoxIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MsgBoxIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Value returned from a yes / no message box
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMsgBoxYesNo as MsgBoxYesNo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MsgBoxYesNoCrossCrateImpl { pub _0: azul::AzMsgBoxYesNo }

    #[cfg(feature = "link_static")] pub use MsgBoxYesNoCrossCrateImpl as MsgBoxYesNo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MsgBoxYesNoCrossCrateImpl { type Target = AzMsgBoxYesNo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MsgBoxYesNoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Value returned from an ok / cancel message box
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMsgBoxOkCancel as MsgBoxOkCancel;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MsgBoxOkCancelCrossCrateImpl { pub _0: azul::AzMsgBoxOkCancel }

    #[cfg(feature = "link_static")] pub use MsgBoxOkCancelCrossCrateImpl as MsgBoxOkCancel;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MsgBoxOkCancelCrossCrateImpl { type Target = AzMsgBoxOkCancel; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MsgBoxOkCancelCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// File picker dialog
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileDialog as FileDialog;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileDialogCrossCrateImpl { pub _0: azul::AzFileDialog }

    #[cfg(feature = "link_static")] pub use FileDialogCrossCrateImpl as FileDialog;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileDialogCrossCrateImpl { type Target = AzFileDialog; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileDialogCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl FileDialog {

        /// Select a single file using the system-native file picker. Blocks the current thread.
        pub fn select_file(title: String, default_path: OptionString, filter_list: OptionFileTypeList) ->  crate::option::OptionString { unsafe { crate::dll::AzFileDialog_selectFile(title, default_path, filter_list) } }
        /// Select multiple files using the system-native file picker. Blocks the current thread.
        pub fn select_multiple_files(title: String, default_path: OptionString, filter_list: OptionFileTypeList) ->  crate::option::OptionStringVec { unsafe { crate::dll::AzFileDialog_selectMultipleFiles(title, default_path, filter_list) } }
        /// Open a dialog prompting the user to select a directory to open. Blocks the current thread.
        pub fn select_folder(title: String, default_path: OptionString) ->  crate::option::OptionString { unsafe { crate::dll::AzFileDialog_selectFolder(title, default_path) } }
        /// Open a dialog prompting the user to save a file. Blocks the current thread.
        pub fn save_file(title: String, default_path: OptionString) ->  crate::option::OptionString { unsafe { crate::dll::AzFileDialog_saveFile(title, default_path) } }
    }

    #[cfg(feature = "link_static")]
    impl FileDialogCrossCrateImpl {

        /// Select a single file using the system-native file picker. Blocks the current thread.
        pub fn select_file(title: String, default_path: OptionString, filter_list: OptionFileTypeList) ->  crate::option::OptionString { unsafe { core::mem::transmute(unsafe { azul::AzFileDialog_selectFile(title._0, default_path._0, filter_list._0) }) } }
        /// Select multiple files using the system-native file picker. Blocks the current thread.
        pub fn select_multiple_files(title: String, default_path: OptionString, filter_list: OptionFileTypeList) ->  crate::option::OptionStringVec { unsafe { core::mem::transmute(unsafe { azul::AzFileDialog_selectMultipleFiles(title._0, default_path._0, filter_list._0) }) } }
        /// Open a dialog prompting the user to select a directory to open. Blocks the current thread.
        pub fn select_folder(title: String, default_path: OptionString) ->  crate::option::OptionString { unsafe { core::mem::transmute(unsafe { azul::AzFileDialog_selectFolder(title._0, default_path._0) }) } }
        /// Open a dialog prompting the user to save a file. Blocks the current thread.
        pub fn save_file(title: String, default_path: OptionString) ->  crate::option::OptionString { unsafe { core::mem::transmute(unsafe { azul::AzFileDialog_saveFile(title._0, default_path._0) }) } }
    }

    /// `FileTypeList` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFileTypeList as FileTypeList;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FileTypeListCrossCrateImpl { pub _0: azul::AzFileTypeList }

    #[cfg(feature = "link_static")] pub use FileTypeListCrossCrateImpl as FileTypeList;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FileTypeListCrossCrateImpl { type Target = AzFileTypeList; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FileTypeListCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ColorPickerDialog` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzColorPickerDialog as ColorPickerDialog;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ColorPickerDialogCrossCrateImpl { pub _0: azul::AzColorPickerDialog }

    #[cfg(feature = "link_static")] pub use ColorPickerDialogCrossCrateImpl as ColorPickerDialog;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ColorPickerDialogCrossCrateImpl { type Target = AzColorPickerDialog; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ColorPickerDialogCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ColorPickerDialog {

        /// Opens a system-native color picker dialog
        pub fn open(title: String, default_color: OptionColorU) ->  crate::option::OptionColorU { unsafe { crate::dll::AzColorPickerDialog_open(title, default_color) } }
    }

    #[cfg(feature = "link_static")]
    impl ColorPickerDialogCrossCrateImpl {

        /// Opens a system-native color picker dialog
        pub fn open(title: String, default_color: OptionColorU) ->  crate::option::OptionColorU { unsafe { core::mem::transmute(unsafe { azul::AzColorPickerDialog_open(title._0, default_color._0) }) } }
    }

}

pub mod clipboard {
    #![allow(dead_code, unused_imports)]
    //! Classes to talk to the system clipboard manager
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::str::String;
    /// Connection to the system clipboard, on some systems this connection can be cached
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSystemClipboard as SystemClipboard;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SystemClipboardCrossCrateImpl { pub _0: azul::AzSystemClipboard }

    #[cfg(feature = "link_static")] pub use SystemClipboardCrossCrateImpl as SystemClipboard;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SystemClipboardCrossCrateImpl { type Target = AzSystemClipboard; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SystemClipboardCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl SystemClipboard {

        /// Creates a new connection to the system clipboard manager
        pub fn new() ->  crate::option::OptionSystemClipboard { unsafe { crate::dll::AzSystemClipboard_new() } }
        /// Returns the system clipboard contents or `None` if the clipboard is empty or there was an error
        pub fn get_string_contents(&self)  -> crate::option::OptionString { unsafe { crate::dll::AzSystemClipboard_getStringContents(self) } }
        /// Sets the system clipboard contents to the new string, returns true if the system clipboard was updated
        pub fn set_string_contents(&mut self, contents: String)  -> bool { unsafe { crate::dll::AzSystemClipboard_setStringContents(self, contents) } }
    }

    #[cfg(feature = "link_static")]
    impl SystemClipboardCrossCrateImpl {

        /// Creates a new connection to the system clipboard manager
        pub fn new() ->  crate::option::OptionSystemClipboard { unsafe { core::mem::transmute(unsafe { azul::AzSystemClipboard_new() }) } }
        /// Returns the system clipboard contents or `None` if the clipboard is empty or there was an error
        pub fn get_string_contents(&self)  -> crate::option::OptionString {  unsafe { core::mem::transmute(unsafe { azul::AzSystemClipboard_getStringContents(&self._0) }) } }
        /// Sets the system clipboard contents to the new string, returns true if the system clipboard was updated
        pub fn set_string_contents(&mut self, contents: String)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzSystemClipboard_setStringContents(&mut self._0, contents._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for SystemClipboard { fn clone(&self) -> Self { unsafe { crate::dll::AzSystemClipboard_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for SystemClipboard { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzSystemClipboard_delete(self) } } } }
}

pub mod time {
    #![allow(dead_code, unused_imports)]
    //! Rust wrappers for `Instant` / `Duration` classes
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    /// `Instant` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstant as Instant;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantCrossCrateImpl { pub _0: azul::AzInstant }

    #[cfg(feature = "link_static")] pub use InstantCrossCrateImpl as Instant;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantCrossCrateImpl { type Target = AzInstant; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Instant {

        /// Returns the duration since and earlier instant or None if the earlier instant is later than self
        pub fn duration_since(&self, earlier: Instant)  -> crate::option::OptionDuration { unsafe { crate::dll::AzInstant_durationSince(self, earlier) } }
        /// Adds a duration to the current time instant, returning the new `Instant`
        pub fn add_duration(&mut self, duration: Duration)  -> crate::time::Instant { unsafe { crate::dll::AzInstant_addDuration(self, duration) } }
        /// Linearly interpolates between [start, end] if the `self` Instant lies between start and end. Returns values between 0.0 and 1.0
        pub fn linear_interpolate(&self, start: Instant, end: Instant)  -> f32 { unsafe { crate::dll::AzInstant_linearInterpolate(self, start, end) } }
    }

    #[cfg(feature = "link_static")]
    impl InstantCrossCrateImpl {

        /// Returns the duration since and earlier instant or None if the earlier instant is later than self
        pub fn duration_since(&self, earlier: Instant)  -> crate::option::OptionDuration {  unsafe { core::mem::transmute(unsafe { azul::AzInstant_durationSince(&self._0, earlier._0) }) } }
        /// Adds a duration to the current time instant, returning the new `Instant`
        pub fn add_duration(&mut self, duration: Duration)  -> crate::time::Instant {  unsafe { core::mem::transmute(unsafe { azul::AzInstant_addDuration(&mut self._0, duration._0) }) } }
        /// Linearly interpolates between [start, end] if the `self` Instant lies between start and end. Returns values between 0.0 and 1.0
        pub fn linear_interpolate(&self, start: Instant, end: Instant)  -> f32 {  unsafe { core::mem::transmute(unsafe { azul::AzInstant_linearInterpolate(&self._0, start._0, end._0) }) } }
    }

    /// `InstantPtr` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstantPtr as InstantPtr;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantPtrCrossCrateImpl { pub _0: azul::AzInstantPtr }

    #[cfg(feature = "link_static")] pub use InstantPtrCrossCrateImpl as InstantPtr;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantPtrCrossCrateImpl { type Target = AzInstantPtr; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantPtrCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))] impl Clone for InstantPtr { fn clone(&self) -> Self { unsafe { crate::dll::AzInstantPtr_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for InstantPtr { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzInstantPtr_delete(self) } } } }
    /// `InstantPtrCloneFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstantPtrCloneFnType as InstantPtrCloneFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantPtrCloneFnTypeCrossCrateImpl { pub _0: azul::AzInstantPtrCloneFnType }

    #[cfg(feature = "link_static")] pub use InstantPtrCloneFnTypeCrossCrateImpl as InstantPtrCloneFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantPtrCloneFnTypeCrossCrateImpl { type Target = AzInstantPtrCloneFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantPtrCloneFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InstantPtrCloneFn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstantPtrCloneFn as InstantPtrCloneFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantPtrCloneFnCrossCrateImpl { pub _0: azul::AzInstantPtrCloneFn }

    #[cfg(feature = "link_static")] pub use InstantPtrCloneFnCrossCrateImpl as InstantPtrCloneFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantPtrCloneFnCrossCrateImpl { type Target = AzInstantPtrCloneFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantPtrCloneFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InstantPtrDestructorFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstantPtrDestructorFnType as InstantPtrDestructorFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantPtrDestructorFnTypeCrossCrateImpl { pub _0: azul::AzInstantPtrDestructorFnType }

    #[cfg(feature = "link_static")] pub use InstantPtrDestructorFnTypeCrossCrateImpl as InstantPtrDestructorFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantPtrDestructorFnTypeCrossCrateImpl { type Target = AzInstantPtrDestructorFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantPtrDestructorFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InstantPtrDestructorFn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInstantPtrDestructorFn as InstantPtrDestructorFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InstantPtrDestructorFnCrossCrateImpl { pub _0: azul::AzInstantPtrDestructorFn }

    #[cfg(feature = "link_static")] pub use InstantPtrDestructorFnCrossCrateImpl as InstantPtrDestructorFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InstantPtrDestructorFnCrossCrateImpl { type Target = AzInstantPtrDestructorFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InstantPtrDestructorFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SystemTick` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSystemTick as SystemTick;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SystemTickCrossCrateImpl { pub _0: azul::AzSystemTick }

    #[cfg(feature = "link_static")] pub use SystemTickCrossCrateImpl as SystemTick;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SystemTickCrossCrateImpl { type Target = AzSystemTick; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SystemTickCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Duration` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDuration as Duration;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DurationCrossCrateImpl { pub _0: azul::AzDuration }

    #[cfg(feature = "link_static")] pub use DurationCrossCrateImpl as Duration;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DurationCrossCrateImpl { type Target = AzDuration; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DurationCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SystemTimeDiff` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSystemTimeDiff as SystemTimeDiff;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SystemTimeDiffCrossCrateImpl { pub _0: azul::AzSystemTimeDiff }

    #[cfg(feature = "link_static")] pub use SystemTimeDiffCrossCrateImpl as SystemTimeDiff;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SystemTimeDiffCrossCrateImpl { type Target = AzSystemTimeDiff; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SystemTimeDiffCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SystemTickDiff` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSystemTickDiff as SystemTickDiff;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SystemTickDiffCrossCrateImpl { pub _0: azul::AzSystemTickDiff }

    #[cfg(feature = "link_static")] pub use SystemTickDiffCrossCrateImpl as SystemTickDiff;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SystemTickDiffCrossCrateImpl { type Target = AzSystemTickDiff; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SystemTickDiffCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod task {
    #![allow(dead_code, unused_imports)]
    //! Asyncronous timers / task / thread handlers for easy async loading
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::callbacks::{RefAny, TimerCallbackType};
    use crate::time::Duration;
    /// `TimerId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimerId as TimerId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerIdCrossCrateImpl { pub _0: azul::AzTimerId }

    #[cfg(feature = "link_static")] pub use TimerIdCrossCrateImpl as TimerId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerIdCrossCrateImpl { type Target = AzTimerId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Timer` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTimer as Timer;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TimerCrossCrateImpl { pub _0: azul::AzTimer }

    #[cfg(feature = "link_static")] pub use TimerCrossCrateImpl as Timer;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TimerCrossCrateImpl { type Target = AzTimer; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TimerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl Timer {

        /// Creates a new `Timer` instance.
        pub fn new(timer_data: RefAny, callback: TimerCallbackType, get_system_time_fn: GetSystemTimeFn) -> Self { unsafe { crate::dll::AzTimer_new(timer_data, callback, get_system_time_fn) } }
        /// Calls the `Timer::with_delay` function.
        pub fn with_delay(&self, delay: Duration)  -> crate::task::Timer { unsafe { crate::dll::AzTimer_withDelay(self, delay) } }
        /// Calls the `Timer::with_interval` function.
        pub fn with_interval(&self, interval: Duration)  -> crate::task::Timer { unsafe { crate::dll::AzTimer_withInterval(self, interval) } }
        /// Calls the `Timer::with_timeout` function.
        pub fn with_timeout(&self, timeout: Duration)  -> crate::task::Timer { unsafe { crate::dll::AzTimer_withTimeout(self, timeout) } }
    }

    #[cfg(feature = "link_static")]
    impl TimerCrossCrateImpl {

        /// Creates a new `Timer` instance.
        pub fn new(timer_data: RefAny, callback: TimerCallbackType, get_system_time_fn: GetSystemTimeFn) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzTimer_new(timer_data._0, callback._0, get_system_time_fn._0) }) } }
        /// Calls the `Timer::with_delay` function.
        pub fn with_delay(&self, delay: Duration)  -> crate::task::Timer {  unsafe { core::mem::transmute(unsafe { azul::AzTimer_withDelay(&self._0, delay._0) }) } }
        /// Calls the `Timer::with_interval` function.
        pub fn with_interval(&self, interval: Duration)  -> crate::task::Timer {  unsafe { core::mem::transmute(unsafe { azul::AzTimer_withInterval(&self._0, interval._0) }) } }
        /// Calls the `Timer::with_timeout` function.
        pub fn with_timeout(&self, timeout: Duration)  -> crate::task::Timer {  unsafe { core::mem::transmute(unsafe { azul::AzTimer_withTimeout(&self._0, timeout._0) }) } }
    }

    /// Should a timer terminate or not - used to remove active timers
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTerminateTimer as TerminateTimer;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TerminateTimerCrossCrateImpl { pub _0: azul::AzTerminateTimer }

    #[cfg(feature = "link_static")] pub use TerminateTimerCrossCrateImpl as TerminateTimer;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TerminateTimerCrossCrateImpl { type Target = AzTerminateTimer; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TerminateTimerCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadId as ThreadId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadIdCrossCrateImpl { pub _0: azul::AzThreadId }

    #[cfg(feature = "link_static")] pub use ThreadIdCrossCrateImpl as ThreadId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadIdCrossCrateImpl { type Target = AzThreadId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `Thread` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThread as Thread;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadCrossCrateImpl { pub _0: azul::AzThread }

    #[cfg(feature = "link_static")] pub use ThreadCrossCrateImpl as Thread;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadCrossCrateImpl { type Target = AzThread; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))] impl Clone for Thread { fn clone(&self) -> Self { unsafe { crate::dll::AzThread_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for Thread { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzThread_delete(self) } } } }
    /// `ThreadSender` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSender as ThreadSender;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSenderCrossCrateImpl { pub _0: azul::AzThreadSender }

    #[cfg(feature = "link_static")] pub use ThreadSenderCrossCrateImpl as ThreadSender;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSenderCrossCrateImpl { type Target = AzThreadSender; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSenderCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ThreadSender {

        /// Calls the `ThreadSender::send` function.
        pub fn send(&mut self, msg: ThreadReceiveMsg)  -> bool { unsafe { crate::dll::AzThreadSender_send(self, msg) } }
    }

    #[cfg(feature = "link_static")]
    impl ThreadSenderCrossCrateImpl {

        /// Calls the `ThreadSender::send` function.
        pub fn send(&mut self, msg: ThreadReceiveMsg)  -> bool {  unsafe { core::mem::transmute(unsafe { azul::AzThreadSender_send(&mut self._0, msg._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for ThreadSender { fn clone(&self) -> Self { unsafe { crate::dll::AzThreadSender_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for ThreadSender { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzThreadSender_delete(self) } } } }
    /// `ThreadReceiver` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadReceiver as ThreadReceiver;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadReceiverCrossCrateImpl { pub _0: azul::AzThreadReceiver }

    #[cfg(feature = "link_static")] pub use ThreadReceiverCrossCrateImpl as ThreadReceiver;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadReceiverCrossCrateImpl { type Target = AzThreadReceiver; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadReceiverCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl ThreadReceiver {

        /// Calls the `ThreadReceiver::receive` function.
        pub fn receive(&mut self)  -> crate::option::OptionThreadSendMsg { unsafe { crate::dll::AzThreadReceiver_receive(self) } }
    }

    #[cfg(feature = "link_static")]
    impl ThreadReceiverCrossCrateImpl {

        /// Calls the `ThreadReceiver::receive` function.
        pub fn receive(&mut self)  -> crate::option::OptionThreadSendMsg {  unsafe { core::mem::transmute(unsafe { azul::AzThreadReceiver_receive(&mut self._0) }) } }
    }

    #[cfg(not(feature = "link_static"))] impl Clone for ThreadReceiver { fn clone(&self) -> Self { unsafe { crate::dll::AzThreadReceiver_deepCopy(self) } } }
    #[cfg(not(feature = "link_static"))] impl Drop for ThreadReceiver { fn drop(&mut self) { if self.run_destructor { unsafe { crate::dll::AzThreadReceiver_delete(self) } } } }
    /// `ThreadSendMsg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSendMsg as ThreadSendMsg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSendMsgCrossCrateImpl { pub _0: azul::AzThreadSendMsg }

    #[cfg(feature = "link_static")] pub use ThreadSendMsgCrossCrateImpl as ThreadSendMsg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSendMsgCrossCrateImpl { type Target = AzThreadSendMsg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSendMsgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadReceiveMsg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadReceiveMsg as ThreadReceiveMsg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadReceiveMsgCrossCrateImpl { pub _0: azul::AzThreadReceiveMsg }

    #[cfg(feature = "link_static")] pub use ThreadReceiveMsgCrossCrateImpl as ThreadReceiveMsg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadReceiveMsgCrossCrateImpl { type Target = AzThreadReceiveMsg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadReceiveMsgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadWriteBackMsg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadWriteBackMsg as ThreadWriteBackMsg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadWriteBackMsgCrossCrateImpl { pub _0: azul::AzThreadWriteBackMsg }

    #[cfg(feature = "link_static")] pub use ThreadWriteBackMsgCrossCrateImpl as ThreadWriteBackMsg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadWriteBackMsgCrossCrateImpl { type Target = AzThreadWriteBackMsg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadWriteBackMsgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CreateThreadFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCreateThreadFnType as CreateThreadFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CreateThreadFnTypeCrossCrateImpl { pub _0: azul::AzCreateThreadFnType }

    #[cfg(feature = "link_static")] pub use CreateThreadFnTypeCrossCrateImpl as CreateThreadFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CreateThreadFnTypeCrossCrateImpl { type Target = AzCreateThreadFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CreateThreadFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CreateThreadFn` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCreateThreadFn as CreateThreadFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CreateThreadFnCrossCrateImpl { pub _0: azul::AzCreateThreadFn }

    #[cfg(feature = "link_static")] pub use CreateThreadFnCrossCrateImpl as CreateThreadFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CreateThreadFnCrossCrateImpl { type Target = AzCreateThreadFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CreateThreadFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GetSystemTimeFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGetSystemTimeFnType as GetSystemTimeFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GetSystemTimeFnTypeCrossCrateImpl { pub _0: azul::AzGetSystemTimeFnType }

    #[cfg(feature = "link_static")] pub use GetSystemTimeFnTypeCrossCrateImpl as GetSystemTimeFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GetSystemTimeFnTypeCrossCrateImpl { type Target = AzGetSystemTimeFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GetSystemTimeFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Get the current system time, equivalent to `std::time::Instant::now()`, except it also works on systems that work with "ticks" instead of timers
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGetSystemTimeFn as GetSystemTimeFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GetSystemTimeFnCrossCrateImpl { pub _0: azul::AzGetSystemTimeFn }

    #[cfg(feature = "link_static")] pub use GetSystemTimeFnCrossCrateImpl as GetSystemTimeFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GetSystemTimeFnCrossCrateImpl { type Target = AzGetSystemTimeFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GetSystemTimeFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Callback that checks whether the thread has finished - the input argument is the `dropcheck` field on the Thread.
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckThreadFinishedFnType as CheckThreadFinishedFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckThreadFinishedFnTypeCrossCrateImpl { pub _0: azul::AzCheckThreadFinishedFnType }

    #[cfg(feature = "link_static")] pub use CheckThreadFinishedFnTypeCrossCrateImpl as CheckThreadFinishedFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckThreadFinishedFnTypeCrossCrateImpl { type Target = AzCheckThreadFinishedFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckThreadFinishedFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Function called to check if the thread has finished
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCheckThreadFinishedFn as CheckThreadFinishedFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CheckThreadFinishedFnCrossCrateImpl { pub _0: azul::AzCheckThreadFinishedFn }

    #[cfg(feature = "link_static")] pub use CheckThreadFinishedFnCrossCrateImpl as CheckThreadFinishedFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CheckThreadFinishedFnCrossCrateImpl { type Target = AzCheckThreadFinishedFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CheckThreadFinishedFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LibrarySendThreadMsgFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLibrarySendThreadMsgFnType as LibrarySendThreadMsgFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LibrarySendThreadMsgFnTypeCrossCrateImpl { pub _0: azul::AzLibrarySendThreadMsgFnType }

    #[cfg(feature = "link_static")] pub use LibrarySendThreadMsgFnTypeCrossCrateImpl as LibrarySendThreadMsgFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LibrarySendThreadMsgFnTypeCrossCrateImpl { type Target = AzLibrarySendThreadMsgFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LibrarySendThreadMsgFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Function to send a message to the thread
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLibrarySendThreadMsgFn as LibrarySendThreadMsgFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LibrarySendThreadMsgFnCrossCrateImpl { pub _0: azul::AzLibrarySendThreadMsgFn }

    #[cfg(feature = "link_static")] pub use LibrarySendThreadMsgFnCrossCrateImpl as LibrarySendThreadMsgFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LibrarySendThreadMsgFnCrossCrateImpl { type Target = AzLibrarySendThreadMsgFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LibrarySendThreadMsgFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LibraryReceiveThreadMsgFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLibraryReceiveThreadMsgFnType as LibraryReceiveThreadMsgFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LibraryReceiveThreadMsgFnTypeCrossCrateImpl { pub _0: azul::AzLibraryReceiveThreadMsgFnType }

    #[cfg(feature = "link_static")] pub use LibraryReceiveThreadMsgFnTypeCrossCrateImpl as LibraryReceiveThreadMsgFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LibraryReceiveThreadMsgFnTypeCrossCrateImpl { type Target = AzLibraryReceiveThreadMsgFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LibraryReceiveThreadMsgFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Function to receive a message from the thread
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLibraryReceiveThreadMsgFn as LibraryReceiveThreadMsgFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LibraryReceiveThreadMsgFnCrossCrateImpl { pub _0: azul::AzLibraryReceiveThreadMsgFn }

    #[cfg(feature = "link_static")] pub use LibraryReceiveThreadMsgFnCrossCrateImpl as LibraryReceiveThreadMsgFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LibraryReceiveThreadMsgFnCrossCrateImpl { type Target = AzLibraryReceiveThreadMsgFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LibraryReceiveThreadMsgFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadRecvFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadRecvFnType as ThreadRecvFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadRecvFnTypeCrossCrateImpl { pub _0: azul::AzThreadRecvFnType }

    #[cfg(feature = "link_static")] pub use ThreadRecvFnTypeCrossCrateImpl as ThreadRecvFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadRecvFnTypeCrossCrateImpl { type Target = AzThreadRecvFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadRecvFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Function that the running `Thread` can call to receive messages from the main UI thread
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadRecvFn as ThreadRecvFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadRecvFnCrossCrateImpl { pub _0: azul::AzThreadRecvFn }

    #[cfg(feature = "link_static")] pub use ThreadRecvFnCrossCrateImpl as ThreadRecvFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadRecvFnCrossCrateImpl { type Target = AzThreadRecvFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadRecvFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadSendFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSendFnType as ThreadSendFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSendFnTypeCrossCrateImpl { pub _0: azul::AzThreadSendFnType }

    #[cfg(feature = "link_static")] pub use ThreadSendFnTypeCrossCrateImpl as ThreadSendFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSendFnTypeCrossCrateImpl { type Target = AzThreadSendFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSendFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Function that the running `Thread` can call to receive messages from the main UI thread
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSendFn as ThreadSendFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSendFnCrossCrateImpl { pub _0: azul::AzThreadSendFn }

    #[cfg(feature = "link_static")] pub use ThreadSendFnCrossCrateImpl as ThreadSendFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSendFnCrossCrateImpl { type Target = AzThreadSendFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSendFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadDestructorFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadDestructorFnType as ThreadDestructorFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadDestructorFnTypeCrossCrateImpl { pub _0: azul::AzThreadDestructorFnType }

    #[cfg(feature = "link_static")] pub use ThreadDestructorFnTypeCrossCrateImpl as ThreadDestructorFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadDestructorFnTypeCrossCrateImpl { type Target = AzThreadDestructorFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadDestructorFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Destructor of the `Thread`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadDestructorFn as ThreadDestructorFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadDestructorFnCrossCrateImpl { pub _0: azul::AzThreadDestructorFn }

    #[cfg(feature = "link_static")] pub use ThreadDestructorFnCrossCrateImpl as ThreadDestructorFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadDestructorFnCrossCrateImpl { type Target = AzThreadDestructorFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadDestructorFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadReceiverDestructorFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadReceiverDestructorFnType as ThreadReceiverDestructorFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadReceiverDestructorFnTypeCrossCrateImpl { pub _0: azul::AzThreadReceiverDestructorFnType }

    #[cfg(feature = "link_static")] pub use ThreadReceiverDestructorFnTypeCrossCrateImpl as ThreadReceiverDestructorFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadReceiverDestructorFnTypeCrossCrateImpl { type Target = AzThreadReceiverDestructorFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadReceiverDestructorFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Destructor of the `ThreadReceiver`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadReceiverDestructorFn as ThreadReceiverDestructorFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadReceiverDestructorFnCrossCrateImpl { pub _0: azul::AzThreadReceiverDestructorFn }

    #[cfg(feature = "link_static")] pub use ThreadReceiverDestructorFnCrossCrateImpl as ThreadReceiverDestructorFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadReceiverDestructorFnCrossCrateImpl { type Target = AzThreadReceiverDestructorFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadReceiverDestructorFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ThreadSenderDestructorFnType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSenderDestructorFnType as ThreadSenderDestructorFnType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSenderDestructorFnTypeCrossCrateImpl { pub _0: azul::AzThreadSenderDestructorFnType }

    #[cfg(feature = "link_static")] pub use ThreadSenderDestructorFnTypeCrossCrateImpl as ThreadSenderDestructorFnType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSenderDestructorFnTypeCrossCrateImpl { type Target = AzThreadSenderDestructorFnType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSenderDestructorFnTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Destructor of the `ThreadSender`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzThreadSenderDestructorFn as ThreadSenderDestructorFn;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ThreadSenderDestructorFnCrossCrateImpl { pub _0: azul::AzThreadSenderDestructorFn }

    #[cfg(feature = "link_static")] pub use ThreadSenderDestructorFnCrossCrateImpl as ThreadSenderDestructorFn;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ThreadSenderDestructorFnCrossCrateImpl { type Target = AzThreadSenderDestructorFn; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ThreadSenderDestructorFnCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod str {
    #![allow(dead_code, unused_imports)]
    //! Definition of azuls internal `String` wrappers
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;

    use alloc::string;

    #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
    use serde::{Serialize, Deserialize, Serializer, Deserializer};

    #[cfg(not(feature = "link_static"))]
    #[cfg(feature = "serde-support")]
    impl Serialize for crate::str::String {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where S: Serializer,
        {
            serializer.serialize_str(self.as_str())
        }
    }

    #[cfg(not(feature = "link_static"))]
    #[cfg(feature = "serde-support")]
    impl<'de> Deserialize<'de> for crate::str::String {
        fn deserialize<D>(deserializer: D) -> Result<crate::str::String, D::Error>
        where D: Deserializer<'de>,
        {
            let s = string::String::deserialize(deserializer)?;
            Ok(s.into())
        }
    }


    #[cfg(not(feature = "link_static"))]
    impl From<&'static str> for crate::str::String {
        fn from(v: &'static str) -> crate::str::String {
            crate::str::String::from_const_str(v)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl From<string::String> for crate::str::String {
        fn from(s: string::String) -> crate::str::String {
            crate::str::String::from_string(s)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl AsRef<str> for crate::str::String {
        fn as_ref(&self) -> &str {
            self.as_str()
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl core::fmt::Debug for crate::str::String {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.as_str().fmt(f)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl core::fmt::Display for crate::str::String {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.as_str().fmt(f)
        }
    }

    #[cfg(not(feature = "link_static"))]
    impl crate::str::String {

        #[inline(always)]
        pub fn from_string(s: string::String) -> crate::str::String {
            crate::str::String {
                vec: crate::vec::U8Vec::from_vec(s.into_bytes())
            }
        }

        #[inline(always)]
        pub const fn from_const_str(s: &'static str) -> crate::str::String {
            crate::str::String {
                vec: crate::vec::U8Vec::from_const_slice(s.as_bytes())
            }
        }
    }    use crate::vec::FmtArgVec;
    /// `FmtValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFmtValue as FmtValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FmtValueCrossCrateImpl { pub _0: azul::AzFmtValue }

    #[cfg(feature = "link_static")] pub use FmtValueCrossCrateImpl as FmtValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FmtValueCrossCrateImpl { type Target = AzFmtValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FmtValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FmtArg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFmtArg as FmtArg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FmtArgCrossCrateImpl { pub _0: azul::AzFmtArg }

    #[cfg(feature = "link_static")] pub use FmtArgCrossCrateImpl as FmtArg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FmtArgCrossCrateImpl { type Target = AzFmtArg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FmtArgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `String` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzString as String;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringCrossCrateImpl { pub _0: azul::AzString }

    #[cfg(feature = "link_static")] pub use StringCrossCrateImpl as String;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringCrossCrateImpl { type Target = AzString; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl String {

        /// Creates a dynamically formatted String from a fomat string + named arguments
        pub fn format(format: String, args: FmtArgVec) -> Self { unsafe { crate::dll::AzString_format(format, args) } }
        /// Creates a new String from an arbitary pointer, a start offset (bytes from the start pointer, usually 0) and a length (in bytes). The bytes are expected to point to a UTF-8 encoded string, no error checking is performed.
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self { unsafe { crate::dll::AzString_copyFromBytes(ptr, start, len) } }
        /// Trims whitespace from the start / end of the string
        pub fn trim(&self)  -> crate::str::String { unsafe { crate::dll::AzString_trim(self) } }
        /// Returns a reference to the string - NOTE: the returned value is a reference to `self`, you MUST NOT drop the `String` object that the `Refstr` references
        pub fn as_refstr(&self)  -> crate::gl::Refstr { unsafe { crate::dll::AzString_asRefstr(self) } }
    }

    #[cfg(feature = "link_static")]
    impl StringCrossCrateImpl {

        /// Creates a dynamically formatted String from a fomat string + named arguments
        pub fn format(format: String, args: FmtArgVec) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzString_format(format._0, args._0) }) } }
        /// Creates a new String from an arbitary pointer, a start offset (bytes from the start pointer, usually 0) and a length (in bytes). The bytes are expected to point to a UTF-8 encoded string, no error checking is performed.
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzString_copyFromBytes(ptr, start, len) }) } }
        /// Trims whitespace from the start / end of the string
        pub fn trim(&self)  -> crate::str::String {  unsafe { core::mem::transmute(unsafe { azul::AzString_trim(&self._0) }) } }
        /// Returns a reference to the string - NOTE: the returned value is a reference to `self`, you MUST NOT drop the `String` object that the `Refstr` references
        pub fn as_refstr(&self)  -> crate::gl::Refstr {  unsafe { core::mem::transmute(unsafe { azul::AzString_asRefstr(&self._0) }) } }
    }

}

pub mod vec {
    #![allow(dead_code, unused_imports)]
    //! Definition of azuls internal `Vec<*>` wrappers
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use core::iter;
    use core::fmt;
    use core::cmp;

    use alloc::vec::{self, Vec};
    use alloc::slice;
    use alloc::string;

    use crate::gl::{
        GLint as AzGLint,
        GLuint as AzGLuint,
    };

    macro_rules! impl_vec {($struct_type:ident, $struct_name:ident, $destructor_name:ident, $c_destructor_fn_name:ident, $crate_dll_delete_fn:ident) => (

        #[cfg(not(feature = "link_static"))]
        unsafe impl Send for $struct_name { }
        #[cfg(not(feature = "link_static"))]
        unsafe impl Sync for $struct_name { }

        #[cfg(not(feature = "link_static"))]
        impl fmt::Debug for $destructor_name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    $destructor_name::DefaultRust => write!(f, "DefaultRust"),
                    $destructor_name::NoDestructor => write!(f, "NoDestructor"),
                    $destructor_name::External(_) => write!(f, "External"),
                }
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl PartialEq for $destructor_name {
            fn eq(&self, rhs: &Self) -> bool {
                match (self, rhs) {
                    ($destructor_name::DefaultRust, $destructor_name::DefaultRust) => true,
                    ($destructor_name::NoDestructor, $destructor_name::NoDestructor) => true,
                    ($destructor_name::External(a), $destructor_name::External(b)) => (a as *const _ as usize).eq(&(b as *const _ as usize)),
                    _ => false,
                }
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl PartialOrd for $destructor_name {
            fn partial_cmp(&self, _rhs: &Self) -> Option<cmp::Ordering> {
                None
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl $struct_name {

            #[inline]
            pub fn iter(&self) -> slice::Iter<$struct_type> {
                self.as_ref().iter()
            }

            #[inline]
            pub fn ptr_as_usize(&self) -> usize {
                self.ptr as usize
            }

            #[inline]
            pub fn len(&self) -> usize {
                self.len
            }

            #[inline]
            pub fn capacity(&self) -> usize {
                self.cap
            }

            #[inline]
            pub fn is_empty(&self) -> bool {
                self.len == 0
            }

            pub fn get(&self, index: usize) -> Option<&$struct_type> {
                let v1: &[$struct_type] = self.as_ref();
                let res = v1.get(index);
                res
            }

            #[inline]
            unsafe fn get_unchecked(&self, index: usize) -> &$struct_type {
                let v1: &[$struct_type] = self.as_ref();
                let res = v1.get_unchecked(index);
                res
            }

            pub fn as_slice(&self) -> &[$struct_type] {
                self.as_ref()
            }

            #[inline(always)]
            pub const fn from_const_slice(input: &'static [$struct_type]) -> Self {
                Self {
                    ptr: input.as_ptr(),
                    len: input.len(),
                    cap: input.len(),
                    destructor: $destructor_name::NoDestructor, // because of &'static
                }
            }

            #[inline(always)]
            pub fn from_vec(input: Vec<$struct_type>) -> Self {

                extern "C" fn $c_destructor_fn_name(s: &mut $struct_name) {
                    let _ = unsafe { Vec::from_raw_parts(s.ptr as *mut $struct_type, s.len, s.cap) };
                }

                let ptr = input.as_ptr();
                let len = input.len();
                let cap = input.capacity();

                let _ = ::core::mem::ManuallyDrop::new(input);

                Self {
                    ptr,
                    len,
                    cap,
                    destructor: $destructor_name::External($c_destructor_fn_name),
                }
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl AsRef<[$struct_type]> for $struct_name {
            fn as_ref(&self) -> &[$struct_type] {
                unsafe { slice::from_raw_parts(self.ptr, self.len) }
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl iter::FromIterator<$struct_type> for $struct_name {
            fn from_iter<T>(iter: T) -> Self where T: IntoIterator<Item = $struct_type> {
                Self::from_vec(Vec::from_iter(iter))
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl From<Vec<$struct_type>> for $struct_name {
            fn from(input: Vec<$struct_type>) -> $struct_name {
                Self::from_vec(input)
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl From<&'static [$struct_type]> for $struct_name {
            fn from(input: &'static [$struct_type]) -> $struct_name {
                Self::from_const_slice(input)
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl Drop for $struct_name {
            fn drop(&mut self) {
                match self.destructor {
                    $destructor_name::DefaultRust => { unsafe { crate::dll::$crate_dll_delete_fn(self); } },
                    $destructor_name::NoDestructor => { },
                    $destructor_name::External(f) => { f(self); }
                }
                // necessary so that double-frees are avoided
                self.destructor = $destructor_name::NoDestructor;
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl fmt::Debug for $struct_name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                self.as_ref().fmt(f)
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl PartialOrd for $struct_name {
            fn partial_cmp(&self, rhs: &Self) -> Option<cmp::Ordering> {
                self.as_ref().partial_cmp(rhs.as_ref())
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl PartialEq for $struct_name {
            fn eq(&self, rhs: &Self) -> bool {
                self.as_ref().eq(rhs.as_ref())
            }
        }
    )}

    macro_rules! impl_vec_clone {($struct_type:ident, $struct_name:ident, $destructor_name:ident) => (
        #[cfg(not(feature = "link_static"))]
        impl $struct_name {
            /// NOTE: CLONES the memory if the memory is external or &'static
            /// Moves the memory out if the memory is library-allocated
            #[inline(always)]
            pub fn clone_self(&self) -> Self {
                match self.destructor {
                    $destructor_name::NoDestructor => {
                        Self {
                            ptr: self.ptr,
                            len: self.len,
                            cap: self.cap,
                            destructor: $destructor_name::NoDestructor,
                        }
                    }
                    $destructor_name::External(_) | $destructor_name::DefaultRust => {
                        Self::from_vec(self.as_ref().to_vec())
                    }
                }
            }
        }

        #[cfg(not(feature = "link_static"))]
        impl Clone for $struct_name {
            fn clone(&self) -> Self {
                self.clone_self()
            }
        }
    )}

    macro_rules! impl_vec_serde {($struct_type:ident, $struct_name:ident) => (
        #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
        use serde::{Serialize, Deserialize, Serializer, Deserializer};

        #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
        impl Serialize for $struct_name {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where S: Serializer,
            {
                self.as_ref().serialize(serializer)
            }
        }

        #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
        impl<'de> Deserialize<'de> for $struct_name {
            fn deserialize<D>(deserializer: D) -> Result<$struct_name, D::Error>
            where D: Deserializer<'de>,
            {
                let s = Vec::<$struct_type>::deserialize(deserializer)?;
                Ok(s.into())
            }
        }
    )}

    impl_vec!(u8,  AzU8Vec,  AzU8VecDestructor, az_u8_vec_destructor, AzU8Vec_delete);
    impl_vec_clone!(u8,  AzU8Vec,  AzU8VecDestructor);
    impl_vec!(u16, AzU16Vec, AzU16VecDestructor, az_u16_vec_destructor, AzU16Vec_delete);
    impl_vec_clone!(u16, AzU16Vec, AzU16VecDestructor);
    impl_vec!(u32, AzU32Vec, AzU32VecDestructor, az_u32_vec_destructor, AzU32Vec_delete);
    impl_vec_clone!(u32, AzU32Vec, AzU32VecDestructor);
    impl_vec!(u32, AzScanCodeVec, AzScanCodeVecDestructor, az_scan_code_vec_destructor, AzScanCodeVec_delete);
    impl_vec_clone!(u32, AzScanCodeVec, AzScanCodeVecDestructor);
    impl_vec!(u32, AzGLuintVec, AzGLuintVecDestructor, az_g_luint_vec_destructor, AzGLuintVec_delete);
    impl_vec_clone!(u32, AzGLuintVec, AzGLuintVecDestructor);
    impl_vec!(i32, AzGLintVec, AzGLintVecDestructor, az_g_lint_vec_destructor, AzGLintVec_delete);
    impl_vec_clone!(i32, AzGLintVec, AzGLintVecDestructor);
    impl_vec!(f32,  AzF32Vec,  AzF32VecDestructor, az_f32_vec_destructor, AzF32Vec_delete);
    impl_vec_clone!(f32,  AzF32Vec,  AzF32VecDestructor);
    impl_vec!(AzXmlNode,  AzXmlNodeVec,  AzXmlNodeVecDestructor, az_xml_node_vec_destructor, AzXmlNodeVec_delete);
    impl_vec_clone!(AzXmlNode,  AzXmlNodeVec,  AzXmlNodeVecDestructor);
    impl_vec!(AzInlineWord,  AzInlineWordVec,  AzInlineWordVecDestructor, az_inline_word_vec_destructor, AzInlineWordVec_delete);
    impl_vec_clone!(AzInlineWord,  AzInlineWordVec,  AzInlineWordVecDestructor);
    impl_vec!(AzInlineGlyph,  AzInlineGlyphVec,  AzInlineGlyphVecDestructor, az_inline_glyph_vec_destructor, AzInlineGlyphVec_delete);
    impl_vec_clone!(AzInlineGlyph,  AzInlineGlyphVec,  AzInlineGlyphVecDestructor);
    impl_vec!(AzInlineLine,  AzInlineLineVec,  AzInlineLineVecDestructor, az_inline_line_vec_destructor, AzInlineLineVec_delete);
    impl_vec_clone!(AzInlineLine,  AzInlineLineVec,  AzInlineLineVecDestructor);
    impl_vec!(AzFmtArg,  AzFmtArgVec,  AzFmtArgVecDestructor, az_fmt_arg_vec_destructor, AzFmtArgVec_delete);
    impl_vec_clone!(AzFmtArg,  AzFmtArgVec,  AzFmtArgVecDestructor);
    impl_vec!(AzInlineTextHit,  AzInlineTextHitVec,  AzInlineTextHitVecDestructor, az_inline_text_hit_vec_destructor, AzInlineTextHitVec_delete);
    impl_vec_clone!(AzInlineTextHit,  AzInlineTextHitVec,  AzInlineTextHitVecDestructor);
    impl_vec!(AzTessellatedSvgNode,  AzTessellatedSvgNodeVec,  AzTessellatedSvgNodeVecDestructor, az_tesselated_svg_node_vec_destructor, AzTessellatedSvgNodeVec_delete);
    impl_vec_clone!(AzTessellatedSvgNode,  AzTessellatedSvgNodeVec,  AzTessellatedSvgNodeVecDestructor);
    impl_vec!(AzNodeDataInlineCssProperty, AzNodeDataInlineCssPropertyVec, NodeDataInlineCssPropertyVecDestructor, az_node_data_inline_css_property_vec_destructor, AzNodeDataInlineCssPropertyVec_delete);
    impl_vec_clone!(AzNodeDataInlineCssProperty, AzNodeDataInlineCssPropertyVec, NodeDataInlineCssPropertyVecDestructor);
    impl_vec!(AzIdOrClass, AzIdOrClassVec, IdOrClassVecDestructor, az_id_or_class_vec_destructor, AzIdOrClassVec_delete);
    impl_vec_clone!(AzIdOrClass, AzIdOrClassVec, IdOrClassVecDestructor);
    impl_vec!(AzStyleTransform, AzStyleTransformVec, AzStyleTransformVecDestructor, az_style_transform_vec_destructor, AzStyleTransformVec_delete);
    impl_vec_clone!(AzStyleTransform, AzStyleTransformVec, AzStyleTransformVecDestructor);
    impl_vec!(AzCssProperty, AzCssPropertyVec, AzCssPropertyVecDestructor, az_css_property_vec_destructor, AzCssPropertyVec_delete);
    impl_vec_clone!(AzCssProperty, AzCssPropertyVec, AzCssPropertyVecDestructor);
    impl_vec!(AzSvgMultiPolygon, AzSvgMultiPolygonVec, AzSvgMultiPolygonVecDestructor, az_svg_multi_polygon_vec_destructor, AzSvgMultiPolygonVec_delete);
    impl_vec_clone!(AzSvgMultiPolygon, AzSvgMultiPolygonVec, AzSvgMultiPolygonVecDestructor);
    impl_vec!(AzSvgPath, AzSvgPathVec, AzSvgPathVecDestructor, az_svg_path_vec_destructor, AzSvgPathVec_delete);
    impl_vec_clone!(AzSvgPath, AzSvgPathVec, AzSvgPathVecDestructor);
    impl_vec!(AzVertexAttribute, AzVertexAttributeVec, AzVertexAttributeVecDestructor, az_vertex_attribute_vec_destructor, AzVertexAttributeVec_delete);
    impl_vec_clone!(AzVertexAttribute, AzVertexAttributeVec, AzVertexAttributeVecDestructor);
    impl_vec!(AzSvgPathElement, AzSvgPathElementVec, AzSvgPathElementVecDestructor, az_svg_path_element_vec_destructor, AzSvgPathElementVec_delete);
    impl_vec_clone!(AzSvgPathElement, AzSvgPathElementVec, AzSvgPathElementVecDestructor);
    impl_vec!(AzSvgVertex, AzSvgVertexVec, AzSvgVertexVecDestructor, az_svg_vertex_vec_destructor, AzSvgVertexVec_delete);
    impl_vec_clone!(AzSvgVertex, AzSvgVertexVec, AzSvgVertexVecDestructor);
    impl_vec!(AzXWindowType, AzXWindowTypeVec, AzXWindowTypeVecDestructor, az_x_window_type_vec_destructor, AzXWindowTypeVec_delete);
    impl_vec_clone!(AzXWindowType, AzXWindowTypeVec, AzXWindowTypeVecDestructor);
    impl_vec!(AzVirtualKeyCode, AzVirtualKeyCodeVec, AzVirtualKeyCodeVecDestructor, az_virtual_key_code_vec_destructor, AzVirtualKeyCodeVec_delete);
    impl_vec_clone!(AzVirtualKeyCode, AzVirtualKeyCodeVec, AzVirtualKeyCodeVecDestructor);
    impl_vec!(AzCascadeInfo, AzCascadeInfoVec, AzCascadeInfoVecDestructor, az_cascade_info_vec_destructor, AzCascadeInfoVec_delete);
    impl_vec_clone!(AzCascadeInfo, AzCascadeInfoVec, AzCascadeInfoVecDestructor);
    impl_vec!(AzCssDeclaration, AzCssDeclarationVec, AzCssDeclarationVecDestructor, az_css_declaration_vec_destructor, AzCssDeclarationVec_delete);
    impl_vec_clone!(AzCssDeclaration, AzCssDeclarationVec, AzCssDeclarationVecDestructor);
    impl_vec!(AzCssPathSelector, AzCssPathSelectorVec, AzCssPathSelectorVecDestructor, az_css_path_selector_vec_destructor, AzCssPathSelectorVec_delete);
    impl_vec_clone!(AzCssPathSelector, AzCssPathSelectorVec, AzCssPathSelectorVecDestructor);
    impl_vec!(AzStylesheet, AzStylesheetVec, AzStylesheetVecDestructor, az_stylesheet_vec_destructor, AzStylesheetVec_delete);
    impl_vec_clone!(AzStylesheet, AzStylesheetVec, AzStylesheetVecDestructor);
    impl_vec!(AzCssRuleBlock, AzCssRuleBlockVec, AzCssRuleBlockVecDestructor, az_css_rule_block_vec_destructor, AzCssRuleBlockVec_delete);
    impl_vec_clone!(AzCssRuleBlock, AzCssRuleBlockVec, AzCssRuleBlockVecDestructor);
    impl_vec!(AzCallbackData, AzCallbackDataVec, AzCallbackDataVecDestructor, az_callback_data_vec_destructor, AzCallbackDataVec_delete);
    impl_vec_clone!(AzCallbackData, AzCallbackDataVec, AzCallbackDataVecDestructor);
    impl_vec!(AzDebugMessage, AzDebugMessageVec, AzDebugMessageVecDestructor, az_debug_message_vec_destructor, AzDebugMessageVec_delete);
    impl_vec_clone!(AzDebugMessage, AzDebugMessageVec, AzDebugMessageVecDestructor);
    impl_vec!(AzDom, AzDomVec, AzDomVecDestructor, az_dom_vec_destructor, AzDomVec_delete);
    impl_vec_clone!(AzDom, AzDomVec, AzDomVecDestructor);
    impl_vec!(AzString, AzStringVec, AzStringVecDestructor, az_string_vec_destructor, AzStringVec_delete);
    impl_vec_clone!(AzString, AzStringVec, AzStringVecDestructor);
    impl_vec!(AzStringPair, AzStringPairVec, AzStringPairVecDestructor, az_string_pair_vec_destructor, AzStringPairVec_delete);
    impl_vec_clone!(AzStringPair, AzStringPairVec, AzStringPairVecDestructor);
    impl_vec!(AzNormalizedLinearColorStop, AzNormalizedLinearColorStopVec, AzNormalizedLinearColorStopVecDestructor, az_normalized_linear_color_stop_vec_destructor, AzNormalizedLinearColorStopVec_delete);
    impl_vec_clone!(AzNormalizedLinearColorStop, AzNormalizedLinearColorStopVec, AzNormalizedLinearColorStopVecDestructor);
    impl_vec!(AzNormalizedRadialColorStop, AzNormalizedRadialColorStopVec, AzNormalizedRadialColorStopVecDestructor, az_normalized_radial_color_stop_vec_destructor, AzNormalizedRadialColorStopVec_delete);
    impl_vec_clone!(AzNormalizedRadialColorStop, AzNormalizedRadialColorStopVec, AzNormalizedRadialColorStopVecDestructor);
    impl_vec!(AzNodeId, AzNodeIdVec, AzNodeIdVecDestructor, az_node_id_vec_destructor, AzNodeIdVec_delete);
    impl_vec_clone!(AzNodeId, AzNodeIdVec, AzNodeIdVecDestructor);
    impl_vec!(AzNodeHierarchyItem, AzNodeHierarchyItemVec, AzNodeHierarchyItemVecDestructor, az_node_hierarchy_item_vec_destructor, AzNodeHierarchyItemVec_delete);
    impl_vec_clone!(AzNodeHierarchyItem, AzNodeHierarchyItemVec, AzNodeHierarchyItemVecDestructor);
    impl_vec!(AzStyledNode, AzStyledNodeVec, AzStyledNodeVecDestructor, az_styled_node_vec_destructor, AzStyledNodeVec_delete);
    impl_vec_clone!(AzStyledNode, AzStyledNodeVec, AzStyledNodeVecDestructor);
    impl_vec!(AzTagIdToNodeIdMapping, AzTagIdToNodeIdMappingVec, AzTagIdToNodeIdMappingVecDestructor, az_tag_id_to_node_id_mapping_vec_destructor, AzTagIdToNodeIdMappingVec_delete);
    impl_vec_clone!(AzTagIdToNodeIdMapping, AzTagIdToNodeIdMappingVec, AzTagIdToNodeIdMappingVecDestructor);
    impl_vec!(AzParentWithNodeDepth, AzParentWithNodeDepthVec, AzParentWithNodeDepthVecDestructor, az_parent_with_node_depth_vec_destructor, AzParentWithNodeDepthVec_delete);
    impl_vec_clone!(AzParentWithNodeDepth, AzParentWithNodeDepthVec, AzParentWithNodeDepthVecDestructor);
    impl_vec!(AzNodeData, AzNodeDataVec, AzNodeDataVecDestructor, az_node_data_vec_destructor, AzNodeDataVec_delete);
    impl_vec_clone!(AzNodeData, AzNodeDataVec, AzNodeDataVecDestructor);
    impl_vec!(AzStyleBackgroundRepeat, AzStyleBackgroundRepeatVec, AzStyleBackgroundRepeatVecDestructor, az_style_background_repeat_vec_destructor, AzStyleBackgroundRepeatVec_delete);
    impl_vec_clone!(AzStyleBackgroundRepeat, AzStyleBackgroundRepeatVec, AzStyleBackgroundRepeatVecDestructor);
    impl_vec!(AzStyleBackgroundPosition, AzStyleBackgroundPositionVec, AzStyleBackgroundPositionVecDestructor, az_style_background_position_vec_destructor, AzStyleBackgroundPositionVec_delete);
    impl_vec_clone!(AzStyleBackgroundPosition, AzStyleBackgroundPositionVec, AzStyleBackgroundPositionVecDestructor);
    impl_vec!(AzStyleBackgroundSize, AzStyleBackgroundSizeVec, AzStyleBackgroundSizeVecDestructor, az_style_background_size_vec_destructor, AzStyleBackgroundSizeVec_delete);
    impl_vec_clone!(AzStyleBackgroundSize, AzStyleBackgroundSizeVec, AzStyleBackgroundSizeVecDestructor);
    impl_vec!(AzStyleBackgroundContent, AzStyleBackgroundContentVec, AzStyleBackgroundContentVecDestructor, az_style_background_content_vec_destructor, AzStyleBackgroundContentVec_delete);
    impl_vec_clone!(AzStyleBackgroundContent, AzStyleBackgroundContentVec, AzStyleBackgroundContentVecDestructor);
    impl_vec!(AzVideoMode, AzVideoModeVec, AzVideoModeVecDestructor, az_video_mode_vec_destructor, AzVideoModeVec_delete);
    impl_vec_clone!(AzVideoMode, AzVideoModeVec, AzVideoModeVecDestructor);
    impl_vec!(AzMonitor, AzMonitorVec, AzMonitorVecDestructor, az_monitor_vec_destructor, AzMonitorVec_delete);
    impl_vec_clone!(AzMonitor, AzMonitorVec, AzMonitorVecDestructor);
    impl_vec!(AzStyleFontFamily, AzStyleFontFamilyVec, AzStyleFontFamilyVecDestructor, az_style_font_family_vec_destructor, AzStyleFontFamilyVec_delete);
    impl_vec_clone!(AzStyleFontFamily, AzStyleFontFamilyVec, AzStyleFontFamilyVecDestructor);
    impl_vec!(AzTab, AzTabVec, AzTabVecDestructor, az_tab_vec_destructor, AzTabVec_delete);
    impl_vec_clone!(AzTab, AzTabVec, AzTabVecDestructor);
    impl_vec!(AzNodeTypeIdInfoMap, AzNodeTypeIdInfoMapVec, AzNodeTypeIdInfoMapVecDestructor, az_node_type_id_info_map_vec_destructor, AzNodeTypeIdInfoMapVec_delete);
    impl_vec_clone!(AzNodeTypeIdInfoMap, AzNodeTypeIdInfoMapVec, AzNodeTypeIdInfoMapVecDestructor);
    impl_vec!(AzInputOutputTypeIdInfoMap, AzInputOutputTypeIdInfoMapVec, AzInputOutputTypeIdInfoMapVecDestructor, az_input_output_type_id_info_map_vec_destructor, AzInputOutputTypeIdInfoMapVec_delete);
    impl_vec_clone!(AzInputOutputTypeIdInfoMap, AzInputOutputTypeIdInfoMapVec, AzInputOutputTypeIdInfoMapVecDestructor);
    impl_vec!(AzNodeIdNodeMap, AzNodeIdNodeMapVec, AzNodeIdNodeMapVecDestructor, az_node_id_node_map_vec_destructor, AzNodeIdNodeMapVec_delete);
    impl_vec_clone!(AzNodeIdNodeMap, AzNodeIdNodeMapVec, AzNodeIdNodeMapVecDestructor);
    impl_vec!(AzInputOutputTypeId, AzInputOutputTypeIdVec, AzInputOutputTypeIdVecDestructor, az_input_output_type_id_vec_destructor, AzInputOutputTypeIdVec_delete);
    impl_vec_clone!(AzInputOutputTypeId, AzInputOutputTypeIdVec, AzInputOutputTypeIdVecDestructor);
    impl_vec_serde!(AzInputOutputTypeId, AzInputOutputTypeIdVec);
    impl_vec!(AzNodeTypeField, AzNodeTypeFieldVec, AzNodeTypeFieldVecDestructor, az_node_type_field_vec_destructor, AzNodeTypeFieldVec_delete);
    impl_vec_clone!(AzNodeTypeField, AzNodeTypeFieldVec, AzNodeTypeFieldVecDestructor);
    impl_vec!(AzInputConnection, AzInputConnectionVec, AzInputConnectionVecDestructor, az_input_connection_vec_destructor, AzInputConnectionVec_delete);
    impl_vec_clone!(AzInputConnection, AzInputConnectionVec, AzInputConnectionVecDestructor);
    impl_vec!(AzOutputNodeAndIndex, AzOutputNodeAndIndexVec, AzOutputNodeAndIndexVecDestructor, az_output_node_and_index_vec_destructor, AzOutputNodeAndIndexVec_delete);
    impl_vec_clone!(AzOutputNodeAndIndex, AzOutputNodeAndIndexVec, AzOutputNodeAndIndexVecDestructor);
    impl_vec!(AzOutputConnection, AzOutputConnectionVec, AzOutputConnectionVecDestructor, az_output_connection_vec_destructor, AzOutputConnectionVec_delete);
    impl_vec_clone!(AzOutputConnection, AzOutputConnectionVec, AzOutputConnectionVecDestructor);
    impl_vec!(AzInputNodeAndIndex, AzInputNodeAndIndexVec, AzInputNodeAndIndexVecDestructor, az_input_node_and_index_vec_destructor, AzInputNodeAndIndexVec_delete);
    impl_vec_clone!(AzInputNodeAndIndex, AzInputNodeAndIndexVec, AzInputNodeAndIndexVecDestructor);
    impl_vec!(AzLogicalRect, AzLogicalRectVec, AzLogicalRectVecDestructor, az_logical_rect_vec_destructor, AzLogicalRectVec_delete);
    impl_vec_clone!(AzLogicalRect, AzLogicalRectVec, AzLogicalRectVecDestructor);
    impl_vec!(AzStyleFilter, AzStyleFilterVec, AzStyleFilterVecDestructor, az_style_filter_vec_destructor, AzStyleFilterVec_delete);
    impl_vec_clone!(AzStyleFilter, AzStyleFilterVec, AzStyleFilterVecDestructor);

    impl_vec!(AzAccessibilityState,  AzAccessibilityStateVec,  AzAccessibilityStateVecDestructor, az_accessibility_state_vec_destructor, AzAccessibilityStateVec_delete);
    impl_vec_clone!(AzAccessibilityState,  AzAccessibilityStateVec,  AzAccessibilityStateVecDestructor);

    impl_vec!(AzMenuItem,  AzMenuItemVec,  AzMenuItemVecDestructor, az_menu_item_vec_destructor, AzMenuItemVec_delete);
    impl_vec_clone!(AzMenuItem,  AzMenuItemVec,  AzMenuItemVecDestructor);

    #[cfg(not(feature = "link_static"))]
    impl From<vec::Vec<string::String>> for crate::vec::StringVec {
        fn from(v: vec::Vec<string::String>) -> crate::vec::StringVec {
            let vec: Vec<AzString> = v.into_iter().map(Into::into).collect();
            vec.into()
            // v dropped here
        }
    }

    #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
    impl Serialize for crate::prelude::SvgPathElementVec {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where S: Serializer,
        {
            self.as_ref().serialize(serializer)
        }
    }

    #[cfg(all(feature = "serde-support", not(feature = "link_static")))]
    impl<'de> Deserialize<'de> for crate::prelude::SvgPathElementVec {
        fn deserialize<D>(deserializer: D) -> Result<crate::prelude::SvgPathElementVec, D::Error>
        where D: Deserializer<'de>,
        {
            let s = Vec::<crate::prelude::SvgPathElement>::deserialize(deserializer)?;
            Ok(s.into())
        }
    }    /// Wrapper over a Rust-allocated `Vec<StyleFilter>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilterVec as StyleFilterVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterVecCrossCrateImpl { pub _0: azul::AzStyleFilterVec }

    #[cfg(feature = "link_static")] pub use StyleFilterVecCrossCrateImpl as StyleFilterVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterVecCrossCrateImpl { type Target = AzStyleFilterVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<LogicalRect>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalRectVec as LogicalRectVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalRectVecCrossCrateImpl { pub _0: azul::AzLogicalRectVec }

    #[cfg(feature = "link_static")] pub use LogicalRectVecCrossCrateImpl as LogicalRectVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalRectVecCrossCrateImpl { type Target = AzLogicalRectVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalRectVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<NodeTypeIdInfoMap>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeIdInfoMapVec as NodeTypeIdInfoMapVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeIdInfoMapVecCrossCrateImpl { pub _0: azul::AzNodeTypeIdInfoMapVec }

    #[cfg(feature = "link_static")] pub use NodeTypeIdInfoMapVecCrossCrateImpl as NodeTypeIdInfoMapVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeIdInfoMapVecCrossCrateImpl { type Target = AzNodeTypeIdInfoMapVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeIdInfoMapVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeIdInfoMap>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdInfoMapVec as InputOutputTypeIdInfoMapVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdInfoMapVecCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdInfoMapVec }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdInfoMapVecCrossCrateImpl as InputOutputTypeIdInfoMapVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdInfoMapVecCrossCrateImpl { type Target = AzInputOutputTypeIdInfoMapVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdInfoMapVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<NodeIdNodeMap>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdNodeMapVec as NodeIdNodeMapVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdNodeMapVecCrossCrateImpl { pub _0: azul::AzNodeIdNodeMapVec }

    #[cfg(feature = "link_static")] pub use NodeIdNodeMapVecCrossCrateImpl as NodeIdNodeMapVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdNodeMapVecCrossCrateImpl { type Target = AzNodeIdNodeMapVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdNodeMapVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InputOutputTypeId>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdVec as InputOutputTypeIdVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdVecCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdVec }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdVecCrossCrateImpl as InputOutputTypeIdVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdVecCrossCrateImpl { type Target = AzInputOutputTypeIdVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<NodeTypeField>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeFieldVec as NodeTypeFieldVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeFieldVecCrossCrateImpl { pub _0: azul::AzNodeTypeFieldVec }

    #[cfg(feature = "link_static")] pub use NodeTypeFieldVecCrossCrateImpl as NodeTypeFieldVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeFieldVecCrossCrateImpl { type Target = AzNodeTypeFieldVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeFieldVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InputConnection>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputConnectionVec as InputConnectionVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputConnectionVecCrossCrateImpl { pub _0: azul::AzInputConnectionVec }

    #[cfg(feature = "link_static")] pub use InputConnectionVecCrossCrateImpl as InputConnectionVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputConnectionVecCrossCrateImpl { type Target = AzInputConnectionVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputConnectionVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<OutputNodeAndIndex>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputNodeAndIndexVec as OutputNodeAndIndexVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputNodeAndIndexVecCrossCrateImpl { pub _0: azul::AzOutputNodeAndIndexVec }

    #[cfg(feature = "link_static")] pub use OutputNodeAndIndexVecCrossCrateImpl as OutputNodeAndIndexVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputNodeAndIndexVecCrossCrateImpl { type Target = AzOutputNodeAndIndexVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputNodeAndIndexVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<OutputConnection>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputConnectionVec as OutputConnectionVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputConnectionVecCrossCrateImpl { pub _0: azul::AzOutputConnectionVec }

    #[cfg(feature = "link_static")] pub use OutputConnectionVecCrossCrateImpl as OutputConnectionVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputConnectionVecCrossCrateImpl { type Target = AzOutputConnectionVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputConnectionVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InputNodeAndIndex>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputNodeAndIndexVec as InputNodeAndIndexVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputNodeAndIndexVecCrossCrateImpl { pub _0: azul::AzInputNodeAndIndexVec }

    #[cfg(feature = "link_static")] pub use InputNodeAndIndexVecCrossCrateImpl as InputNodeAndIndexVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputNodeAndIndexVecCrossCrateImpl { type Target = AzInputNodeAndIndexVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputNodeAndIndexVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<Tab>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTabVec as TabVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabVecCrossCrateImpl { pub _0: azul::AzTabVec }

    #[cfg(feature = "link_static")] pub use TabVecCrossCrateImpl as TabVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabVecCrossCrateImpl { type Target = AzTabVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<AccessibilityState>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityStateVec as AccessibilityStateVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityStateVecCrossCrateImpl { pub _0: azul::AzAccessibilityStateVec }

    #[cfg(feature = "link_static")] pub use AccessibilityStateVecCrossCrateImpl as AccessibilityStateVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityStateVecCrossCrateImpl { type Target = AzAccessibilityStateVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityStateVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<MenuItem>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItemVec as MenuItemVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemVecCrossCrateImpl { pub _0: azul::AzMenuItemVec }

    #[cfg(feature = "link_static")] pub use MenuItemVecCrossCrateImpl as MenuItemVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemVecCrossCrateImpl { type Target = AzMenuItemVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<TessellatedSvgNode>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedSvgNodeVec as TessellatedSvgNodeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TessellatedSvgNodeVecCrossCrateImpl { pub _0: azul::AzTessellatedSvgNodeVec }

    #[cfg(feature = "link_static")] pub use TessellatedSvgNodeVecCrossCrateImpl as TessellatedSvgNodeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedSvgNodeVecCrossCrateImpl { type Target = AzTessellatedSvgNodeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedSvgNodeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl TessellatedSvgNodeVec {

        /// Returns the `TessellatedSvgNodeVec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self)  -> crate::svg::TessellatedSvgNodeVecRef { unsafe { crate::dll::AzTessellatedSvgNodeVec_asRefVec(self) } }
    }

    #[cfg(feature = "link_static")]
    impl TessellatedSvgNodeVecCrossCrateImpl {

        /// Returns the `TessellatedSvgNodeVec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self)  -> crate::svg::TessellatedSvgNodeVecRef {  unsafe { core::mem::transmute(unsafe { azul::AzTessellatedSvgNodeVec_asRefVec(&self._0) }) } }
    }

    /// Wrapper over a Rust-allocated `Vec<StyleFontFamily>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontFamilyVec as StyleFontFamilyVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontFamilyVecCrossCrateImpl { pub _0: azul::AzStyleFontFamilyVec }

    #[cfg(feature = "link_static")] pub use StyleFontFamilyVecCrossCrateImpl as StyleFontFamilyVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontFamilyVecCrossCrateImpl { type Target = AzStyleFontFamilyVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontFamilyVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<XmlNode>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlNodeVec as XmlNodeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlNodeVecCrossCrateImpl { pub _0: azul::AzXmlNodeVec }

    #[cfg(feature = "link_static")] pub use XmlNodeVecCrossCrateImpl as XmlNodeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlNodeVecCrossCrateImpl { type Target = AzXmlNodeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlNodeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<FmtArg>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFmtArgVec as FmtArgVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FmtArgVecCrossCrateImpl { pub _0: azul::AzFmtArgVec }

    #[cfg(feature = "link_static")] pub use FmtArgVecCrossCrateImpl as FmtArgVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FmtArgVecCrossCrateImpl { type Target = AzFmtArgVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FmtArgVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InlineLine>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineLineVec as InlineLineVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineLineVecCrossCrateImpl { pub _0: azul::AzInlineLineVec }

    #[cfg(feature = "link_static")] pub use InlineLineVecCrossCrateImpl as InlineLineVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineLineVecCrossCrateImpl { type Target = AzInlineLineVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineLineVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InlineWord>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineWordVec as InlineWordVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineWordVecCrossCrateImpl { pub _0: azul::AzInlineWordVec }

    #[cfg(feature = "link_static")] pub use InlineWordVecCrossCrateImpl as InlineWordVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineWordVecCrossCrateImpl { type Target = AzInlineWordVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineWordVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InlineGlyph>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineGlyphVec as InlineGlyphVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineGlyphVecCrossCrateImpl { pub _0: azul::AzInlineGlyphVec }

    #[cfg(feature = "link_static")] pub use InlineGlyphVecCrossCrateImpl as InlineGlyphVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineGlyphVecCrossCrateImpl { type Target = AzInlineGlyphVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineGlyphVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<InlineTextHit>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineTextHitVec as InlineTextHitVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextHitVecCrossCrateImpl { pub _0: azul::AzInlineTextHitVec }

    #[cfg(feature = "link_static")] pub use InlineTextHitVecCrossCrateImpl as InlineTextHitVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextHitVecCrossCrateImpl { type Target = AzInlineTextHitVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextHitVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<Monitor>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMonitorVec as MonitorVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MonitorVecCrossCrateImpl { pub _0: azul::AzMonitorVec }

    #[cfg(feature = "link_static")] pub use MonitorVecCrossCrateImpl as MonitorVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MonitorVecCrossCrateImpl { type Target = AzMonitorVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MonitorVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<VideoMode>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVideoModeVec as VideoModeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VideoModeVecCrossCrateImpl { pub _0: azul::AzVideoModeVec }

    #[cfg(feature = "link_static")] pub use VideoModeVecCrossCrateImpl as VideoModeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VideoModeVecCrossCrateImpl { type Target = AzVideoModeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VideoModeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<Dom>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDomVec as DomVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomVecCrossCrateImpl { pub _0: azul::AzDomVec }

    #[cfg(feature = "link_static")] pub use DomVecCrossCrateImpl as DomVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomVecCrossCrateImpl { type Target = AzDomVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<IdOrClass>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIdOrClassVec as IdOrClassVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IdOrClassVecCrossCrateImpl { pub _0: azul::AzIdOrClassVec }

    #[cfg(feature = "link_static")] pub use IdOrClassVecCrossCrateImpl as IdOrClassVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IdOrClassVecCrossCrateImpl { type Target = AzIdOrClassVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IdOrClassVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<NodeDataInlineCssProperty>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataInlineCssPropertyVec as NodeDataInlineCssPropertyVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataInlineCssPropertyVecCrossCrateImpl { pub _0: azul::AzNodeDataInlineCssPropertyVec }

    #[cfg(feature = "link_static")] pub use NodeDataInlineCssPropertyVecCrossCrateImpl as NodeDataInlineCssPropertyVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataInlineCssPropertyVecCrossCrateImpl { type Target = AzNodeDataInlineCssPropertyVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataInlineCssPropertyVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundContent>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundContentVec as StyleBackgroundContentVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundContentVecCrossCrateImpl { pub _0: azul::AzStyleBackgroundContentVec }

    #[cfg(feature = "link_static")] pub use StyleBackgroundContentVecCrossCrateImpl as StyleBackgroundContentVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundContentVecCrossCrateImpl { type Target = AzStyleBackgroundContentVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundContentVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundPosition>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundPositionVec as StyleBackgroundPositionVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundPositionVecCrossCrateImpl { pub _0: azul::AzStyleBackgroundPositionVec }

    #[cfg(feature = "link_static")] pub use StyleBackgroundPositionVecCrossCrateImpl as StyleBackgroundPositionVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundPositionVecCrossCrateImpl { type Target = AzStyleBackgroundPositionVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundPositionVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundRepeat>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundRepeatVec as StyleBackgroundRepeatVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundRepeatVecCrossCrateImpl { pub _0: azul::AzStyleBackgroundRepeatVec }

    #[cfg(feature = "link_static")] pub use StyleBackgroundRepeatVecCrossCrateImpl as StyleBackgroundRepeatVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundRepeatVecCrossCrateImpl { type Target = AzStyleBackgroundRepeatVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundRepeatVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<StyleBackgroundSize>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundSizeVec as StyleBackgroundSizeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundSizeVecCrossCrateImpl { pub _0: azul::AzStyleBackgroundSizeVec }

    #[cfg(feature = "link_static")] pub use StyleBackgroundSizeVecCrossCrateImpl as StyleBackgroundSizeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundSizeVecCrossCrateImpl { type Target = AzStyleBackgroundSizeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundSizeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<StyleTransform>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformVec as StyleTransformVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformVecCrossCrateImpl { pub _0: azul::AzStyleTransformVec }

    #[cfg(feature = "link_static")] pub use StyleTransformVecCrossCrateImpl as StyleTransformVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformVecCrossCrateImpl { type Target = AzStyleTransformVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<CssProperty>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertyVec as CssPropertyVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyVecCrossCrateImpl { pub _0: azul::AzCssPropertyVec }

    #[cfg(feature = "link_static")] pub use CssPropertyVecCrossCrateImpl as CssPropertyVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyVecCrossCrateImpl { type Target = AzCssPropertyVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<SvgMultiPolygon>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgMultiPolygonVec as SvgMultiPolygonVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgMultiPolygonVecCrossCrateImpl { pub _0: azul::AzSvgMultiPolygonVec }

    #[cfg(feature = "link_static")] pub use SvgMultiPolygonVecCrossCrateImpl as SvgMultiPolygonVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgMultiPolygonVecCrossCrateImpl { type Target = AzSvgMultiPolygonVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgMultiPolygonVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<SvgPath>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathVec as SvgPathVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathVecCrossCrateImpl { pub _0: azul::AzSvgPathVec }

    #[cfg(feature = "link_static")] pub use SvgPathVecCrossCrateImpl as SvgPathVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathVecCrossCrateImpl { type Target = AzSvgPathVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<VertexAttribute>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexAttributeVec as VertexAttributeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexAttributeVecCrossCrateImpl { pub _0: azul::AzVertexAttributeVec }

    #[cfg(feature = "link_static")] pub use VertexAttributeVecCrossCrateImpl as VertexAttributeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexAttributeVecCrossCrateImpl { type Target = AzVertexAttributeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexAttributeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `VertexAttribute`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathElementVec as SvgPathElementVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathElementVecCrossCrateImpl { pub _0: azul::AzSvgPathElementVec }

    #[cfg(feature = "link_static")] pub use SvgPathElementVecCrossCrateImpl as SvgPathElementVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathElementVecCrossCrateImpl { type Target = AzSvgPathElementVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathElementVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `SvgVertex`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgVertexVec as SvgVertexVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgVertexVecCrossCrateImpl { pub _0: azul::AzSvgVertexVec }

    #[cfg(feature = "link_static")] pub use SvgVertexVecCrossCrateImpl as SvgVertexVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgVertexVecCrossCrateImpl { type Target = AzSvgVertexVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgVertexVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<u32>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU32Vec as U32Vec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U32VecCrossCrateImpl { pub _0: azul::AzU32Vec }

    #[cfg(feature = "link_static")] pub use U32VecCrossCrateImpl as U32Vec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U32VecCrossCrateImpl { type Target = AzU32Vec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U32VecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `XWindowType`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXWindowTypeVec as XWindowTypeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XWindowTypeVecCrossCrateImpl { pub _0: azul::AzXWindowTypeVec }

    #[cfg(feature = "link_static")] pub use XWindowTypeVecCrossCrateImpl as XWindowTypeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XWindowTypeVecCrossCrateImpl { type Target = AzXWindowTypeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XWindowTypeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `VirtualKeyCode`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVirtualKeyCodeVec as VirtualKeyCodeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VirtualKeyCodeVecCrossCrateImpl { pub _0: azul::AzVirtualKeyCodeVec }

    #[cfg(feature = "link_static")] pub use VirtualKeyCodeVecCrossCrateImpl as VirtualKeyCodeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VirtualKeyCodeVecCrossCrateImpl { type Target = AzVirtualKeyCodeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VirtualKeyCodeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `CascadeInfo`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCascadeInfoVec as CascadeInfoVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CascadeInfoVecCrossCrateImpl { pub _0: azul::AzCascadeInfoVec }

    #[cfg(feature = "link_static")] pub use CascadeInfoVecCrossCrateImpl as CascadeInfoVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CascadeInfoVecCrossCrateImpl { type Target = AzCascadeInfoVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CascadeInfoVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `ScanCode`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScanCodeVec as ScanCodeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScanCodeVecCrossCrateImpl { pub _0: azul::AzScanCodeVec }

    #[cfg(feature = "link_static")] pub use ScanCodeVecCrossCrateImpl as ScanCodeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScanCodeVecCrossCrateImpl { type Target = AzScanCodeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScanCodeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `CssDeclaration`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssDeclarationVec as CssDeclarationVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssDeclarationVecCrossCrateImpl { pub _0: azul::AzCssDeclarationVec }

    #[cfg(feature = "link_static")] pub use CssDeclarationVecCrossCrateImpl as CssDeclarationVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssDeclarationVecCrossCrateImpl { type Target = AzCssDeclarationVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssDeclarationVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `CssPathSelector`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPathSelectorVec as CssPathSelectorVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathSelectorVecCrossCrateImpl { pub _0: azul::AzCssPathSelectorVec }

    #[cfg(feature = "link_static")] pub use CssPathSelectorVecCrossCrateImpl as CssPathSelectorVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathSelectorVecCrossCrateImpl { type Target = AzCssPathSelectorVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathSelectorVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Stylesheet`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylesheetVec as StylesheetVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylesheetVecCrossCrateImpl { pub _0: azul::AzStylesheetVec }

    #[cfg(feature = "link_static")] pub use StylesheetVecCrossCrateImpl as StylesheetVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylesheetVecCrossCrateImpl { type Target = AzStylesheetVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylesheetVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `CssRuleBlock`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssRuleBlockVec as CssRuleBlockVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssRuleBlockVecCrossCrateImpl { pub _0: azul::AzCssRuleBlockVec }

    #[cfg(feature = "link_static")] pub use CssRuleBlockVecCrossCrateImpl as CssRuleBlockVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssRuleBlockVecCrossCrateImpl { type Target = AzCssRuleBlockVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssRuleBlockVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<u16>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU16Vec as U16Vec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U16VecCrossCrateImpl { pub _0: azul::AzU16Vec }

    #[cfg(feature = "link_static")] pub use U16VecCrossCrateImpl as U16Vec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U16VecCrossCrateImpl { type Target = AzU16Vec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U16VecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<f32>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzF32Vec as F32Vec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct F32VecCrossCrateImpl { pub _0: azul::AzF32Vec }

    #[cfg(feature = "link_static")] pub use F32VecCrossCrateImpl as F32Vec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for F32VecCrossCrateImpl { type Target = AzF32Vec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for F32VecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `U8Vec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU8Vec as U8Vec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U8VecCrossCrateImpl { pub _0: azul::AzU8Vec }

    #[cfg(feature = "link_static")] pub use U8VecCrossCrateImpl as U8Vec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U8VecCrossCrateImpl { type Target = AzU8Vec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U8VecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    #[cfg(not(feature = "link_static"))]
    impl U8Vec {

        /// Creates a new, heap-allocated U8Vec by copying the memory into Rust (heap allocation)
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self { unsafe { crate::dll::AzU8Vec_copyFromBytes(ptr, start, len) } }
        /// Returns the `U8Vec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self)  -> crate::gl::U8VecRef { unsafe { crate::dll::AzU8Vec_asRefVec(self) } }
    }

    #[cfg(feature = "link_static")]
    impl U8VecCrossCrateImpl {

        /// Creates a new, heap-allocated U8Vec by copying the memory into Rust (heap allocation)
        pub fn copy_from_bytes(ptr: *const u8, start: usize, len: usize) -> Self { unsafe { core::mem::transmute(unsafe { azul::AzU8Vec_copyFromBytes(ptr, start, len) }) } }
        /// Returns the `U8Vec` as a non-owning slice, NOTE: The `U8Vec` that this slice was borrowed from MUST NOT be deleted before the `U8VecRef`
        pub fn as_ref_vec(&self)  -> crate::gl::U8VecRef {  unsafe { core::mem::transmute(unsafe { azul::AzU8Vec_asRefVec(&self._0) }) } }
    }

    /// Wrapper over a Rust-allocated `CallbackData`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackDataVec as CallbackDataVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackDataVecCrossCrateImpl { pub _0: azul::AzCallbackDataVec }

    #[cfg(feature = "link_static")] pub use CallbackDataVecCrossCrateImpl as CallbackDataVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackDataVecCrossCrateImpl { type Target = AzCallbackDataVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackDataVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<DebugMessage>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDebugMessageVec as DebugMessageVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DebugMessageVecCrossCrateImpl { pub _0: azul::AzDebugMessageVec }

    #[cfg(feature = "link_static")] pub use DebugMessageVecCrossCrateImpl as DebugMessageVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DebugMessageVecCrossCrateImpl { type Target = AzDebugMessageVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DebugMessageVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `U32Vec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLuintVec as GLuintVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLuintVecCrossCrateImpl { pub _0: azul::AzGLuintVec }

    #[cfg(feature = "link_static")] pub use GLuintVecCrossCrateImpl as GLuintVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLuintVecCrossCrateImpl { type Target = AzGLuintVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLuintVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `GLintVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLintVec as GLintVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLintVecCrossCrateImpl { pub _0: azul::AzGLintVec }

    #[cfg(feature = "link_static")] pub use GLintVecCrossCrateImpl as GLintVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLintVecCrossCrateImpl { type Target = AzGLintVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLintVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `StringVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringVec as StringVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringVecCrossCrateImpl { pub _0: azul::AzStringVec }

    #[cfg(feature = "link_static")] pub use StringVecCrossCrateImpl as StringVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringVecCrossCrateImpl { type Target = AzStringVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `StringPairVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringPairVec as StringPairVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringPairVecCrossCrateImpl { pub _0: azul::AzStringPairVec }

    #[cfg(feature = "link_static")] pub use StringPairVecCrossCrateImpl as StringPairVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringPairVecCrossCrateImpl { type Target = AzStringPairVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringPairVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `NormalizedLinearColorStopVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedLinearColorStopVec as NormalizedLinearColorStopVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedLinearColorStopVecCrossCrateImpl { pub _0: azul::AzNormalizedLinearColorStopVec }

    #[cfg(feature = "link_static")] pub use NormalizedLinearColorStopVecCrossCrateImpl as NormalizedLinearColorStopVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedLinearColorStopVecCrossCrateImpl { type Target = AzNormalizedLinearColorStopVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedLinearColorStopVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `NormalizedRadialColorStopVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedRadialColorStopVec as NormalizedRadialColorStopVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedRadialColorStopVecCrossCrateImpl { pub _0: azul::AzNormalizedRadialColorStopVec }

    #[cfg(feature = "link_static")] pub use NormalizedRadialColorStopVecCrossCrateImpl as NormalizedRadialColorStopVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedRadialColorStopVecCrossCrateImpl { type Target = AzNormalizedRadialColorStopVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedRadialColorStopVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `NodeIdVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdVec as NodeIdVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdVecCrossCrateImpl { pub _0: azul::AzNodeIdVec }

    #[cfg(feature = "link_static")] pub use NodeIdVecCrossCrateImpl as NodeIdVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdVecCrossCrateImpl { type Target = AzNodeIdVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `Vec<NodeHierarchyItem>`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeHierarchyItemVec as NodeHierarchyItemVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeHierarchyItemVecCrossCrateImpl { pub _0: azul::AzNodeHierarchyItemVec }

    #[cfg(feature = "link_static")] pub use NodeHierarchyItemVecCrossCrateImpl as NodeHierarchyItemVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeHierarchyItemVecCrossCrateImpl { type Target = AzNodeHierarchyItemVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeHierarchyItemVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `StyledNodeVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledNodeVec as StyledNodeVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledNodeVecCrossCrateImpl { pub _0: azul::AzStyledNodeVec }

    #[cfg(feature = "link_static")] pub use StyledNodeVecCrossCrateImpl as StyledNodeVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledNodeVecCrossCrateImpl { type Target = AzStyledNodeVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledNodeVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `TagIdToNodeIdMappingVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTagIdToNodeIdMappingVec as TagIdToNodeIdMappingVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TagIdToNodeIdMappingVecCrossCrateImpl { pub _0: azul::AzTagIdToNodeIdMappingVec }

    #[cfg(feature = "link_static")] pub use TagIdToNodeIdMappingVecCrossCrateImpl as TagIdToNodeIdMappingVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TagIdToNodeIdMappingVecCrossCrateImpl { type Target = AzTagIdToNodeIdMappingVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TagIdToNodeIdMappingVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `ParentWithNodeDepthVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzParentWithNodeDepthVec as ParentWithNodeDepthVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ParentWithNodeDepthVecCrossCrateImpl { pub _0: azul::AzParentWithNodeDepthVec }

    #[cfg(feature = "link_static")] pub use ParentWithNodeDepthVecCrossCrateImpl as ParentWithNodeDepthVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ParentWithNodeDepthVecCrossCrateImpl { type Target = AzParentWithNodeDepthVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ParentWithNodeDepthVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Wrapper over a Rust-allocated `NodeDataVec`
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataVec as NodeDataVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataVecCrossCrateImpl { pub _0: azul::AzNodeDataVec }

    #[cfg(feature = "link_static")] pub use NodeDataVecCrossCrateImpl as NodeDataVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataVecCrossCrateImpl { type Target = AzNodeDataVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontFamilyVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontFamilyVecDestructor as StyleFontFamilyVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontFamilyVecDestructorCrossCrateImpl { pub _0: azul::AzStyleFontFamilyVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleFontFamilyVecDestructorCrossCrateImpl as StyleFontFamilyVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontFamilyVecDestructorCrossCrateImpl { type Target = AzStyleFontFamilyVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontFamilyVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFontFamilyVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFontFamilyVecDestructorType as StyleFontFamilyVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFontFamilyVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleFontFamilyVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleFontFamilyVecDestructorTypeCrossCrateImpl as StyleFontFamilyVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFontFamilyVecDestructorTypeCrossCrateImpl { type Target = AzStyleFontFamilyVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFontFamilyVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFilterVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilterVecDestructor as StyleFilterVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterVecDestructorCrossCrateImpl { pub _0: azul::AzStyleFilterVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleFilterVecDestructorCrossCrateImpl as StyleFilterVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterVecDestructorCrossCrateImpl { type Target = AzStyleFilterVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleFilterVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleFilterVecDestructorType as StyleFilterVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleFilterVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleFilterVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleFilterVecDestructorTypeCrossCrateImpl as StyleFilterVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleFilterVecDestructorTypeCrossCrateImpl { type Target = AzStyleFilterVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleFilterVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LogicalRectVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalRectVecDestructor as LogicalRectVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalRectVecDestructorCrossCrateImpl { pub _0: azul::AzLogicalRectVecDestructor }

    #[cfg(feature = "link_static")] pub use LogicalRectVecDestructorCrossCrateImpl as LogicalRectVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalRectVecDestructorCrossCrateImpl { type Target = AzLogicalRectVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalRectVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `LogicalRectVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzLogicalRectVecDestructorType as LogicalRectVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct LogicalRectVecDestructorTypeCrossCrateImpl { pub _0: azul::AzLogicalRectVecDestructorType }

    #[cfg(feature = "link_static")] pub use LogicalRectVecDestructorTypeCrossCrateImpl as LogicalRectVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for LogicalRectVecDestructorTypeCrossCrateImpl { type Target = AzLogicalRectVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for LogicalRectVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeIdInfoMapVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeIdInfoMapVecDestructor as NodeTypeIdInfoMapVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeIdInfoMapVecDestructorCrossCrateImpl { pub _0: azul::AzNodeTypeIdInfoMapVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeTypeIdInfoMapVecDestructorCrossCrateImpl as NodeTypeIdInfoMapVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeIdInfoMapVecDestructorCrossCrateImpl { type Target = AzNodeTypeIdInfoMapVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeIdInfoMapVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeIdInfoMapVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeIdInfoMapVecDestructorType as NodeTypeIdInfoMapVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeIdInfoMapVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeTypeIdInfoMapVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeTypeIdInfoMapVecDestructorTypeCrossCrateImpl as NodeTypeIdInfoMapVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeIdInfoMapVecDestructorTypeCrossCrateImpl { type Target = AzNodeTypeIdInfoMapVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeIdInfoMapVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeIdInfoMapVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdInfoMapVecDestructor as InputOutputTypeIdInfoMapVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdInfoMapVecDestructorCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdInfoMapVecDestructor }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdInfoMapVecDestructorCrossCrateImpl as InputOutputTypeIdInfoMapVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdInfoMapVecDestructorCrossCrateImpl { type Target = AzInputOutputTypeIdInfoMapVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdInfoMapVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeIdInfoMapVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdInfoMapVecDestructorType as InputOutputTypeIdInfoMapVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdInfoMapVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdInfoMapVecDestructorType }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdInfoMapVecDestructorTypeCrossCrateImpl as InputOutputTypeIdInfoMapVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdInfoMapVecDestructorTypeCrossCrateImpl { type Target = AzInputOutputTypeIdInfoMapVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdInfoMapVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeIdNodeMapVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdNodeMapVecDestructor as NodeIdNodeMapVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdNodeMapVecDestructorCrossCrateImpl { pub _0: azul::AzNodeIdNodeMapVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeIdNodeMapVecDestructorCrossCrateImpl as NodeIdNodeMapVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdNodeMapVecDestructorCrossCrateImpl { type Target = AzNodeIdNodeMapVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdNodeMapVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeIdNodeMapVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdNodeMapVecDestructorType as NodeIdNodeMapVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdNodeMapVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeIdNodeMapVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeIdNodeMapVecDestructorTypeCrossCrateImpl as NodeIdNodeMapVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdNodeMapVecDestructorTypeCrossCrateImpl { type Target = AzNodeIdNodeMapVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdNodeMapVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeIdVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdVecDestructor as InputOutputTypeIdVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdVecDestructorCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdVecDestructor }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdVecDestructorCrossCrateImpl as InputOutputTypeIdVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdVecDestructorCrossCrateImpl { type Target = AzInputOutputTypeIdVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputOutputTypeIdVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputOutputTypeIdVecDestructorType as InputOutputTypeIdVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputOutputTypeIdVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInputOutputTypeIdVecDestructorType }

    #[cfg(feature = "link_static")] pub use InputOutputTypeIdVecDestructorTypeCrossCrateImpl as InputOutputTypeIdVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputOutputTypeIdVecDestructorTypeCrossCrateImpl { type Target = AzInputOutputTypeIdVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputOutputTypeIdVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeFieldVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeFieldVecDestructor as NodeTypeFieldVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeFieldVecDestructorCrossCrateImpl { pub _0: azul::AzNodeTypeFieldVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeTypeFieldVecDestructorCrossCrateImpl as NodeTypeFieldVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeFieldVecDestructorCrossCrateImpl { type Target = AzNodeTypeFieldVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeFieldVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeTypeFieldVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeTypeFieldVecDestructorType as NodeTypeFieldVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeTypeFieldVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeTypeFieldVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeTypeFieldVecDestructorTypeCrossCrateImpl as NodeTypeFieldVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeTypeFieldVecDestructorTypeCrossCrateImpl { type Target = AzNodeTypeFieldVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeTypeFieldVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputConnectionVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputConnectionVecDestructor as InputConnectionVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputConnectionVecDestructorCrossCrateImpl { pub _0: azul::AzInputConnectionVecDestructor }

    #[cfg(feature = "link_static")] pub use InputConnectionVecDestructorCrossCrateImpl as InputConnectionVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputConnectionVecDestructorCrossCrateImpl { type Target = AzInputConnectionVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputConnectionVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputConnectionVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputConnectionVecDestructorType as InputConnectionVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputConnectionVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInputConnectionVecDestructorType }

    #[cfg(feature = "link_static")] pub use InputConnectionVecDestructorTypeCrossCrateImpl as InputConnectionVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputConnectionVecDestructorTypeCrossCrateImpl { type Target = AzInputConnectionVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputConnectionVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputNodeAndIndexVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputNodeAndIndexVecDestructor as OutputNodeAndIndexVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputNodeAndIndexVecDestructorCrossCrateImpl { pub _0: azul::AzOutputNodeAndIndexVecDestructor }

    #[cfg(feature = "link_static")] pub use OutputNodeAndIndexVecDestructorCrossCrateImpl as OutputNodeAndIndexVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputNodeAndIndexVecDestructorCrossCrateImpl { type Target = AzOutputNodeAndIndexVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputNodeAndIndexVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputNodeAndIndexVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputNodeAndIndexVecDestructorType as OutputNodeAndIndexVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputNodeAndIndexVecDestructorTypeCrossCrateImpl { pub _0: azul::AzOutputNodeAndIndexVecDestructorType }

    #[cfg(feature = "link_static")] pub use OutputNodeAndIndexVecDestructorTypeCrossCrateImpl as OutputNodeAndIndexVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputNodeAndIndexVecDestructorTypeCrossCrateImpl { type Target = AzOutputNodeAndIndexVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputNodeAndIndexVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputConnectionVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputConnectionVecDestructor as OutputConnectionVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputConnectionVecDestructorCrossCrateImpl { pub _0: azul::AzOutputConnectionVecDestructor }

    #[cfg(feature = "link_static")] pub use OutputConnectionVecDestructorCrossCrateImpl as OutputConnectionVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputConnectionVecDestructorCrossCrateImpl { type Target = AzOutputConnectionVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputConnectionVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OutputConnectionVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOutputConnectionVecDestructorType as OutputConnectionVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OutputConnectionVecDestructorTypeCrossCrateImpl { pub _0: azul::AzOutputConnectionVecDestructorType }

    #[cfg(feature = "link_static")] pub use OutputConnectionVecDestructorTypeCrossCrateImpl as OutputConnectionVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OutputConnectionVecDestructorTypeCrossCrateImpl { type Target = AzOutputConnectionVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OutputConnectionVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputNodeAndIndexVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputNodeAndIndexVecDestructor as InputNodeAndIndexVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputNodeAndIndexVecDestructorCrossCrateImpl { pub _0: azul::AzInputNodeAndIndexVecDestructor }

    #[cfg(feature = "link_static")] pub use InputNodeAndIndexVecDestructorCrossCrateImpl as InputNodeAndIndexVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputNodeAndIndexVecDestructorCrossCrateImpl { type Target = AzInputNodeAndIndexVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputNodeAndIndexVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InputNodeAndIndexVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInputNodeAndIndexVecDestructorType as InputNodeAndIndexVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InputNodeAndIndexVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInputNodeAndIndexVecDestructorType }

    #[cfg(feature = "link_static")] pub use InputNodeAndIndexVecDestructorTypeCrossCrateImpl as InputNodeAndIndexVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InputNodeAndIndexVecDestructorTypeCrossCrateImpl { type Target = AzInputNodeAndIndexVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InputNodeAndIndexVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TabVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTabVecDestructor as TabVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabVecDestructorCrossCrateImpl { pub _0: azul::AzTabVecDestructor }

    #[cfg(feature = "link_static")] pub use TabVecDestructorCrossCrateImpl as TabVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabVecDestructorCrossCrateImpl { type Target = AzTabVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TabVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTabVecDestructorType as TabVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TabVecDestructorTypeCrossCrateImpl { pub _0: azul::AzTabVecDestructorType }

    #[cfg(feature = "link_static")] pub use TabVecDestructorTypeCrossCrateImpl as TabVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TabVecDestructorTypeCrossCrateImpl { type Target = AzTabVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TabVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AccessibilityStateVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityStateVecDestructor as AccessibilityStateVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityStateVecDestructorCrossCrateImpl { pub _0: azul::AzAccessibilityStateVecDestructor }

    #[cfg(feature = "link_static")] pub use AccessibilityStateVecDestructorCrossCrateImpl as AccessibilityStateVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityStateVecDestructorCrossCrateImpl { type Target = AzAccessibilityStateVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityStateVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `AccessibilityStateVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzAccessibilityStateVecDestructorType as AccessibilityStateVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct AccessibilityStateVecDestructorTypeCrossCrateImpl { pub _0: azul::AzAccessibilityStateVecDestructorType }

    #[cfg(feature = "link_static")] pub use AccessibilityStateVecDestructorTypeCrossCrateImpl as AccessibilityStateVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for AccessibilityStateVecDestructorTypeCrossCrateImpl { type Target = AzAccessibilityStateVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for AccessibilityStateVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MenuItemVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItemVecDestructor as MenuItemVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemVecDestructorCrossCrateImpl { pub _0: azul::AzMenuItemVecDestructor }

    #[cfg(feature = "link_static")] pub use MenuItemVecDestructorCrossCrateImpl as MenuItemVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemVecDestructorCrossCrateImpl { type Target = AzMenuItemVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MenuItemVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMenuItemVecDestructorType as MenuItemVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MenuItemVecDestructorTypeCrossCrateImpl { pub _0: azul::AzMenuItemVecDestructorType }

    #[cfg(feature = "link_static")] pub use MenuItemVecDestructorTypeCrossCrateImpl as MenuItemVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MenuItemVecDestructorTypeCrossCrateImpl { type Target = AzMenuItemVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MenuItemVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TessellatedSvgNodeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedSvgNodeVecDestructor as TessellatedSvgNodeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TessellatedSvgNodeVecDestructorCrossCrateImpl { pub _0: azul::AzTessellatedSvgNodeVecDestructor }

    #[cfg(feature = "link_static")] pub use TessellatedSvgNodeVecDestructorCrossCrateImpl as TessellatedSvgNodeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedSvgNodeVecDestructorCrossCrateImpl { type Target = AzTessellatedSvgNodeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedSvgNodeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TessellatedSvgNodeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTessellatedSvgNodeVecDestructorType as TessellatedSvgNodeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TessellatedSvgNodeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzTessellatedSvgNodeVecDestructorType }

    #[cfg(feature = "link_static")] pub use TessellatedSvgNodeVecDestructorTypeCrossCrateImpl as TessellatedSvgNodeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TessellatedSvgNodeVecDestructorTypeCrossCrateImpl { type Target = AzTessellatedSvgNodeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TessellatedSvgNodeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlNodeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlNodeVecDestructor as XmlNodeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlNodeVecDestructorCrossCrateImpl { pub _0: azul::AzXmlNodeVecDestructor }

    #[cfg(feature = "link_static")] pub use XmlNodeVecDestructorCrossCrateImpl as XmlNodeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlNodeVecDestructorCrossCrateImpl { type Target = AzXmlNodeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlNodeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlNodeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlNodeVecDestructorType as XmlNodeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlNodeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzXmlNodeVecDestructorType }

    #[cfg(feature = "link_static")] pub use XmlNodeVecDestructorTypeCrossCrateImpl as XmlNodeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlNodeVecDestructorTypeCrossCrateImpl { type Target = AzXmlNodeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlNodeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FmtArgVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFmtArgVecDestructor as FmtArgVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FmtArgVecDestructorCrossCrateImpl { pub _0: azul::AzFmtArgVecDestructor }

    #[cfg(feature = "link_static")] pub use FmtArgVecDestructorCrossCrateImpl as FmtArgVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FmtArgVecDestructorCrossCrateImpl { type Target = AzFmtArgVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FmtArgVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `FmtArgVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzFmtArgVecDestructorType as FmtArgVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct FmtArgVecDestructorTypeCrossCrateImpl { pub _0: azul::AzFmtArgVecDestructorType }

    #[cfg(feature = "link_static")] pub use FmtArgVecDestructorTypeCrossCrateImpl as FmtArgVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for FmtArgVecDestructorTypeCrossCrateImpl { type Target = AzFmtArgVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for FmtArgVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineLineVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineLineVecDestructor as InlineLineVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineLineVecDestructorCrossCrateImpl { pub _0: azul::AzInlineLineVecDestructor }

    #[cfg(feature = "link_static")] pub use InlineLineVecDestructorCrossCrateImpl as InlineLineVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineLineVecDestructorCrossCrateImpl { type Target = AzInlineLineVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineLineVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineLineVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineLineVecDestructorType as InlineLineVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineLineVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInlineLineVecDestructorType }

    #[cfg(feature = "link_static")] pub use InlineLineVecDestructorTypeCrossCrateImpl as InlineLineVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineLineVecDestructorTypeCrossCrateImpl { type Target = AzInlineLineVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineLineVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineWordVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineWordVecDestructor as InlineWordVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineWordVecDestructorCrossCrateImpl { pub _0: azul::AzInlineWordVecDestructor }

    #[cfg(feature = "link_static")] pub use InlineWordVecDestructorCrossCrateImpl as InlineWordVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineWordVecDestructorCrossCrateImpl { type Target = AzInlineWordVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineWordVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineWordVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineWordVecDestructorType as InlineWordVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineWordVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInlineWordVecDestructorType }

    #[cfg(feature = "link_static")] pub use InlineWordVecDestructorTypeCrossCrateImpl as InlineWordVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineWordVecDestructorTypeCrossCrateImpl { type Target = AzInlineWordVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineWordVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineGlyphVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineGlyphVecDestructor as InlineGlyphVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineGlyphVecDestructorCrossCrateImpl { pub _0: azul::AzInlineGlyphVecDestructor }

    #[cfg(feature = "link_static")] pub use InlineGlyphVecDestructorCrossCrateImpl as InlineGlyphVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineGlyphVecDestructorCrossCrateImpl { type Target = AzInlineGlyphVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineGlyphVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineGlyphVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineGlyphVecDestructorType as InlineGlyphVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineGlyphVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInlineGlyphVecDestructorType }

    #[cfg(feature = "link_static")] pub use InlineGlyphVecDestructorTypeCrossCrateImpl as InlineGlyphVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineGlyphVecDestructorTypeCrossCrateImpl { type Target = AzInlineGlyphVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineGlyphVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineTextHitVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineTextHitVecDestructor as InlineTextHitVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextHitVecDestructorCrossCrateImpl { pub _0: azul::AzInlineTextHitVecDestructor }

    #[cfg(feature = "link_static")] pub use InlineTextHitVecDestructorCrossCrateImpl as InlineTextHitVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextHitVecDestructorCrossCrateImpl { type Target = AzInlineTextHitVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextHitVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InlineTextHitVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInlineTextHitVecDestructorType as InlineTextHitVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InlineTextHitVecDestructorTypeCrossCrateImpl { pub _0: azul::AzInlineTextHitVecDestructorType }

    #[cfg(feature = "link_static")] pub use InlineTextHitVecDestructorTypeCrossCrateImpl as InlineTextHitVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InlineTextHitVecDestructorTypeCrossCrateImpl { type Target = AzInlineTextHitVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InlineTextHitVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MonitorVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMonitorVecDestructor as MonitorVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MonitorVecDestructorCrossCrateImpl { pub _0: azul::AzMonitorVecDestructor }

    #[cfg(feature = "link_static")] pub use MonitorVecDestructorCrossCrateImpl as MonitorVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MonitorVecDestructorCrossCrateImpl { type Target = AzMonitorVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MonitorVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `MonitorVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzMonitorVecDestructorType as MonitorVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct MonitorVecDestructorTypeCrossCrateImpl { pub _0: azul::AzMonitorVecDestructorType }

    #[cfg(feature = "link_static")] pub use MonitorVecDestructorTypeCrossCrateImpl as MonitorVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for MonitorVecDestructorTypeCrossCrateImpl { type Target = AzMonitorVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for MonitorVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VideoModeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVideoModeVecDestructor as VideoModeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VideoModeVecDestructorCrossCrateImpl { pub _0: azul::AzVideoModeVecDestructor }

    #[cfg(feature = "link_static")] pub use VideoModeVecDestructorCrossCrateImpl as VideoModeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VideoModeVecDestructorCrossCrateImpl { type Target = AzVideoModeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VideoModeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VideoModeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVideoModeVecDestructorType as VideoModeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VideoModeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzVideoModeVecDestructorType }

    #[cfg(feature = "link_static")] pub use VideoModeVecDestructorTypeCrossCrateImpl as VideoModeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VideoModeVecDestructorTypeCrossCrateImpl { type Target = AzVideoModeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VideoModeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DomVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDomVecDestructor as DomVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomVecDestructorCrossCrateImpl { pub _0: azul::AzDomVecDestructor }

    #[cfg(feature = "link_static")] pub use DomVecDestructorCrossCrateImpl as DomVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomVecDestructorCrossCrateImpl { type Target = AzDomVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DomVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDomVecDestructorType as DomVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DomVecDestructorTypeCrossCrateImpl { pub _0: azul::AzDomVecDestructorType }

    #[cfg(feature = "link_static")] pub use DomVecDestructorTypeCrossCrateImpl as DomVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DomVecDestructorTypeCrossCrateImpl { type Target = AzDomVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DomVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `IdOrClassVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIdOrClassVecDestructor as IdOrClassVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IdOrClassVecDestructorCrossCrateImpl { pub _0: azul::AzIdOrClassVecDestructor }

    #[cfg(feature = "link_static")] pub use IdOrClassVecDestructorCrossCrateImpl as IdOrClassVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IdOrClassVecDestructorCrossCrateImpl { type Target = AzIdOrClassVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IdOrClassVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `IdOrClassVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzIdOrClassVecDestructorType as IdOrClassVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct IdOrClassVecDestructorTypeCrossCrateImpl { pub _0: azul::AzIdOrClassVecDestructorType }

    #[cfg(feature = "link_static")] pub use IdOrClassVecDestructorTypeCrossCrateImpl as IdOrClassVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for IdOrClassVecDestructorTypeCrossCrateImpl { type Target = AzIdOrClassVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for IdOrClassVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDataInlineCssPropertyVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataInlineCssPropertyVecDestructor as NodeDataInlineCssPropertyVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataInlineCssPropertyVecDestructorCrossCrateImpl { pub _0: azul::AzNodeDataInlineCssPropertyVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeDataInlineCssPropertyVecDestructorCrossCrateImpl as NodeDataInlineCssPropertyVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataInlineCssPropertyVecDestructorCrossCrateImpl { type Target = AzNodeDataInlineCssPropertyVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataInlineCssPropertyVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDataInlineCssPropertyVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataInlineCssPropertyVecDestructorType as NodeDataInlineCssPropertyVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataInlineCssPropertyVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeDataInlineCssPropertyVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeDataInlineCssPropertyVecDestructorTypeCrossCrateImpl as NodeDataInlineCssPropertyVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataInlineCssPropertyVecDestructorTypeCrossCrateImpl { type Target = AzNodeDataInlineCssPropertyVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataInlineCssPropertyVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundContentVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundContentVecDestructor as StyleBackgroundContentVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundContentVecDestructorCrossCrateImpl { pub _0: azul::AzStyleBackgroundContentVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleBackgroundContentVecDestructorCrossCrateImpl as StyleBackgroundContentVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundContentVecDestructorCrossCrateImpl { type Target = AzStyleBackgroundContentVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundContentVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundContentVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundContentVecDestructorType as StyleBackgroundContentVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundContentVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleBackgroundContentVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleBackgroundContentVecDestructorTypeCrossCrateImpl as StyleBackgroundContentVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundContentVecDestructorTypeCrossCrateImpl { type Target = AzStyleBackgroundContentVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundContentVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundPositionVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundPositionVecDestructor as StyleBackgroundPositionVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundPositionVecDestructorCrossCrateImpl { pub _0: azul::AzStyleBackgroundPositionVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleBackgroundPositionVecDestructorCrossCrateImpl as StyleBackgroundPositionVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundPositionVecDestructorCrossCrateImpl { type Target = AzStyleBackgroundPositionVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundPositionVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundPositionVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundPositionVecDestructorType as StyleBackgroundPositionVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundPositionVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleBackgroundPositionVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleBackgroundPositionVecDestructorTypeCrossCrateImpl as StyleBackgroundPositionVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundPositionVecDestructorTypeCrossCrateImpl { type Target = AzStyleBackgroundPositionVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundPositionVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundRepeatVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundRepeatVecDestructor as StyleBackgroundRepeatVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundRepeatVecDestructorCrossCrateImpl { pub _0: azul::AzStyleBackgroundRepeatVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleBackgroundRepeatVecDestructorCrossCrateImpl as StyleBackgroundRepeatVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundRepeatVecDestructorCrossCrateImpl { type Target = AzStyleBackgroundRepeatVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundRepeatVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundRepeatVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundRepeatVecDestructorType as StyleBackgroundRepeatVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundRepeatVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleBackgroundRepeatVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleBackgroundRepeatVecDestructorTypeCrossCrateImpl as StyleBackgroundRepeatVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundRepeatVecDestructorTypeCrossCrateImpl { type Target = AzStyleBackgroundRepeatVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundRepeatVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundSizeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundSizeVecDestructor as StyleBackgroundSizeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundSizeVecDestructorCrossCrateImpl { pub _0: azul::AzStyleBackgroundSizeVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleBackgroundSizeVecDestructorCrossCrateImpl as StyleBackgroundSizeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundSizeVecDestructorCrossCrateImpl { type Target = AzStyleBackgroundSizeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundSizeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleBackgroundSizeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleBackgroundSizeVecDestructorType as StyleBackgroundSizeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleBackgroundSizeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleBackgroundSizeVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleBackgroundSizeVecDestructorTypeCrossCrateImpl as StyleBackgroundSizeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleBackgroundSizeVecDestructorTypeCrossCrateImpl { type Target = AzStyleBackgroundSizeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleBackgroundSizeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformVecDestructor as StyleTransformVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformVecDestructorCrossCrateImpl { pub _0: azul::AzStyleTransformVecDestructor }

    #[cfg(feature = "link_static")] pub use StyleTransformVecDestructorCrossCrateImpl as StyleTransformVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformVecDestructorCrossCrateImpl { type Target = AzStyleTransformVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyleTransformVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyleTransformVecDestructorType as StyleTransformVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyleTransformVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyleTransformVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyleTransformVecDestructorTypeCrossCrateImpl as StyleTransformVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyleTransformVecDestructorTypeCrossCrateImpl { type Target = AzStyleTransformVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyleTransformVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPropertyVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertyVecDestructor as CssPropertyVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyVecDestructorCrossCrateImpl { pub _0: azul::AzCssPropertyVecDestructor }

    #[cfg(feature = "link_static")] pub use CssPropertyVecDestructorCrossCrateImpl as CssPropertyVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyVecDestructorCrossCrateImpl { type Target = AzCssPropertyVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPropertyVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPropertyVecDestructorType as CssPropertyVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPropertyVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCssPropertyVecDestructorType }

    #[cfg(feature = "link_static")] pub use CssPropertyVecDestructorTypeCrossCrateImpl as CssPropertyVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPropertyVecDestructorTypeCrossCrateImpl { type Target = AzCssPropertyVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPropertyVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgMultiPolygonVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgMultiPolygonVecDestructor as SvgMultiPolygonVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgMultiPolygonVecDestructorCrossCrateImpl { pub _0: azul::AzSvgMultiPolygonVecDestructor }

    #[cfg(feature = "link_static")] pub use SvgMultiPolygonVecDestructorCrossCrateImpl as SvgMultiPolygonVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgMultiPolygonVecDestructorCrossCrateImpl { type Target = AzSvgMultiPolygonVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgMultiPolygonVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgMultiPolygonVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgMultiPolygonVecDestructorType as SvgMultiPolygonVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgMultiPolygonVecDestructorTypeCrossCrateImpl { pub _0: azul::AzSvgMultiPolygonVecDestructorType }

    #[cfg(feature = "link_static")] pub use SvgMultiPolygonVecDestructorTypeCrossCrateImpl as SvgMultiPolygonVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgMultiPolygonVecDestructorTypeCrossCrateImpl { type Target = AzSvgMultiPolygonVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgMultiPolygonVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgPathVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathVecDestructor as SvgPathVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathVecDestructorCrossCrateImpl { pub _0: azul::AzSvgPathVecDestructor }

    #[cfg(feature = "link_static")] pub use SvgPathVecDestructorCrossCrateImpl as SvgPathVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathVecDestructorCrossCrateImpl { type Target = AzSvgPathVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgPathVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathVecDestructorType as SvgPathVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathVecDestructorTypeCrossCrateImpl { pub _0: azul::AzSvgPathVecDestructorType }

    #[cfg(feature = "link_static")] pub use SvgPathVecDestructorTypeCrossCrateImpl as SvgPathVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathVecDestructorTypeCrossCrateImpl { type Target = AzSvgPathVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexAttributeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexAttributeVecDestructor as VertexAttributeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexAttributeVecDestructorCrossCrateImpl { pub _0: azul::AzVertexAttributeVecDestructor }

    #[cfg(feature = "link_static")] pub use VertexAttributeVecDestructorCrossCrateImpl as VertexAttributeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexAttributeVecDestructorCrossCrateImpl { type Target = AzVertexAttributeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexAttributeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VertexAttributeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVertexAttributeVecDestructorType as VertexAttributeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VertexAttributeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzVertexAttributeVecDestructorType }

    #[cfg(feature = "link_static")] pub use VertexAttributeVecDestructorTypeCrossCrateImpl as VertexAttributeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VertexAttributeVecDestructorTypeCrossCrateImpl { type Target = AzVertexAttributeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VertexAttributeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgPathElementVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathElementVecDestructor as SvgPathElementVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathElementVecDestructorCrossCrateImpl { pub _0: azul::AzSvgPathElementVecDestructor }

    #[cfg(feature = "link_static")] pub use SvgPathElementVecDestructorCrossCrateImpl as SvgPathElementVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathElementVecDestructorCrossCrateImpl { type Target = AzSvgPathElementVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathElementVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgPathElementVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgPathElementVecDestructorType as SvgPathElementVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgPathElementVecDestructorTypeCrossCrateImpl { pub _0: azul::AzSvgPathElementVecDestructorType }

    #[cfg(feature = "link_static")] pub use SvgPathElementVecDestructorTypeCrossCrateImpl as SvgPathElementVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgPathElementVecDestructorTypeCrossCrateImpl { type Target = AzSvgPathElementVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgPathElementVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgVertexVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgVertexVecDestructor as SvgVertexVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgVertexVecDestructorCrossCrateImpl { pub _0: azul::AzSvgVertexVecDestructor }

    #[cfg(feature = "link_static")] pub use SvgVertexVecDestructorCrossCrateImpl as SvgVertexVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgVertexVecDestructorCrossCrateImpl { type Target = AzSvgVertexVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgVertexVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgVertexVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgVertexVecDestructorType as SvgVertexVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgVertexVecDestructorTypeCrossCrateImpl { pub _0: azul::AzSvgVertexVecDestructorType }

    #[cfg(feature = "link_static")] pub use SvgVertexVecDestructorTypeCrossCrateImpl as SvgVertexVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgVertexVecDestructorTypeCrossCrateImpl { type Target = AzSvgVertexVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgVertexVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U32VecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU32VecDestructor as U32VecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U32VecDestructorCrossCrateImpl { pub _0: azul::AzU32VecDestructor }

    #[cfg(feature = "link_static")] pub use U32VecDestructorCrossCrateImpl as U32VecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U32VecDestructorCrossCrateImpl { type Target = AzU32VecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U32VecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U32VecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU32VecDestructorType as U32VecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U32VecDestructorTypeCrossCrateImpl { pub _0: azul::AzU32VecDestructorType }

    #[cfg(feature = "link_static")] pub use U32VecDestructorTypeCrossCrateImpl as U32VecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U32VecDestructorTypeCrossCrateImpl { type Target = AzU32VecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U32VecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XWindowTypeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXWindowTypeVecDestructor as XWindowTypeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XWindowTypeVecDestructorCrossCrateImpl { pub _0: azul::AzXWindowTypeVecDestructor }

    #[cfg(feature = "link_static")] pub use XWindowTypeVecDestructorCrossCrateImpl as XWindowTypeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XWindowTypeVecDestructorCrossCrateImpl { type Target = AzXWindowTypeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XWindowTypeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XWindowTypeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXWindowTypeVecDestructorType as XWindowTypeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XWindowTypeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzXWindowTypeVecDestructorType }

    #[cfg(feature = "link_static")] pub use XWindowTypeVecDestructorTypeCrossCrateImpl as XWindowTypeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XWindowTypeVecDestructorTypeCrossCrateImpl { type Target = AzXWindowTypeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XWindowTypeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VirtualKeyCodeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVirtualKeyCodeVecDestructor as VirtualKeyCodeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VirtualKeyCodeVecDestructorCrossCrateImpl { pub _0: azul::AzVirtualKeyCodeVecDestructor }

    #[cfg(feature = "link_static")] pub use VirtualKeyCodeVecDestructorCrossCrateImpl as VirtualKeyCodeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VirtualKeyCodeVecDestructorCrossCrateImpl { type Target = AzVirtualKeyCodeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VirtualKeyCodeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `VirtualKeyCodeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzVirtualKeyCodeVecDestructorType as VirtualKeyCodeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct VirtualKeyCodeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzVirtualKeyCodeVecDestructorType }

    #[cfg(feature = "link_static")] pub use VirtualKeyCodeVecDestructorTypeCrossCrateImpl as VirtualKeyCodeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for VirtualKeyCodeVecDestructorTypeCrossCrateImpl { type Target = AzVirtualKeyCodeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for VirtualKeyCodeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CascadeInfoVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCascadeInfoVecDestructor as CascadeInfoVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CascadeInfoVecDestructorCrossCrateImpl { pub _0: azul::AzCascadeInfoVecDestructor }

    #[cfg(feature = "link_static")] pub use CascadeInfoVecDestructorCrossCrateImpl as CascadeInfoVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CascadeInfoVecDestructorCrossCrateImpl { type Target = AzCascadeInfoVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CascadeInfoVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CascadeInfoVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCascadeInfoVecDestructorType as CascadeInfoVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CascadeInfoVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCascadeInfoVecDestructorType }

    #[cfg(feature = "link_static")] pub use CascadeInfoVecDestructorTypeCrossCrateImpl as CascadeInfoVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CascadeInfoVecDestructorTypeCrossCrateImpl { type Target = AzCascadeInfoVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CascadeInfoVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ScanCodeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScanCodeVecDestructor as ScanCodeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScanCodeVecDestructorCrossCrateImpl { pub _0: azul::AzScanCodeVecDestructor }

    #[cfg(feature = "link_static")] pub use ScanCodeVecDestructorCrossCrateImpl as ScanCodeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScanCodeVecDestructorCrossCrateImpl { type Target = AzScanCodeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScanCodeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ScanCodeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzScanCodeVecDestructorType as ScanCodeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ScanCodeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzScanCodeVecDestructorType }

    #[cfg(feature = "link_static")] pub use ScanCodeVecDestructorTypeCrossCrateImpl as ScanCodeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ScanCodeVecDestructorTypeCrossCrateImpl { type Target = AzScanCodeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ScanCodeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssDeclarationVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssDeclarationVecDestructor as CssDeclarationVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssDeclarationVecDestructorCrossCrateImpl { pub _0: azul::AzCssDeclarationVecDestructor }

    #[cfg(feature = "link_static")] pub use CssDeclarationVecDestructorCrossCrateImpl as CssDeclarationVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssDeclarationVecDestructorCrossCrateImpl { type Target = AzCssDeclarationVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssDeclarationVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssDeclarationVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssDeclarationVecDestructorType as CssDeclarationVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssDeclarationVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCssDeclarationVecDestructorType }

    #[cfg(feature = "link_static")] pub use CssDeclarationVecDestructorTypeCrossCrateImpl as CssDeclarationVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssDeclarationVecDestructorTypeCrossCrateImpl { type Target = AzCssDeclarationVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssDeclarationVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPathSelectorVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPathSelectorVecDestructor as CssPathSelectorVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathSelectorVecDestructorCrossCrateImpl { pub _0: azul::AzCssPathSelectorVecDestructor }

    #[cfg(feature = "link_static")] pub use CssPathSelectorVecDestructorCrossCrateImpl as CssPathSelectorVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathSelectorVecDestructorCrossCrateImpl { type Target = AzCssPathSelectorVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathSelectorVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssPathSelectorVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssPathSelectorVecDestructorType as CssPathSelectorVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssPathSelectorVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCssPathSelectorVecDestructorType }

    #[cfg(feature = "link_static")] pub use CssPathSelectorVecDestructorTypeCrossCrateImpl as CssPathSelectorVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssPathSelectorVecDestructorTypeCrossCrateImpl { type Target = AzCssPathSelectorVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssPathSelectorVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StylesheetVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylesheetVecDestructor as StylesheetVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylesheetVecDestructorCrossCrateImpl { pub _0: azul::AzStylesheetVecDestructor }

    #[cfg(feature = "link_static")] pub use StylesheetVecDestructorCrossCrateImpl as StylesheetVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylesheetVecDestructorCrossCrateImpl { type Target = AzStylesheetVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylesheetVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StylesheetVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStylesheetVecDestructorType as StylesheetVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StylesheetVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStylesheetVecDestructorType }

    #[cfg(feature = "link_static")] pub use StylesheetVecDestructorTypeCrossCrateImpl as StylesheetVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StylesheetVecDestructorTypeCrossCrateImpl { type Target = AzStylesheetVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StylesheetVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssRuleBlockVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssRuleBlockVecDestructor as CssRuleBlockVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssRuleBlockVecDestructorCrossCrateImpl { pub _0: azul::AzCssRuleBlockVecDestructor }

    #[cfg(feature = "link_static")] pub use CssRuleBlockVecDestructorCrossCrateImpl as CssRuleBlockVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssRuleBlockVecDestructorCrossCrateImpl { type Target = AzCssRuleBlockVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssRuleBlockVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CssRuleBlockVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCssRuleBlockVecDestructorType as CssRuleBlockVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CssRuleBlockVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCssRuleBlockVecDestructorType }

    #[cfg(feature = "link_static")] pub use CssRuleBlockVecDestructorTypeCrossCrateImpl as CssRuleBlockVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CssRuleBlockVecDestructorTypeCrossCrateImpl { type Target = AzCssRuleBlockVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CssRuleBlockVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `F32VecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzF32VecDestructor as F32VecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct F32VecDestructorCrossCrateImpl { pub _0: azul::AzF32VecDestructor }

    #[cfg(feature = "link_static")] pub use F32VecDestructorCrossCrateImpl as F32VecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for F32VecDestructorCrossCrateImpl { type Target = AzF32VecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for F32VecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `F32VecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzF32VecDestructorType as F32VecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct F32VecDestructorTypeCrossCrateImpl { pub _0: azul::AzF32VecDestructorType }

    #[cfg(feature = "link_static")] pub use F32VecDestructorTypeCrossCrateImpl as F32VecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for F32VecDestructorTypeCrossCrateImpl { type Target = AzF32VecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for F32VecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U16VecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU16VecDestructor as U16VecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U16VecDestructorCrossCrateImpl { pub _0: azul::AzU16VecDestructor }

    #[cfg(feature = "link_static")] pub use U16VecDestructorCrossCrateImpl as U16VecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U16VecDestructorCrossCrateImpl { type Target = AzU16VecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U16VecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U16VecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU16VecDestructorType as U16VecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U16VecDestructorTypeCrossCrateImpl { pub _0: azul::AzU16VecDestructorType }

    #[cfg(feature = "link_static")] pub use U16VecDestructorTypeCrossCrateImpl as U16VecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U16VecDestructorTypeCrossCrateImpl { type Target = AzU16VecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U16VecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U8VecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU8VecDestructor as U8VecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U8VecDestructorCrossCrateImpl { pub _0: azul::AzU8VecDestructor }

    #[cfg(feature = "link_static")] pub use U8VecDestructorCrossCrateImpl as U8VecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U8VecDestructorCrossCrateImpl { type Target = AzU8VecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U8VecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `U8VecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzU8VecDestructorType as U8VecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct U8VecDestructorTypeCrossCrateImpl { pub _0: azul::AzU8VecDestructorType }

    #[cfg(feature = "link_static")] pub use U8VecDestructorTypeCrossCrateImpl as U8VecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for U8VecDestructorTypeCrossCrateImpl { type Target = AzU8VecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for U8VecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CallbackDataVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackDataVecDestructor as CallbackDataVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackDataVecDestructorCrossCrateImpl { pub _0: azul::AzCallbackDataVecDestructor }

    #[cfg(feature = "link_static")] pub use CallbackDataVecDestructorCrossCrateImpl as CallbackDataVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackDataVecDestructorCrossCrateImpl { type Target = AzCallbackDataVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackDataVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `CallbackDataVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzCallbackDataVecDestructorType as CallbackDataVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct CallbackDataVecDestructorTypeCrossCrateImpl { pub _0: azul::AzCallbackDataVecDestructorType }

    #[cfg(feature = "link_static")] pub use CallbackDataVecDestructorTypeCrossCrateImpl as CallbackDataVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for CallbackDataVecDestructorTypeCrossCrateImpl { type Target = AzCallbackDataVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for CallbackDataVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DebugMessageVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDebugMessageVecDestructor as DebugMessageVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DebugMessageVecDestructorCrossCrateImpl { pub _0: azul::AzDebugMessageVecDestructor }

    #[cfg(feature = "link_static")] pub use DebugMessageVecDestructorCrossCrateImpl as DebugMessageVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DebugMessageVecDestructorCrossCrateImpl { type Target = AzDebugMessageVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DebugMessageVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DebugMessageVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDebugMessageVecDestructorType as DebugMessageVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DebugMessageVecDestructorTypeCrossCrateImpl { pub _0: azul::AzDebugMessageVecDestructorType }

    #[cfg(feature = "link_static")] pub use DebugMessageVecDestructorTypeCrossCrateImpl as DebugMessageVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DebugMessageVecDestructorTypeCrossCrateImpl { type Target = AzDebugMessageVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DebugMessageVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GLuintVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLuintVecDestructor as GLuintVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLuintVecDestructorCrossCrateImpl { pub _0: azul::AzGLuintVecDestructor }

    #[cfg(feature = "link_static")] pub use GLuintVecDestructorCrossCrateImpl as GLuintVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLuintVecDestructorCrossCrateImpl { type Target = AzGLuintVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLuintVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GLuintVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLuintVecDestructorType as GLuintVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLuintVecDestructorTypeCrossCrateImpl { pub _0: azul::AzGLuintVecDestructorType }

    #[cfg(feature = "link_static")] pub use GLuintVecDestructorTypeCrossCrateImpl as GLuintVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLuintVecDestructorTypeCrossCrateImpl { type Target = AzGLuintVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLuintVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GLintVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLintVecDestructor as GLintVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLintVecDestructorCrossCrateImpl { pub _0: azul::AzGLintVecDestructor }

    #[cfg(feature = "link_static")] pub use GLintVecDestructorCrossCrateImpl as GLintVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLintVecDestructorCrossCrateImpl { type Target = AzGLintVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLintVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `GLintVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzGLintVecDestructorType as GLintVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct GLintVecDestructorTypeCrossCrateImpl { pub _0: azul::AzGLintVecDestructorType }

    #[cfg(feature = "link_static")] pub use GLintVecDestructorTypeCrossCrateImpl as GLintVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for GLintVecDestructorTypeCrossCrateImpl { type Target = AzGLintVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for GLintVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StringVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringVecDestructor as StringVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringVecDestructorCrossCrateImpl { pub _0: azul::AzStringVecDestructor }

    #[cfg(feature = "link_static")] pub use StringVecDestructorCrossCrateImpl as StringVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringVecDestructorCrossCrateImpl { type Target = AzStringVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StringVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringVecDestructorType as StringVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStringVecDestructorType }

    #[cfg(feature = "link_static")] pub use StringVecDestructorTypeCrossCrateImpl as StringVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringVecDestructorTypeCrossCrateImpl { type Target = AzStringVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StringPairVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringPairVecDestructor as StringPairVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringPairVecDestructorCrossCrateImpl { pub _0: azul::AzStringPairVecDestructor }

    #[cfg(feature = "link_static")] pub use StringPairVecDestructorCrossCrateImpl as StringPairVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringPairVecDestructorCrossCrateImpl { type Target = AzStringPairVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringPairVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StringPairVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStringPairVecDestructorType as StringPairVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StringPairVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStringPairVecDestructorType }

    #[cfg(feature = "link_static")] pub use StringPairVecDestructorTypeCrossCrateImpl as StringPairVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StringPairVecDestructorTypeCrossCrateImpl { type Target = AzStringPairVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StringPairVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NormalizedLinearColorStopVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedLinearColorStopVecDestructor as NormalizedLinearColorStopVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedLinearColorStopVecDestructorCrossCrateImpl { pub _0: azul::AzNormalizedLinearColorStopVecDestructor }

    #[cfg(feature = "link_static")] pub use NormalizedLinearColorStopVecDestructorCrossCrateImpl as NormalizedLinearColorStopVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedLinearColorStopVecDestructorCrossCrateImpl { type Target = AzNormalizedLinearColorStopVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedLinearColorStopVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NormalizedLinearColorStopVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedLinearColorStopVecDestructorType as NormalizedLinearColorStopVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedLinearColorStopVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNormalizedLinearColorStopVecDestructorType }

    #[cfg(feature = "link_static")] pub use NormalizedLinearColorStopVecDestructorTypeCrossCrateImpl as NormalizedLinearColorStopVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedLinearColorStopVecDestructorTypeCrossCrateImpl { type Target = AzNormalizedLinearColorStopVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedLinearColorStopVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NormalizedRadialColorStopVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedRadialColorStopVecDestructor as NormalizedRadialColorStopVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedRadialColorStopVecDestructorCrossCrateImpl { pub _0: azul::AzNormalizedRadialColorStopVecDestructor }

    #[cfg(feature = "link_static")] pub use NormalizedRadialColorStopVecDestructorCrossCrateImpl as NormalizedRadialColorStopVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedRadialColorStopVecDestructorCrossCrateImpl { type Target = AzNormalizedRadialColorStopVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedRadialColorStopVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NormalizedRadialColorStopVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNormalizedRadialColorStopVecDestructorType as NormalizedRadialColorStopVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NormalizedRadialColorStopVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNormalizedRadialColorStopVecDestructorType }

    #[cfg(feature = "link_static")] pub use NormalizedRadialColorStopVecDestructorTypeCrossCrateImpl as NormalizedRadialColorStopVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NormalizedRadialColorStopVecDestructorTypeCrossCrateImpl { type Target = AzNormalizedRadialColorStopVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NormalizedRadialColorStopVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeIdVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdVecDestructor as NodeIdVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdVecDestructorCrossCrateImpl { pub _0: azul::AzNodeIdVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeIdVecDestructorCrossCrateImpl as NodeIdVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdVecDestructorCrossCrateImpl { type Target = AzNodeIdVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeIdVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeIdVecDestructorType as NodeIdVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeIdVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeIdVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeIdVecDestructorTypeCrossCrateImpl as NodeIdVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeIdVecDestructorTypeCrossCrateImpl { type Target = AzNodeIdVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeIdVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeHierarchyItemVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeHierarchyItemVecDestructor as NodeHierarchyItemVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeHierarchyItemVecDestructorCrossCrateImpl { pub _0: azul::AzNodeHierarchyItemVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeHierarchyItemVecDestructorCrossCrateImpl as NodeHierarchyItemVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeHierarchyItemVecDestructorCrossCrateImpl { type Target = AzNodeHierarchyItemVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeHierarchyItemVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeHierarchyItemVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeHierarchyItemVecDestructorType as NodeHierarchyItemVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeHierarchyItemVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeHierarchyItemVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeHierarchyItemVecDestructorTypeCrossCrateImpl as NodeHierarchyItemVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeHierarchyItemVecDestructorTypeCrossCrateImpl { type Target = AzNodeHierarchyItemVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeHierarchyItemVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyledNodeVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledNodeVecDestructor as StyledNodeVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledNodeVecDestructorCrossCrateImpl { pub _0: azul::AzStyledNodeVecDestructor }

    #[cfg(feature = "link_static")] pub use StyledNodeVecDestructorCrossCrateImpl as StyledNodeVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledNodeVecDestructorCrossCrateImpl { type Target = AzStyledNodeVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledNodeVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `StyledNodeVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzStyledNodeVecDestructorType as StyledNodeVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct StyledNodeVecDestructorTypeCrossCrateImpl { pub _0: azul::AzStyledNodeVecDestructorType }

    #[cfg(feature = "link_static")] pub use StyledNodeVecDestructorTypeCrossCrateImpl as StyledNodeVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for StyledNodeVecDestructorTypeCrossCrateImpl { type Target = AzStyledNodeVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for StyledNodeVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TagIdToNodeIdMappingVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTagIdToNodeIdMappingVecDestructor as TagIdToNodeIdMappingVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TagIdToNodeIdMappingVecDestructorCrossCrateImpl { pub _0: azul::AzTagIdToNodeIdMappingVecDestructor }

    #[cfg(feature = "link_static")] pub use TagIdToNodeIdMappingVecDestructorCrossCrateImpl as TagIdToNodeIdMappingVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TagIdToNodeIdMappingVecDestructorCrossCrateImpl { type Target = AzTagIdToNodeIdMappingVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TagIdToNodeIdMappingVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `TagIdToNodeIdMappingVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzTagIdToNodeIdMappingVecDestructorType as TagIdToNodeIdMappingVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct TagIdToNodeIdMappingVecDestructorTypeCrossCrateImpl { pub _0: azul::AzTagIdToNodeIdMappingVecDestructorType }

    #[cfg(feature = "link_static")] pub use TagIdToNodeIdMappingVecDestructorTypeCrossCrateImpl as TagIdToNodeIdMappingVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for TagIdToNodeIdMappingVecDestructorTypeCrossCrateImpl { type Target = AzTagIdToNodeIdMappingVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for TagIdToNodeIdMappingVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ParentWithNodeDepthVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzParentWithNodeDepthVecDestructor as ParentWithNodeDepthVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ParentWithNodeDepthVecDestructorCrossCrateImpl { pub _0: azul::AzParentWithNodeDepthVecDestructor }

    #[cfg(feature = "link_static")] pub use ParentWithNodeDepthVecDestructorCrossCrateImpl as ParentWithNodeDepthVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ParentWithNodeDepthVecDestructorCrossCrateImpl { type Target = AzParentWithNodeDepthVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ParentWithNodeDepthVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ParentWithNodeDepthVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzParentWithNodeDepthVecDestructorType as ParentWithNodeDepthVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ParentWithNodeDepthVecDestructorTypeCrossCrateImpl { pub _0: azul::AzParentWithNodeDepthVecDestructorType }

    #[cfg(feature = "link_static")] pub use ParentWithNodeDepthVecDestructorTypeCrossCrateImpl as ParentWithNodeDepthVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ParentWithNodeDepthVecDestructorTypeCrossCrateImpl { type Target = AzParentWithNodeDepthVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ParentWithNodeDepthVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDataVecDestructor` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataVecDestructor as NodeDataVecDestructor;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataVecDestructorCrossCrateImpl { pub _0: azul::AzNodeDataVecDestructor }

    #[cfg(feature = "link_static")] pub use NodeDataVecDestructorCrossCrateImpl as NodeDataVecDestructor;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataVecDestructorCrossCrateImpl { type Target = AzNodeDataVecDestructor; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataVecDestructorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NodeDataVecDestructorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNodeDataVecDestructorType as NodeDataVecDestructorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NodeDataVecDestructorTypeCrossCrateImpl { pub _0: azul::AzNodeDataVecDestructorType }

    #[cfg(feature = "link_static")] pub use NodeDataVecDestructorTypeCrossCrateImpl as NodeDataVecDestructorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NodeDataVecDestructorTypeCrossCrateImpl { type Target = AzNodeDataVecDestructorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NodeDataVecDestructorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod option {
    #![allow(dead_code, unused_imports)]
    //! Definition of azuls internal `Option<*>` wrappers
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    use crate::dll::*;

    macro_rules! impl_option_inner {
        ($struct_type:ident, $struct_name:ident) => (

        #[cfg(not(feature = "link_static"))]
        impl Default for $struct_name {
            fn default() -> $struct_name { $struct_name::None }
        }

        #[cfg(not(feature = "link_static"))]
        impl $struct_name {
            pub fn as_option(&self) -> Option<&$struct_type> {
                match self {
                    $struct_name::None => None,
                    $struct_name::Some(t) => Some(t),
                }
            }
            pub fn replace(&mut self, value: $struct_type) -> $struct_name {
                ::core::mem::replace(self, $struct_name::Some(value))
            }
            pub const fn is_some(&self) -> bool {
                match self {
                    $struct_name::None => false,
                    $struct_name::Some(_) => true,
                }
            }
            pub const fn is_none(&self) -> bool {
                !self.is_some()
            }
            pub const fn as_ref(&self) -> Option<&$struct_type> {
                match *self {
                    $struct_name::Some(ref x) => Some(x),
                    $struct_name::None => None,
                }
            }
        }
    )}

    macro_rules! impl_option {
        ($struct_type:ident, $struct_name:ident, copy = false, clone = false, [$($derive:meta),* ]) => (
            impl_option_inner!($struct_type, $struct_name);
        );
        ($struct_type:ident, $struct_name:ident, copy = false, [$($derive:meta),* ]) => (
            impl_option_inner!($struct_type, $struct_name);

            #[cfg(not(feature = "link_static"))]
            impl From<$struct_name> for Option<$struct_type> {
                fn from(o: $struct_name) -> Option<$struct_type> {
                    match &o {
                        $struct_name::None => None,
                        $struct_name::Some(t) => Some(t.clone()),
                    }
                }
            }

            #[cfg(not(feature = "link_static"))]
            impl From<Option<$struct_type>> for $struct_name {
                fn from(o: Option<$struct_type>) -> $struct_name {
                    match &o {
                        None => $struct_name::None,
                        Some(t) => $struct_name::Some(t.clone()),
                    }
                }
            }

            #[cfg(not(feature = "link_static"))]
            impl $struct_name {
                pub fn into_option(self) -> Option<$struct_type> {
                    self.into()
                }
                pub fn map<U, F: FnOnce($struct_type) -> U>(self, f: F) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => Some(f(s)),
                    }
                }

                pub fn and_then<U, F>(self, f: F) -> Option<U> where F: FnOnce($struct_type) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => f(s),
                    }
                }
            }
        );
        ($struct_type:ident, $struct_name:ident, [$($derive:meta),* ]) => (
            impl_option_inner!($struct_type, $struct_name);

            #[cfg(not(feature = "link_static"))]
            impl From<$struct_name> for Option<$struct_type> {
                fn from(o: $struct_name) -> Option<$struct_type> {
                    match o {
                        $struct_name::None => None,
                        $struct_name::Some(t) => Some(t),
                    }
                }
            }

            #[cfg(not(feature = "link_static"))]
            impl From<Option<$struct_type>> for $struct_name {
                fn from(o: Option<$struct_type>) -> $struct_name {
                    match o {
                        None => $struct_name::None,
                        Some(t) => $struct_name::Some(t),
                    }
                }
            }

            #[cfg(not(feature = "link_static"))]
            impl $struct_name {
                pub fn into_option(self) -> Option<$struct_type> {
                    self.into()
                }
                pub fn map<U, F: FnOnce($struct_type) -> U>(self, f: F) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => Some(f(s)),
                    }
                }

                pub fn and_then<U, F>(self, f: F) -> Option<U> where F: FnOnce($struct_type) -> Option<U> {
                    match self.into_option() {
                        None => None,
                        Some(s) => f(s),
                    }
                }
            }
        );
    }

    pub type AzX11Visual = *const c_void;
    pub type AzHwndHandle = *mut c_void;

    impl_option!(i32, AzOptionI32, [Debug, Copy, Clone]);
    impl_option!(f32, AzOptionF32, [Debug, Copy, Clone]);
    impl_option!(usize, AzOptionUsize, [Debug, Copy, Clone]);
    impl_option!(u32, AzOptionChar, [Debug, Copy, Clone]);

    impl_option!(AzThreadId, AzOptionThreadId, [Debug, Copy, Clone]);
    impl_option!(AzTimerId, AzOptionTimerId, [Debug, Copy, Clone]);
    impl_option!(AzThreadSendMsg, AzOptionThreadSendMsg, [Debug, Copy, Clone]);
    impl_option!(AzLayoutRect, AzOptionLayoutRect, [Debug, Copy, Clone]);
    impl_option!(AzRefAny, AzOptionRefAny, copy = false, clone = false, [Debug, Clone]);
    impl_option!(AzLayoutPoint, AzOptionLayoutPoint, [Debug, Copy, Clone]);
    impl_option!(AzWindowTheme, AzOptionWindowTheme, [Debug, Copy, Clone]);
    impl_option!(AzNodeId, AzOptionNodeId, [Debug, Copy, Clone]);
    impl_option!(AzDomNodeId, AzOptionDomNodeId, [Debug, Copy, Clone]);
    impl_option!(AzColorU, AzOptionColorU, [Debug, Copy, Clone]);
    impl_option!(AzRawImage, AzOptionRawImage, copy = false, [Debug, Clone]);
    impl_option!(AzSvgDashPattern, AzOptionSvgDashPattern, [Debug, Copy, Clone]);
    impl_option!(AzWaylandTheme, AzOptionWaylandTheme, copy = false, [Debug, Clone]);
    impl_option!(AzTaskBarIcon, AzOptionTaskBarIcon, copy = false, [Debug, Clone]);
    impl_option!(AzLogicalPosition, AzOptionLogicalPosition, [Debug, Copy, Clone]);
    impl_option!(AzPhysicalPositionI32, AzOptionPhysicalPositionI32, [Debug, Copy, Clone]);
    impl_option!(AzWindowIcon, AzOptionWindowIcon, copy = false, [Debug, Clone]);
    impl_option!(AzString, AzOptionString, copy = false, [Debug, Clone]);
    impl_option!(AzMouseCursorType, AzOptionMouseCursorType, [Debug, Copy, Clone]);
    impl_option!(AzLogicalSize, AzOptionLogicalSize, [Debug, Copy, Clone]);
    impl_option!(AzVirtualKeyCode, AzOptionVirtualKeyCode, [Debug, Copy, Clone]);
    impl_option!(AzPercentageValue, AzOptionPercentageValue, [Debug, Copy, Clone]);
    impl_option!(AzDom, AzOptionDom, copy = false, clone = false, [Debug, Clone]);
    impl_option!(AzTexture, AzOptionTexture, copy = false, clone = false, [Debug]);
    impl_option!(AzImageMask, AzOptionImageMask, copy = false, [Debug, Clone]);
    impl_option!(AzTabIndex, AzOptionTabIndex, [Debug, Copy, Clone]);
    impl_option!(AzCallback, AzOptionCallback, [Debug, Copy, Clone]);
    impl_option!(AzTagId, AzOptionTagId, [Debug, Copy, Clone]);
    impl_option!(AzDuration, AzOptionDuration, [Debug, Copy, Clone]);
    impl_option!(AzInstant, AzOptionInstant, copy = false, clone = false, [Debug]); // TODO: impl clone!
    impl_option!(AzU8VecRef, AzOptionU8VecRef, copy = false, clone = false, [Debug]);
    impl_option!(AzSystemClipboard, AzOptionSystemClipboard, copy = false,  clone = false, [Debug]);
    impl_option!(AzFileTypeList, AzOptionFileTypeList, copy = false, [Debug, Clone]);
    impl_option!(AzWindowState, AzOptionWindowState, copy = false, [Debug, Clone]);
    impl_option!(AzKeyboardState, AzOptionKeyboardState, copy = false, [Debug, Clone]);
    impl_option!(AzMouseState, AzOptionMouseState, [Debug, Clone]);
    impl_option!(AzNodeGraphOnNodeAdded, AzOptionNodeGraphOnNodeAdded, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeRemoved, AzOptionNodeGraphOnNodeRemoved, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeDragged, AzOptionNodeGraphOnNodeDragged, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeGraphDragged, AzOptionNodeGraphOnNodeGraphDragged, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeConnected, AzOptionNodeGraphOnNodeConnected, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeInputDisconnected, AzOptionNodeGraphOnNodeInputDisconnected, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeOutputDisconnected, AzOptionNodeGraphOnNodeOutputDisconnected, [Debug, Copy, Clone]);
    impl_option!(AzNodeGraphOnNodeFieldEdited, AzOptionNodeGraphOnNodeFieldEdited, [Debug, Copy, Clone]);
    impl_option!(AzGl, AzOptionGl, copy = false, [Debug, Clone]);    /// `OptionDropDownOnChoiceChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionDropDownOnChoiceChange as OptionDropDownOnChoiceChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionDropDownOnChoiceChangeCrossCrateImpl { pub _0: azul::AzOptionDropDownOnChoiceChange }

    #[cfg(feature = "link_static")] pub use OptionDropDownOnChoiceChangeCrossCrateImpl as OptionDropDownOnChoiceChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionDropDownOnChoiceChangeCrossCrateImpl { type Target = AzOptionDropDownOnChoiceChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionDropDownOnChoiceChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionResolvedTextLayoutOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionResolvedTextLayoutOptions as OptionResolvedTextLayoutOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionResolvedTextLayoutOptionsCrossCrateImpl { pub _0: azul::AzOptionResolvedTextLayoutOptions }

    #[cfg(feature = "link_static")] pub use OptionResolvedTextLayoutOptionsCrossCrateImpl as OptionResolvedTextLayoutOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionResolvedTextLayoutOptionsCrossCrateImpl { type Target = AzOptionResolvedTextLayoutOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionResolvedTextLayoutOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeAdded` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeAdded as OptionNodeGraphOnNodeAdded;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeAddedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeAdded }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeAddedCrossCrateImpl as OptionNodeGraphOnNodeAdded;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeAddedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeAdded; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeAddedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeRemoved` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeRemoved as OptionNodeGraphOnNodeRemoved;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeRemovedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeRemoved }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeRemovedCrossCrateImpl as OptionNodeGraphOnNodeRemoved;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeRemovedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeRemoved; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeRemovedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeGraphDragged` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeGraphDragged as OptionNodeGraphOnNodeGraphDragged;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeGraphDraggedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeGraphDragged }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeGraphDraggedCrossCrateImpl as OptionNodeGraphOnNodeGraphDragged;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeGraphDraggedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeGraphDragged; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeGraphDraggedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeDragged` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeDragged as OptionNodeGraphOnNodeDragged;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeDraggedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeDragged }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeDraggedCrossCrateImpl as OptionNodeGraphOnNodeDragged;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeDraggedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeDragged; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeDraggedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeConnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeConnected as OptionNodeGraphOnNodeConnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeConnectedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeConnected }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeConnectedCrossCrateImpl as OptionNodeGraphOnNodeConnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeConnectedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeConnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeConnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeInputDisconnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeInputDisconnected as OptionNodeGraphOnNodeInputDisconnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeInputDisconnectedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeInputDisconnected }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeInputDisconnectedCrossCrateImpl as OptionNodeGraphOnNodeInputDisconnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeInputDisconnectedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeInputDisconnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeInputDisconnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeOutputDisconnected` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeOutputDisconnected as OptionNodeGraphOnNodeOutputDisconnected;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeOutputDisconnectedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeOutputDisconnected }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeOutputDisconnectedCrossCrateImpl as OptionNodeGraphOnNodeOutputDisconnected;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeOutputDisconnectedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeOutputDisconnected; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeOutputDisconnectedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeGraphOnNodeFieldEdited` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeGraphOnNodeFieldEdited as OptionNodeGraphOnNodeFieldEdited;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeGraphOnNodeFieldEditedCrossCrateImpl { pub _0: azul::AzOptionNodeGraphOnNodeFieldEdited }

    #[cfg(feature = "link_static")] pub use OptionNodeGraphOnNodeFieldEditedCrossCrateImpl as OptionNodeGraphOnNodeFieldEdited;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeGraphOnNodeFieldEditedCrossCrateImpl { type Target = AzOptionNodeGraphOnNodeFieldEdited; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeGraphOnNodeFieldEditedCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionColorInputOnValueChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionColorInputOnValueChange as OptionColorInputOnValueChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionColorInputOnValueChangeCrossCrateImpl { pub _0: azul::AzOptionColorInputOnValueChange }

    #[cfg(feature = "link_static")] pub use OptionColorInputOnValueChangeCrossCrateImpl as OptionColorInputOnValueChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionColorInputOnValueChangeCrossCrateImpl { type Target = AzOptionColorInputOnValueChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionColorInputOnValueChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionButtonOnClick` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionButtonOnClick as OptionButtonOnClick;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionButtonOnClickCrossCrateImpl { pub _0: azul::AzOptionButtonOnClick }

    #[cfg(feature = "link_static")] pub use OptionButtonOnClickCrossCrateImpl as OptionButtonOnClick;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionButtonOnClickCrossCrateImpl { type Target = AzOptionButtonOnClick; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionButtonOnClickCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionFileInputOnPathChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionFileInputOnPathChange as OptionFileInputOnPathChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionFileInputOnPathChangeCrossCrateImpl { pub _0: azul::AzOptionFileInputOnPathChange }

    #[cfg(feature = "link_static")] pub use OptionFileInputOnPathChangeCrossCrateImpl as OptionFileInputOnPathChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionFileInputOnPathChangeCrossCrateImpl { type Target = AzOptionFileInputOnPathChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionFileInputOnPathChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionCheckBoxOnToggle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionCheckBoxOnToggle as OptionCheckBoxOnToggle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionCheckBoxOnToggleCrossCrateImpl { pub _0: azul::AzOptionCheckBoxOnToggle }

    #[cfg(feature = "link_static")] pub use OptionCheckBoxOnToggleCrossCrateImpl as OptionCheckBoxOnToggle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionCheckBoxOnToggleCrossCrateImpl { type Target = AzOptionCheckBoxOnToggle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionCheckBoxOnToggleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTextInputOnTextInput` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTextInputOnTextInput as OptionTextInputOnTextInput;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTextInputOnTextInputCrossCrateImpl { pub _0: azul::AzOptionTextInputOnTextInput }

    #[cfg(feature = "link_static")] pub use OptionTextInputOnTextInputCrossCrateImpl as OptionTextInputOnTextInput;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTextInputOnTextInputCrossCrateImpl { type Target = AzOptionTextInputOnTextInput; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTextInputOnTextInputCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTextInputOnVirtualKeyDown` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTextInputOnVirtualKeyDown as OptionTextInputOnVirtualKeyDown;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTextInputOnVirtualKeyDownCrossCrateImpl { pub _0: azul::AzOptionTextInputOnVirtualKeyDown }

    #[cfg(feature = "link_static")] pub use OptionTextInputOnVirtualKeyDownCrossCrateImpl as OptionTextInputOnVirtualKeyDown;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTextInputOnVirtualKeyDownCrossCrateImpl { type Target = AzOptionTextInputOnVirtualKeyDown; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTextInputOnVirtualKeyDownCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTextInputOnFocusLost` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTextInputOnFocusLost as OptionTextInputOnFocusLost;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTextInputOnFocusLostCrossCrateImpl { pub _0: azul::AzOptionTextInputOnFocusLost }

    #[cfg(feature = "link_static")] pub use OptionTextInputOnFocusLostCrossCrateImpl as OptionTextInputOnFocusLost;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTextInputOnFocusLostCrossCrateImpl { type Target = AzOptionTextInputOnFocusLost; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTextInputOnFocusLostCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTextInputSelection` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTextInputSelection as OptionTextInputSelection;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTextInputSelectionCrossCrateImpl { pub _0: azul::AzOptionTextInputSelection }

    #[cfg(feature = "link_static")] pub use OptionTextInputSelectionCrossCrateImpl as OptionTextInputSelection;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTextInputSelectionCrossCrateImpl { type Target = AzOptionTextInputSelection; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTextInputSelectionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNumberInputOnFocusLost` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNumberInputOnFocusLost as OptionNumberInputOnFocusLost;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNumberInputOnFocusLostCrossCrateImpl { pub _0: azul::AzOptionNumberInputOnFocusLost }

    #[cfg(feature = "link_static")] pub use OptionNumberInputOnFocusLostCrossCrateImpl as OptionNumberInputOnFocusLost;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNumberInputOnFocusLostCrossCrateImpl { type Target = AzOptionNumberInputOnFocusLost; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNumberInputOnFocusLostCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNumberInputOnValueChange` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNumberInputOnValueChange as OptionNumberInputOnValueChange;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNumberInputOnValueChangeCrossCrateImpl { pub _0: azul::AzOptionNumberInputOnValueChange }

    #[cfg(feature = "link_static")] pub use OptionNumberInputOnValueChangeCrossCrateImpl as OptionNumberInputOnValueChange;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNumberInputOnValueChangeCrossCrateImpl { type Target = AzOptionNumberInputOnValueChange; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNumberInputOnValueChangeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionMenuItemIcon` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionMenuItemIcon as OptionMenuItemIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionMenuItemIconCrossCrateImpl { pub _0: azul::AzOptionMenuItemIcon }

    #[cfg(feature = "link_static")] pub use OptionMenuItemIconCrossCrateImpl as OptionMenuItemIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionMenuItemIconCrossCrateImpl { type Target = AzOptionMenuItemIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionMenuItemIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionMenuCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionMenuCallback as OptionMenuCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionMenuCallbackCrossCrateImpl { pub _0: azul::AzOptionMenuCallback }

    #[cfg(feature = "link_static")] pub use OptionMenuCallbackCrossCrateImpl as OptionMenuCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionMenuCallbackCrossCrateImpl { type Target = AzOptionMenuCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionMenuCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionVirtualKeyCodeCombo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionVirtualKeyCodeCombo as OptionVirtualKeyCodeCombo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionVirtualKeyCodeComboCrossCrateImpl { pub _0: azul::AzOptionVirtualKeyCodeCombo }

    #[cfg(feature = "link_static")] pub use OptionVirtualKeyCodeComboCrossCrateImpl as OptionVirtualKeyCodeCombo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionVirtualKeyCodeComboCrossCrateImpl { type Target = AzOptionVirtualKeyCodeCombo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionVirtualKeyCodeComboCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionCssProperty` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionCssProperty as OptionCssProperty;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionCssPropertyCrossCrateImpl { pub _0: azul::AzOptionCssProperty }

    #[cfg(feature = "link_static")] pub use OptionCssPropertyCrossCrateImpl as OptionCssProperty;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionCssPropertyCrossCrateImpl { type Target = AzOptionCssProperty; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionCssPropertyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionPositionInfo` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionPositionInfo as OptionPositionInfo;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionPositionInfoCrossCrateImpl { pub _0: azul::AzOptionPositionInfo }

    #[cfg(feature = "link_static")] pub use OptionPositionInfoCrossCrateImpl as OptionPositionInfo;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionPositionInfoCrossCrateImpl { type Target = AzOptionPositionInfo; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionPositionInfoCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTimerId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTimerId as OptionTimerId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTimerIdCrossCrateImpl { pub _0: azul::AzOptionTimerId }

    #[cfg(feature = "link_static")] pub use OptionTimerIdCrossCrateImpl as OptionTimerId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTimerIdCrossCrateImpl { type Target = AzOptionTimerId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTimerIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionThreadId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionThreadId as OptionThreadId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionThreadIdCrossCrateImpl { pub _0: azul::AzOptionThreadId }

    #[cfg(feature = "link_static")] pub use OptionThreadIdCrossCrateImpl as OptionThreadId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionThreadIdCrossCrateImpl { type Target = AzOptionThreadId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionThreadIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionI16` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionI16 as OptionI16;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionI16CrossCrateImpl { pub _0: azul::AzOptionI16 }

    #[cfg(feature = "link_static")] pub use OptionI16CrossCrateImpl as OptionI16;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionI16CrossCrateImpl { type Target = AzOptionI16; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionI16CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionU16` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionU16 as OptionU16;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionU16CrossCrateImpl { pub _0: azul::AzOptionU16 }

    #[cfg(feature = "link_static")] pub use OptionU16CrossCrateImpl as OptionU16;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionU16CrossCrateImpl { type Target = AzOptionU16; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionU16CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionU32` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionU32 as OptionU32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionU32CrossCrateImpl { pub _0: azul::AzOptionU32 }

    #[cfg(feature = "link_static")] pub use OptionU32CrossCrateImpl as OptionU32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionU32CrossCrateImpl { type Target = AzOptionU32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionU32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionImageRef` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionImageRef as OptionImageRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionImageRefCrossCrateImpl { pub _0: azul::AzOptionImageRef }

    #[cfg(feature = "link_static")] pub use OptionImageRefCrossCrateImpl as OptionImageRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionImageRefCrossCrateImpl { type Target = AzOptionImageRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionImageRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionFontRef` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionFontRef as OptionFontRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionFontRefCrossCrateImpl { pub _0: azul::AzOptionFontRef }

    #[cfg(feature = "link_static")] pub use OptionFontRefCrossCrateImpl as OptionFontRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionFontRefCrossCrateImpl { type Target = AzOptionFontRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionFontRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionSystemClipboard` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionSystemClipboard as OptionSystemClipboard;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionSystemClipboardCrossCrateImpl { pub _0: azul::AzOptionSystemClipboard }

    #[cfg(feature = "link_static")] pub use OptionSystemClipboardCrossCrateImpl as OptionSystemClipboard;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionSystemClipboardCrossCrateImpl { type Target = AzOptionSystemClipboard; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionSystemClipboardCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionFileTypeList` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionFileTypeList as OptionFileTypeList;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionFileTypeListCrossCrateImpl { pub _0: azul::AzOptionFileTypeList }

    #[cfg(feature = "link_static")] pub use OptionFileTypeListCrossCrateImpl as OptionFileTypeList;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionFileTypeListCrossCrateImpl { type Target = AzOptionFileTypeList; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionFileTypeListCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionWindowState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionWindowState as OptionWindowState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionWindowStateCrossCrateImpl { pub _0: azul::AzOptionWindowState }

    #[cfg(feature = "link_static")] pub use OptionWindowStateCrossCrateImpl as OptionWindowState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionWindowStateCrossCrateImpl { type Target = AzOptionWindowState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionWindowStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionMouseState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionMouseState as OptionMouseState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionMouseStateCrossCrateImpl { pub _0: azul::AzOptionMouseState }

    #[cfg(feature = "link_static")] pub use OptionMouseStateCrossCrateImpl as OptionMouseState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionMouseStateCrossCrateImpl { type Target = AzOptionMouseState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionMouseStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionKeyboardState` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionKeyboardState as OptionKeyboardState;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionKeyboardStateCrossCrateImpl { pub _0: azul::AzOptionKeyboardState }

    #[cfg(feature = "link_static")] pub use OptionKeyboardStateCrossCrateImpl as OptionKeyboardState;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionKeyboardStateCrossCrateImpl { type Target = AzOptionKeyboardState; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionKeyboardStateCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionStringVec` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionStringVec as OptionStringVec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionStringVecCrossCrateImpl { pub _0: azul::AzOptionStringVec }

    #[cfg(feature = "link_static")] pub use OptionStringVecCrossCrateImpl as OptionStringVec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionStringVecCrossCrateImpl { type Target = AzOptionStringVec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionStringVecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionFile` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionFile as OptionFile;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionFileCrossCrateImpl { pub _0: azul::AzOptionFile }

    #[cfg(feature = "link_static")] pub use OptionFileCrossCrateImpl as OptionFile;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionFileCrossCrateImpl { type Target = AzOptionFile; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionFileCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionGl` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionGl as OptionGl;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionGlCrossCrateImpl { pub _0: azul::AzOptionGl }

    #[cfg(feature = "link_static")] pub use OptionGlCrossCrateImpl as OptionGl;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionGlCrossCrateImpl { type Target = AzOptionGl; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionGlCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionThreadReceiveMsg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionThreadReceiveMsg as OptionThreadReceiveMsg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionThreadReceiveMsgCrossCrateImpl { pub _0: azul::AzOptionThreadReceiveMsg }

    #[cfg(feature = "link_static")] pub use OptionThreadReceiveMsgCrossCrateImpl as OptionThreadReceiveMsg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionThreadReceiveMsgCrossCrateImpl { type Target = AzOptionThreadReceiveMsg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionThreadReceiveMsgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionPercentageValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionPercentageValue as OptionPercentageValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionPercentageValueCrossCrateImpl { pub _0: azul::AzOptionPercentageValue }

    #[cfg(feature = "link_static")] pub use OptionPercentageValueCrossCrateImpl as OptionPercentageValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionPercentageValueCrossCrateImpl { type Target = AzOptionPercentageValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionPercentageValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionAngleValue` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionAngleValue as OptionAngleValue;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionAngleValueCrossCrateImpl { pub _0: azul::AzOptionAngleValue }

    #[cfg(feature = "link_static")] pub use OptionAngleValueCrossCrateImpl as OptionAngleValue;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionAngleValueCrossCrateImpl { type Target = AzOptionAngleValue; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionAngleValueCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionRendererOptions` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionRendererOptions as OptionRendererOptions;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionRendererOptionsCrossCrateImpl { pub _0: azul::AzOptionRendererOptions }

    #[cfg(feature = "link_static")] pub use OptionRendererOptionsCrossCrateImpl as OptionRendererOptions;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionRendererOptionsCrossCrateImpl { type Target = AzOptionRendererOptions; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionRendererOptionsCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionCallback` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionCallback as OptionCallback;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionCallbackCrossCrateImpl { pub _0: azul::AzOptionCallback }

    #[cfg(feature = "link_static")] pub use OptionCallbackCrossCrateImpl as OptionCallback;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionCallbackCrossCrateImpl { type Target = AzOptionCallback; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionCallbackCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionThreadSendMsg` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionThreadSendMsg as OptionThreadSendMsg;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionThreadSendMsgCrossCrateImpl { pub _0: azul::AzOptionThreadSendMsg }

    #[cfg(feature = "link_static")] pub use OptionThreadSendMsgCrossCrateImpl as OptionThreadSendMsg;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionThreadSendMsgCrossCrateImpl { type Target = AzOptionThreadSendMsg; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionThreadSendMsgCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionLayoutRect` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionLayoutRect as OptionLayoutRect;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionLayoutRectCrossCrateImpl { pub _0: azul::AzOptionLayoutRect }

    #[cfg(feature = "link_static")] pub use OptionLayoutRectCrossCrateImpl as OptionLayoutRect;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionLayoutRectCrossCrateImpl { type Target = AzOptionLayoutRect; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionLayoutRectCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionRefAny` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionRefAny as OptionRefAny;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionRefAnyCrossCrateImpl { pub _0: azul::AzOptionRefAny }

    #[cfg(feature = "link_static")] pub use OptionRefAnyCrossCrateImpl as OptionRefAny;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionRefAnyCrossCrateImpl { type Target = AzOptionRefAny; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionRefAnyCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionInlineText` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionInlineText as OptionInlineText;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionInlineTextCrossCrateImpl { pub _0: azul::AzOptionInlineText }

    #[cfg(feature = "link_static")] pub use OptionInlineTextCrossCrateImpl as OptionInlineText;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionInlineTextCrossCrateImpl { type Target = AzOptionInlineText; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionInlineTextCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionLayoutPoint` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionLayoutPoint as OptionLayoutPoint;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionLayoutPointCrossCrateImpl { pub _0: azul::AzOptionLayoutPoint }

    #[cfg(feature = "link_static")] pub use OptionLayoutPointCrossCrateImpl as OptionLayoutPoint;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionLayoutPointCrossCrateImpl { type Target = AzOptionLayoutPoint; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionLayoutPointCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionLayoutSize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionLayoutSize as OptionLayoutSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionLayoutSizeCrossCrateImpl { pub _0: azul::AzOptionLayoutSize }

    #[cfg(feature = "link_static")] pub use OptionLayoutSizeCrossCrateImpl as OptionLayoutSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionLayoutSizeCrossCrateImpl { type Target = AzOptionLayoutSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionLayoutSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionWindowTheme` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionWindowTheme as OptionWindowTheme;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionWindowThemeCrossCrateImpl { pub _0: azul::AzOptionWindowTheme }

    #[cfg(feature = "link_static")] pub use OptionWindowThemeCrossCrateImpl as OptionWindowTheme;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionWindowThemeCrossCrateImpl { type Target = AzOptionWindowTheme; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionWindowThemeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionNodeId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionNodeId as OptionNodeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionNodeIdCrossCrateImpl { pub _0: azul::AzOptionNodeId }

    #[cfg(feature = "link_static")] pub use OptionNodeIdCrossCrateImpl as OptionNodeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionNodeIdCrossCrateImpl { type Target = AzOptionNodeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionNodeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionDomNodeId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionDomNodeId as OptionDomNodeId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionDomNodeIdCrossCrateImpl { pub _0: azul::AzOptionDomNodeId }

    #[cfg(feature = "link_static")] pub use OptionDomNodeIdCrossCrateImpl as OptionDomNodeId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionDomNodeIdCrossCrateImpl { type Target = AzOptionDomNodeId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionDomNodeIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionColorU` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionColorU as OptionColorU;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionColorUCrossCrateImpl { pub _0: azul::AzOptionColorU }

    #[cfg(feature = "link_static")] pub use OptionColorUCrossCrateImpl as OptionColorU;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionColorUCrossCrateImpl { type Target = AzOptionColorU; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionColorUCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionRawImage` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionRawImage as OptionRawImage;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionRawImageCrossCrateImpl { pub _0: azul::AzOptionRawImage }

    #[cfg(feature = "link_static")] pub use OptionRawImageCrossCrateImpl as OptionRawImage;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionRawImageCrossCrateImpl { type Target = AzOptionRawImage; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionRawImageCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionSvgDashPattern` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionSvgDashPattern as OptionSvgDashPattern;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionSvgDashPatternCrossCrateImpl { pub _0: azul::AzOptionSvgDashPattern }

    #[cfg(feature = "link_static")] pub use OptionSvgDashPatternCrossCrateImpl as OptionSvgDashPattern;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionSvgDashPatternCrossCrateImpl { type Target = AzOptionSvgDashPattern; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionSvgDashPatternCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionWaylandTheme` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionWaylandTheme as OptionWaylandTheme;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionWaylandThemeCrossCrateImpl { pub _0: azul::AzOptionWaylandTheme }

    #[cfg(feature = "link_static")] pub use OptionWaylandThemeCrossCrateImpl as OptionWaylandTheme;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionWaylandThemeCrossCrateImpl { type Target = AzOptionWaylandTheme; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionWaylandThemeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTaskBarIcon` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTaskBarIcon as OptionTaskBarIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTaskBarIconCrossCrateImpl { pub _0: azul::AzOptionTaskBarIcon }

    #[cfg(feature = "link_static")] pub use OptionTaskBarIconCrossCrateImpl as OptionTaskBarIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTaskBarIconCrossCrateImpl { type Target = AzOptionTaskBarIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTaskBarIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionHwndHandle` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionHwndHandle as OptionHwndHandle;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionHwndHandleCrossCrateImpl { pub _0: azul::AzOptionHwndHandle }

    #[cfg(feature = "link_static")] pub use OptionHwndHandleCrossCrateImpl as OptionHwndHandle;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionHwndHandleCrossCrateImpl { type Target = AzOptionHwndHandle; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionHwndHandleCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionLogicalPosition` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionLogicalPosition as OptionLogicalPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionLogicalPositionCrossCrateImpl { pub _0: azul::AzOptionLogicalPosition }

    #[cfg(feature = "link_static")] pub use OptionLogicalPositionCrossCrateImpl as OptionLogicalPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionLogicalPositionCrossCrateImpl { type Target = AzOptionLogicalPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionLogicalPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionPhysicalPositionI32` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionPhysicalPositionI32 as OptionPhysicalPositionI32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionPhysicalPositionI32CrossCrateImpl { pub _0: azul::AzOptionPhysicalPositionI32 }

    #[cfg(feature = "link_static")] pub use OptionPhysicalPositionI32CrossCrateImpl as OptionPhysicalPositionI32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionPhysicalPositionI32CrossCrateImpl { type Target = AzOptionPhysicalPositionI32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionPhysicalPositionI32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionWindowIcon` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionWindowIcon as OptionWindowIcon;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionWindowIconCrossCrateImpl { pub _0: azul::AzOptionWindowIcon }

    #[cfg(feature = "link_static")] pub use OptionWindowIconCrossCrateImpl as OptionWindowIcon;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionWindowIconCrossCrateImpl { type Target = AzOptionWindowIcon; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionWindowIconCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionString` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionString as OptionString;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionStringCrossCrateImpl { pub _0: azul::AzOptionString }

    #[cfg(feature = "link_static")] pub use OptionStringCrossCrateImpl as OptionString;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionStringCrossCrateImpl { type Target = AzOptionString; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionStringCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionX11Visual` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionX11Visual as OptionX11Visual;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionX11VisualCrossCrateImpl { pub _0: azul::AzOptionX11Visual }

    #[cfg(feature = "link_static")] pub use OptionX11VisualCrossCrateImpl as OptionX11Visual;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionX11VisualCrossCrateImpl { type Target = AzOptionX11Visual; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionX11VisualCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionI32` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionI32 as OptionI32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionI32CrossCrateImpl { pub _0: azul::AzOptionI32 }

    #[cfg(feature = "link_static")] pub use OptionI32CrossCrateImpl as OptionI32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionI32CrossCrateImpl { type Target = AzOptionI32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionI32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionF32` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionF32 as OptionF32;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionF32CrossCrateImpl { pub _0: azul::AzOptionF32 }

    #[cfg(feature = "link_static")] pub use OptionF32CrossCrateImpl as OptionF32;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionF32CrossCrateImpl { type Target = AzOptionF32; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionF32CrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionMouseCursorType` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionMouseCursorType as OptionMouseCursorType;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionMouseCursorTypeCrossCrateImpl { pub _0: azul::AzOptionMouseCursorType }

    #[cfg(feature = "link_static")] pub use OptionMouseCursorTypeCrossCrateImpl as OptionMouseCursorType;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionMouseCursorTypeCrossCrateImpl { type Target = AzOptionMouseCursorType; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionMouseCursorTypeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionLogicalSize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionLogicalSize as OptionLogicalSize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionLogicalSizeCrossCrateImpl { pub _0: azul::AzOptionLogicalSize }

    #[cfg(feature = "link_static")] pub use OptionLogicalSizeCrossCrateImpl as OptionLogicalSize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionLogicalSizeCrossCrateImpl { type Target = AzOptionLogicalSize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionLogicalSizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// Option<char> but the char is a u32, for C FFI stability reasons
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionChar as OptionChar;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionCharCrossCrateImpl { pub _0: azul::AzOptionChar }

    #[cfg(feature = "link_static")] pub use OptionCharCrossCrateImpl as OptionChar;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionCharCrossCrateImpl { type Target = AzOptionChar; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionCharCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionVirtualKeyCode` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionVirtualKeyCode as OptionVirtualKeyCode;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionVirtualKeyCodeCrossCrateImpl { pub _0: azul::AzOptionVirtualKeyCode }

    #[cfg(feature = "link_static")] pub use OptionVirtualKeyCodeCrossCrateImpl as OptionVirtualKeyCode;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionVirtualKeyCodeCrossCrateImpl { type Target = AzOptionVirtualKeyCode; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionVirtualKeyCodeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionDom` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionDom as OptionDom;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionDomCrossCrateImpl { pub _0: azul::AzOptionDom }

    #[cfg(feature = "link_static")] pub use OptionDomCrossCrateImpl as OptionDom;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionDomCrossCrateImpl { type Target = AzOptionDom; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionDomCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTexture` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTexture as OptionTexture;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTextureCrossCrateImpl { pub _0: azul::AzOptionTexture }

    #[cfg(feature = "link_static")] pub use OptionTextureCrossCrateImpl as OptionTexture;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTextureCrossCrateImpl { type Target = AzOptionTexture; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTextureCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionImageMask` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionImageMask as OptionImageMask;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionImageMaskCrossCrateImpl { pub _0: azul::AzOptionImageMask }

    #[cfg(feature = "link_static")] pub use OptionImageMaskCrossCrateImpl as OptionImageMask;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionImageMaskCrossCrateImpl { type Target = AzOptionImageMask; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionImageMaskCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTabIndex` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTabIndex as OptionTabIndex;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTabIndexCrossCrateImpl { pub _0: azul::AzOptionTabIndex }

    #[cfg(feature = "link_static")] pub use OptionTabIndexCrossCrateImpl as OptionTabIndex;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTabIndexCrossCrateImpl { type Target = AzOptionTabIndex; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTabIndexCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionTagId` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionTagId as OptionTagId;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionTagIdCrossCrateImpl { pub _0: azul::AzOptionTagId }

    #[cfg(feature = "link_static")] pub use OptionTagIdCrossCrateImpl as OptionTagId;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionTagIdCrossCrateImpl { type Target = AzOptionTagId; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionTagIdCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionDuration` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionDuration as OptionDuration;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionDurationCrossCrateImpl { pub _0: azul::AzOptionDuration }

    #[cfg(feature = "link_static")] pub use OptionDurationCrossCrateImpl as OptionDuration;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionDurationCrossCrateImpl { type Target = AzOptionDuration; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionDurationCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionInstant` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionInstant as OptionInstant;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionInstantCrossCrateImpl { pub _0: azul::AzOptionInstant }

    #[cfg(feature = "link_static")] pub use OptionInstantCrossCrateImpl as OptionInstant;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionInstantCrossCrateImpl { type Target = AzOptionInstant; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionInstantCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionUsize` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionUsize as OptionUsize;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionUsizeCrossCrateImpl { pub _0: azul::AzOptionUsize }

    #[cfg(feature = "link_static")] pub use OptionUsizeCrossCrateImpl as OptionUsize;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionUsizeCrossCrateImpl { type Target = AzOptionUsize; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionUsizeCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionU8Vec` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionU8Vec as OptionU8Vec;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionU8VecCrossCrateImpl { pub _0: azul::AzOptionU8Vec }

    #[cfg(feature = "link_static")] pub use OptionU8VecCrossCrateImpl as OptionU8Vec;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionU8VecCrossCrateImpl { type Target = AzOptionU8Vec; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionU8VecCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `OptionU8VecRef` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzOptionU8VecRef as OptionU8VecRef;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct OptionU8VecRefCrossCrateImpl { pub _0: azul::AzOptionU8VecRef }

    #[cfg(feature = "link_static")] pub use OptionU8VecRefCrossCrateImpl as OptionU8VecRef;

    #[cfg(feature = "link_static")] impl core::ops::Deref for OptionU8VecRefCrossCrateImpl { type Target = AzOptionU8VecRef; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for OptionU8VecRefCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

pub mod error {
    #![allow(dead_code, unused_imports)]
    //! Definition of error and `Result<T, E>`  types
    #[cfg(not(feature = "link_static"))]
    use crate::dll::*;
    #[cfg(feature = "link_static")]
    use azul::*;
    use core::ffi::c_void;
    /// `ResultXmlXmlError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResultXmlXmlError as ResultXmlXmlError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResultXmlXmlErrorCrossCrateImpl { pub _0: azul::AzResultXmlXmlError }

    #[cfg(feature = "link_static")] pub use ResultXmlXmlErrorCrossCrateImpl as ResultXmlXmlError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResultXmlXmlErrorCrossCrateImpl { type Target = AzResultXmlXmlError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResultXmlXmlErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ResultRawImageDecodeImageError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResultRawImageDecodeImageError as ResultRawImageDecodeImageError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResultRawImageDecodeImageErrorCrossCrateImpl { pub _0: azul::AzResultRawImageDecodeImageError }

    #[cfg(feature = "link_static")] pub use ResultRawImageDecodeImageErrorCrossCrateImpl as ResultRawImageDecodeImageError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResultRawImageDecodeImageErrorCrossCrateImpl { type Target = AzResultRawImageDecodeImageError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResultRawImageDecodeImageErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ResultU8VecEncodeImageError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResultU8VecEncodeImageError as ResultU8VecEncodeImageError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResultU8VecEncodeImageErrorCrossCrateImpl { pub _0: azul::AzResultU8VecEncodeImageError }

    #[cfg(feature = "link_static")] pub use ResultU8VecEncodeImageErrorCrossCrateImpl as ResultU8VecEncodeImageError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResultU8VecEncodeImageErrorCrossCrateImpl { type Target = AzResultU8VecEncodeImageError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResultU8VecEncodeImageErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ResultSvgXmlNodeSvgParseError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResultSvgXmlNodeSvgParseError as ResultSvgXmlNodeSvgParseError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResultSvgXmlNodeSvgParseErrorCrossCrateImpl { pub _0: azul::AzResultSvgXmlNodeSvgParseError }

    #[cfg(feature = "link_static")] pub use ResultSvgXmlNodeSvgParseErrorCrossCrateImpl as ResultSvgXmlNodeSvgParseError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResultSvgXmlNodeSvgParseErrorCrossCrateImpl { type Target = AzResultSvgXmlNodeSvgParseError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResultSvgXmlNodeSvgParseErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `ResultSvgSvgParseError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzResultSvgSvgParseError as ResultSvgSvgParseError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct ResultSvgSvgParseErrorCrossCrateImpl { pub _0: azul::AzResultSvgSvgParseError }

    #[cfg(feature = "link_static")] pub use ResultSvgSvgParseErrorCrossCrateImpl as ResultSvgSvgParseError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for ResultSvgSvgParseErrorCrossCrateImpl { type Target = AzResultSvgSvgParseError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for ResultSvgSvgParseErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgParseError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgParseError as SvgParseError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgParseErrorCrossCrateImpl { pub _0: azul::AzSvgParseError }

    #[cfg(feature = "link_static")] pub use SvgParseErrorCrossCrateImpl as SvgParseError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgParseErrorCrossCrateImpl { type Target = AzSvgParseError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgParseErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlError as XmlError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlErrorCrossCrateImpl { pub _0: azul::AzXmlError }

    #[cfg(feature = "link_static")] pub use XmlErrorCrossCrateImpl as XmlError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlErrorCrossCrateImpl { type Target = AzXmlError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DuplicatedNamespaceError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDuplicatedNamespaceError as DuplicatedNamespaceError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DuplicatedNamespaceErrorCrossCrateImpl { pub _0: azul::AzDuplicatedNamespaceError }

    #[cfg(feature = "link_static")] pub use DuplicatedNamespaceErrorCrossCrateImpl as DuplicatedNamespaceError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DuplicatedNamespaceErrorCrossCrateImpl { type Target = AzDuplicatedNamespaceError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DuplicatedNamespaceErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `UnknownNamespaceError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzUnknownNamespaceError as UnknownNamespaceError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct UnknownNamespaceErrorCrossCrateImpl { pub _0: azul::AzUnknownNamespaceError }

    #[cfg(feature = "link_static")] pub use UnknownNamespaceErrorCrossCrateImpl as UnknownNamespaceError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for UnknownNamespaceErrorCrossCrateImpl { type Target = AzUnknownNamespaceError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for UnknownNamespaceErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `UnexpectedCloseTagError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzUnexpectedCloseTagError as UnexpectedCloseTagError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct UnexpectedCloseTagErrorCrossCrateImpl { pub _0: azul::AzUnexpectedCloseTagError }

    #[cfg(feature = "link_static")] pub use UnexpectedCloseTagErrorCrossCrateImpl as UnexpectedCloseTagError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for UnexpectedCloseTagErrorCrossCrateImpl { type Target = AzUnexpectedCloseTagError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for UnexpectedCloseTagErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `UnknownEntityReferenceError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzUnknownEntityReferenceError as UnknownEntityReferenceError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct UnknownEntityReferenceErrorCrossCrateImpl { pub _0: azul::AzUnknownEntityReferenceError }

    #[cfg(feature = "link_static")] pub use UnknownEntityReferenceErrorCrossCrateImpl as UnknownEntityReferenceError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for UnknownEntityReferenceErrorCrossCrateImpl { type Target = AzUnknownEntityReferenceError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for UnknownEntityReferenceErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `DuplicatedAttributeError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzDuplicatedAttributeError as DuplicatedAttributeError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct DuplicatedAttributeErrorCrossCrateImpl { pub _0: azul::AzDuplicatedAttributeError }

    #[cfg(feature = "link_static")] pub use DuplicatedAttributeErrorCrossCrateImpl as DuplicatedAttributeError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for DuplicatedAttributeErrorCrossCrateImpl { type Target = AzDuplicatedAttributeError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for DuplicatedAttributeErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlParseError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlParseError as XmlParseError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlParseErrorCrossCrateImpl { pub _0: azul::AzXmlParseError }

    #[cfg(feature = "link_static")] pub use XmlParseErrorCrossCrateImpl as XmlParseError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlParseErrorCrossCrateImpl { type Target = AzXmlParseError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlParseErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlTextError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlTextError as XmlTextError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlTextErrorCrossCrateImpl { pub _0: azul::AzXmlTextError }

    #[cfg(feature = "link_static")] pub use XmlTextErrorCrossCrateImpl as XmlTextError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlTextErrorCrossCrateImpl { type Target = AzXmlTextError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlTextErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `XmlStreamError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzXmlStreamError as XmlStreamError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct XmlStreamErrorCrossCrateImpl { pub _0: azul::AzXmlStreamError }

    #[cfg(feature = "link_static")] pub use XmlStreamErrorCrossCrateImpl as XmlStreamError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for XmlStreamErrorCrossCrateImpl { type Target = AzXmlStreamError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for XmlStreamErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `NonXmlCharError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzNonXmlCharError as NonXmlCharError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct NonXmlCharErrorCrossCrateImpl { pub _0: azul::AzNonXmlCharError }

    #[cfg(feature = "link_static")] pub use NonXmlCharErrorCrossCrateImpl as NonXmlCharError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for NonXmlCharErrorCrossCrateImpl { type Target = AzNonXmlCharError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for NonXmlCharErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InvalidCharError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInvalidCharError as InvalidCharError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InvalidCharErrorCrossCrateImpl { pub _0: azul::AzInvalidCharError }

    #[cfg(feature = "link_static")] pub use InvalidCharErrorCrossCrateImpl as InvalidCharError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InvalidCharErrorCrossCrateImpl { type Target = AzInvalidCharError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InvalidCharErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InvalidCharMultipleError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInvalidCharMultipleError as InvalidCharMultipleError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InvalidCharMultipleErrorCrossCrateImpl { pub _0: azul::AzInvalidCharMultipleError }

    #[cfg(feature = "link_static")] pub use InvalidCharMultipleErrorCrossCrateImpl as InvalidCharMultipleError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InvalidCharMultipleErrorCrossCrateImpl { type Target = AzInvalidCharMultipleError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InvalidCharMultipleErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InvalidQuoteError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInvalidQuoteError as InvalidQuoteError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InvalidQuoteErrorCrossCrateImpl { pub _0: azul::AzInvalidQuoteError }

    #[cfg(feature = "link_static")] pub use InvalidQuoteErrorCrossCrateImpl as InvalidQuoteError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InvalidQuoteErrorCrossCrateImpl { type Target = AzInvalidQuoteError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InvalidQuoteErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InvalidSpaceError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInvalidSpaceError as InvalidSpaceError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InvalidSpaceErrorCrossCrateImpl { pub _0: azul::AzInvalidSpaceError }

    #[cfg(feature = "link_static")] pub use InvalidSpaceErrorCrossCrateImpl as InvalidSpaceError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InvalidSpaceErrorCrossCrateImpl { type Target = AzInvalidSpaceError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InvalidSpaceErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `InvalidStringError` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzInvalidStringError as InvalidStringError;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct InvalidStringErrorCrossCrateImpl { pub _0: azul::AzInvalidStringError }

    #[cfg(feature = "link_static")] pub use InvalidStringErrorCrossCrateImpl as InvalidStringError;

    #[cfg(feature = "link_static")] impl core::ops::Deref for InvalidStringErrorCrossCrateImpl { type Target = AzInvalidStringError; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for InvalidStringErrorCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
    /// `SvgParseErrorPosition` struct
    
    #[cfg(not(feature = "link_static"))] #[doc(inline)] pub use crate::dll::AzSvgParseErrorPosition as SvgParseErrorPosition;

    #[cfg(feature = "link_static")] #[repr(transparent)]  pub struct SvgParseErrorPositionCrossCrateImpl { pub _0: azul::AzSvgParseErrorPosition }

    #[cfg(feature = "link_static")] pub use SvgParseErrorPositionCrossCrateImpl as SvgParseErrorPosition;

    #[cfg(feature = "link_static")] impl core::ops::Deref for SvgParseErrorPositionCrossCrateImpl { type Target = AzSvgParseErrorPosition; fn deref(&self) -> &Self::Target { &self._0 } }

    #[cfg(feature = "link_static")] impl core::ops::DerefMut for SvgParseErrorPositionCrossCrateImpl { fn deref_mut(&mut self) -> &mut Self::Target { &mut self._0 } }
}

