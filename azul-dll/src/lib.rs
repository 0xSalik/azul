// WARNING: autogenerated code for azul api version 0.1.0


//! Public API for Azul
//!
//! A single function can have multiple implementations depending on whether it is
//! compiled for the Rust-desktop target, the Rust-wasm target or the C API.
//!
//! For now, the crate simply re-exports azul_core and calls the c_api functions

#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico",
)]

#![allow(dead_code)]
#![allow(unused_imports)]

extern crate azul_core;
extern crate azul_css;
extern crate azul_native_style;
#[cfg(target_arch = "wasm32")]
extern crate azul_web;
#[cfg(not(target_arch = "wasm32"))]
extern crate azul_desktop;

use core::ffi::c_void;
use std::path::PathBuf;
use azul_core::{
    dom::Dom,
    callbacks::{RefAny, LayoutInfo, Callback, CallbackInfo, GlCallbackInfo, GlCallbackReturn, IFrameCallbackInfo, IFrameCallbackReturn},
    window::WindowCreateOptions,
    app_resources::{RawImage, RawImageFormat, FontId, TextId, ImageId},
};
use azul_css::Css;
#[cfg(not(target_arch = "wasm32"))]
use azul_desktop::app::{App, AppConfig};
#[cfg(target_arch = "wasm32")]
use azul_web::app::{App, AppConfig};
/// Pointer to rust-allocated `Box<String>` struct
#[no_mangle] #[repr(C)] pub struct AzStringPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_unchecked(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_lossy(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::string::String::from_utf8_lossy(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `String` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_string_delete(ptr: &mut AzStringPtr) { let _ = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`String`>!.
#[no_mangle] #[inline] pub extern "C" fn az_string_shallow_copy(ptr: &AzStringPtr) -> AzStringPtr { AzStringPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzStringPtr` to a `Box<String>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_string_downcast(ptr: AzStringPtr) -> Box<String> { unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) } }
/// (private): Downcasts the `AzStringPtr` to a `&mut Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_refmut<F: FnOnce(&mut Box<String>)>(ptr: &mut AzStringPtr, func: F) { let mut box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzStringPtr` to a `&Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_ref<F: FnOnce(&Box<String>)>(ptr: &mut AzStringPtr, func: F) { let box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `Vec<u8>`
#[no_mangle] #[repr(C)] pub struct AzU8VecPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `Vec<u8>` by **copying** it from a bytes source
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_copy_from(ptr: *const u8, len: usize) -> AzU8VecPtr { let object: Vec<u8> = unsafe { std::slice::from_raw_parts(ptr, len).to_vec() }; AzU8VecPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `U8Vec` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_delete(ptr: &mut AzU8VecPtr) { let _ = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`U8Vec`>!.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_shallow_copy(ptr: &AzU8VecPtr) -> AzU8VecPtr { AzU8VecPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzU8VecPtr` to a `Box<Vec<u8>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_u8_vec_downcast(ptr: AzU8VecPtr) -> Box<Vec<u8>> { unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) } }
/// (private): Downcasts the `AzU8VecPtr` to a `&mut Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_refmut<F: FnOnce(&mut Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let mut box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzU8VecPtr` to a `&Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_ref<F: FnOnce(&Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `PathBuf`
#[no_mangle] #[repr(C)] pub struct AzPathBufPtr { ptr: *mut c_void }
/// Creates a new PathBuf from a String
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_new(path: AzStringPtr) -> AzPathBufPtr { let object: PathBuf = std::path::PathBuf::from(*az_string_downcast(path)); AzPathBufPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `PathBuf` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_delete(ptr: &mut AzPathBufPtr) { let _ = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`PathBuf`>!.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_shallow_copy(ptr: &AzPathBufPtr) -> AzPathBufPtr { AzPathBufPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzPathBufPtr` to a `Box<PathBuf>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_path_buf_downcast(ptr: AzPathBufPtr) -> Box<PathBuf> { unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) } }
/// (private): Downcasts the `AzPathBufPtr` to a `&mut Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_refmut<F: FnOnce(&mut Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let mut box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzPathBufPtr` to a `&Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_ref<F: FnOnce(&Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<AppConfig>` struct
#[no_mangle] #[repr(C)] pub struct AzAppConfigPtr { ptr: *mut c_void }
/// Creates a new AppConfig with default values
#[no_mangle] #[inline] pub extern "C" fn az_app_config_default() -> AzAppConfigPtr { let object: AppConfig = AppConfig::default(); AzAppConfigPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `AppConfig` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_delete(ptr: &mut AzAppConfigPtr) { let _ = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`AppConfig`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_shallow_copy(ptr: &AzAppConfigPtr) -> AzAppConfigPtr { AzAppConfigPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppConfigPtr` to a `Box<AppConfig>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_config_downcast(ptr: AzAppConfigPtr) -> Box<AppConfig> { unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) } }
/// (private): Downcasts the `AzAppConfigPtr` to a `&mut Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_refmut<F: FnOnce(&mut Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let mut box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppConfigPtr` to a `&Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_ref<F: FnOnce(&Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<App>` struct
#[no_mangle] #[repr(C)] pub struct AzAppPtr { ptr: *mut c_void }
/// Creates a new App instance from the given `AppConfig`
#[no_mangle] #[inline] pub extern "C" fn az_app_new(data: AzRefAny, config: AzAppConfigPtr, callback: AzLayoutCallback) -> AzAppPtr { let object: App = App::new(data, *az_app_config_downcast(config), callback).unwrap(); AzAppPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
#[no_mangle] #[inline] pub extern "C" fn az_app_run(app: AzAppPtr, window: AzWindowCreateOptionsPtr) { az_app_downcast(app).run(*az_window_create_options_downcast(window)) }
/// Destructor: Takes ownership of the `App` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_delete(ptr: &mut AzAppPtr) { let _ = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`App`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_shallow_copy(ptr: &AzAppPtr) -> AzAppPtr { AzAppPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppPtr` to a `Box<App>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_downcast(ptr: AzAppPtr) -> Box<App> { unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) } }
/// (private): Downcasts the `AzAppPtr` to a `&mut Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_refmut<F: FnOnce(&mut Box<App>)>(ptr: &mut AzAppPtr, func: F) { let mut box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppPtr` to a `&Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_ref<F: FnOnce(&Box<App>)>(ptr: &mut AzAppPtr, func: F) { let box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// The layout() callback fn
pub type AzLayoutCallback = fn(AzRefAny, AzLayoutInfoPtr) -> AzDomPtr;
pub type AzCallbackReturn = AzUpdateScreen;
/// Callback for responding to window events
pub type AzCallback = fn(AzCallbackInfoPtr) -> AzCallbackReturn;
/// Pointer to rust-allocated `Box<CallbackInfo>` struct
pub type AzCallbackInfoPtrType = azul_core::callbacks::CallbackInfoPtr;
#[no_mangle] pub use AzCallbackInfoPtrType as AzCallbackInfoPtr;
/// Destructor: Takes ownership of the `CallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_callback_info_delete<'a>(ptr: &mut AzCallbackInfoPtr) { let _ = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`CallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_callback_info_shallow_copy<'a>(ptr: &AzCallbackInfoPtr) -> AzCallbackInfoPtr { AzCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `Box<CallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_callback_info_downcast<'a>(ptr: AzCallbackInfoPtr) -> Box<CallbackInfo<'a>> { unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) } }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `&mut Box<CallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<CallbackInfo<'a>>)>(ptr: &mut AzCallbackInfoPtr, func: F) { let mut box_ptr: Box<CallbackInfo<'a>> = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `&Box<CallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_callback_info_downcast_ref<'a, F: FnOnce(&Box<CallbackInfo<'a>>)>(ptr: &mut AzCallbackInfoPtr, func: F) { let box_ptr: Box<CallbackInfo<'a>> = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `UpdateScreen` struct
#[no_mangle] pub type AzUpdateScreen = Option<()>;

/// Re-export of rust-allocated (stack based) `Redraw` struct
#[no_mangle] pub static AzRedraw: AzUpdateScreen = azul_core::callbacks::Redraw;

/// Re-export of rust-allocated (stack based) `DontRedraw` struct
#[no_mangle] pub static AzDontRedraw: AzUpdateScreen = azul_core::callbacks::DontRedraw;

/// Callback for rendering iframes (infinite data structures that have to know how large they are rendered)
pub type AzIFrameCallback = fn(AzIFrameCallbackInfoPtr) -> AzIFrameCallbackReturnPtr;
/// Pointer to rust-allocated `Box<IFrameCallbackInfo>` struct
pub type AzIFrameCallbackInfoPtrType = azul_core::callbacks::IFrameCallbackInfoPtr;
#[no_mangle] pub use AzIFrameCallbackInfoPtrType as AzIFrameCallbackInfoPtr;
/// Destructor: Takes ownership of the `IFrameCallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_info_delete<'a>(ptr: &mut AzIFrameCallbackInfoPtr) { let _ = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`IFrameCallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_info_shallow_copy<'a>(ptr: &AzIFrameCallbackInfoPtr) -> AzIFrameCallbackInfoPtr { AzIFrameCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `Box<IFrameCallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_i_frame_callback_info_downcast<'a>(ptr: AzIFrameCallbackInfoPtr) -> Box<IFrameCallbackInfo<'a>> { unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) } }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `&mut Box<IFrameCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<IFrameCallbackInfo<'a>>)>(ptr: &mut AzIFrameCallbackInfoPtr, func: F) { let mut box_ptr: Box<IFrameCallbackInfo<'a>> = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `&Box<IFrameCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_info_downcast_ref<'a, F: FnOnce(&Box<IFrameCallbackInfo<'a>>)>(ptr: &mut AzIFrameCallbackInfoPtr, func: F) { let box_ptr: Box<IFrameCallbackInfo<'a>> = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<IFrameCallbackReturn>` struct
pub type AzIFrameCallbackReturnPtrType = azul_core::callbacks::IFrameCallbackReturnPtr;
#[no_mangle] pub use AzIFrameCallbackReturnPtrType as AzIFrameCallbackReturnPtr;
/// Destructor: Takes ownership of the `IFrameCallbackReturn` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_return_delete(ptr: &mut AzIFrameCallbackReturnPtr) { let _ = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`IFrameCallbackReturn`>!.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_return_shallow_copy(ptr: &AzIFrameCallbackReturnPtr) -> AzIFrameCallbackReturnPtr { AzIFrameCallbackReturnPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `Box<IFrameCallbackReturn>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_i_frame_callback_return_downcast(ptr: AzIFrameCallbackReturnPtr) -> Box<IFrameCallbackReturn> { unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) } }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `&mut Box<IFrameCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_return_downcast_refmut<F: FnOnce(&mut Box<IFrameCallbackReturn>)>(ptr: &mut AzIFrameCallbackReturnPtr, func: F) { let mut box_ptr: Box<IFrameCallbackReturn> = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `&Box<IFrameCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_return_downcast_ref<F: FnOnce(&Box<IFrameCallbackReturn>)>(ptr: &mut AzIFrameCallbackReturnPtr, func: F) { let box_ptr: Box<IFrameCallbackReturn> = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Callback for rendering to an OpenGL texture
pub type AzGlCallback = fn(AzGlCallbackInfoPtr) -> AzGlCallbackReturnPtr;
/// Pointer to rust-allocated `Box<GlCallbackInfo>` struct
pub type AzGlCallbackInfoPtrType = azul_core::callbacks::GlCallbackInfoPtr;
#[no_mangle] pub use AzGlCallbackInfoPtrType as AzGlCallbackInfoPtr;
/// Destructor: Takes ownership of the `GlCallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_info_delete<'a>(ptr: &mut AzGlCallbackInfoPtr) { let _ = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`GlCallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_info_shallow_copy<'a>(ptr: &AzGlCallbackInfoPtr) -> AzGlCallbackInfoPtr { AzGlCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `Box<GlCallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_gl_callback_info_downcast<'a>(ptr: AzGlCallbackInfoPtr) -> Box<GlCallbackInfo<'a>> { unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) } }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `&mut Box<GlCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<GlCallbackInfo<'a>>)>(ptr: &mut AzGlCallbackInfoPtr, func: F) { let mut box_ptr: Box<GlCallbackInfo<'a>> = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `&Box<GlCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_info_downcast_ref<'a, F: FnOnce(&Box<GlCallbackInfo<'a>>)>(ptr: &mut AzGlCallbackInfoPtr, func: F) { let box_ptr: Box<GlCallbackInfo<'a>> = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<GlCallbackReturn>` struct
pub type AzGlCallbackReturnPtrType = azul_core::callbacks::GlCallbackReturnPtr;
#[no_mangle] pub use AzGlCallbackReturnPtrType as AzGlCallbackReturnPtr;
/// Destructor: Takes ownership of the `GlCallbackReturn` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_return_delete(ptr: &mut AzGlCallbackReturnPtr) { let _ = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`GlCallbackReturn`>!.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_return_shallow_copy(ptr: &AzGlCallbackReturnPtr) -> AzGlCallbackReturnPtr { AzGlCallbackReturnPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `Box<GlCallbackReturn>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_gl_callback_return_downcast(ptr: AzGlCallbackReturnPtr) -> Box<GlCallbackReturn> { unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) } }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `&mut Box<GlCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_return_downcast_refmut<F: FnOnce(&mut Box<GlCallbackReturn>)>(ptr: &mut AzGlCallbackReturnPtr, func: F) { let mut box_ptr: Box<GlCallbackReturn> = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `&Box<GlCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_return_downcast_ref<F: FnOnce(&Box<GlCallbackReturn>)>(ptr: &mut AzGlCallbackReturnPtr, func: F) { let box_ptr: Box<GlCallbackReturn> = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<RefAny>` struct
pub use ::azul_core::callbacks::RefAny as AzRefAny;

/// Creates a new `RefAny` instance
#[no_mangle] pub extern "C" fn az_ref_any_new(ptr: *const u8, len: usize, type_id: u64, type_name: AzStringPtr, custom_destructor: fn(AzRefAny)) -> AzRefAny {
    AzRefAny::new_c(ptr, len, type_id, *az_string_downcast(type_name), custom_destructor)
}
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *const c_void { ptr.get_ptr(len, type_id) }
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_mut_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *mut c_void { ptr.get_mut_ptr(len, type_id) }
/// Creates a new reference of the pointer, pointing to the same object: WARNING: After calling this function you'll have two pointers to the same Box<`RefAny`>!.
#[no_mangle] pub extern "C" fn az_ref_any_shallow_copy(ptr: &AzRefAny) -> AzRefAny { ptr.clone() }
/// Destructor: Takes ownership of the `RefAny` pointer and deletes it.
#[no_mangle] pub extern "C" fn az_ref_any_delete(ptr: &mut AzRefAny) { az_ref_any_core_copy(ptr).drop_c() }
/// Copies the pointer without invoking the destructor
#[no_mangle] pub extern "C" fn az_ref_any_core_copy(ptr: &AzRefAny) -> AzRefAny {
    AzRefAny {
        _internal_ptr: ptr._internal_ptr,
        _internal_len: ptr._internal_len,
        _internal_layout_size: ptr._internal_layout_size,
        _internal_layout_align: ptr._internal_layout_align,
        type_id: ptr.type_id,
        type_name: ptr.type_name.clone(),
        strong_count: ptr.strong_count,
        is_currently_mutable: ptr.is_currently_mutable,
        custom_destructor: ptr.custom_destructor,
    }
}

/// Pointer to rust-allocated `Box<LayoutInfo>` struct
pub type AzLayoutInfoPtrType = azul_core::callbacks::LayoutInfoPtr;
#[no_mangle] pub use AzLayoutInfoPtrType as AzLayoutInfoPtr;
/// Destructor: Takes ownership of the `LayoutInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_delete<'a>(ptr: &mut AzLayoutInfoPtr) { let _ = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`LayoutInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_shallow_copy<'a>(ptr: &AzLayoutInfoPtr) -> AzLayoutInfoPtr { AzLayoutInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `Box<LayoutInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_layout_info_downcast<'a>(ptr: AzLayoutInfoPtr) -> Box<LayoutInfo<'a>> { unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&mut Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_refmut<'a, F: FnOnce(&mut Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let mut box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_ref<'a, F: FnOnce(&Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Css>` struct
#[no_mangle] #[repr(C)] pub struct AzCssPtr { ptr: *mut c_void }
/// Loads the native style for the given operating system
#[no_mangle] #[inline] pub extern "C" fn az_css_native() -> AzCssPtr { let object: Css = azul_native_style::native(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Returns an empty CSS style
#[no_mangle] #[inline] pub extern "C" fn az_css_empty() -> AzCssPtr { let object: Css = Css::empty(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `Css` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_css_delete(ptr: &mut AzCssPtr) { let _ = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Css`>!.
#[no_mangle] #[inline] pub extern "C" fn az_css_shallow_copy(ptr: &AzCssPtr) -> AzCssPtr { AzCssPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCssPtr` to a `Box<Css>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_css_downcast(ptr: AzCssPtr) -> Box<Css> { unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) } }
/// (private): Downcasts the `AzCssPtr` to a `&mut Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_refmut<F: FnOnce(&mut Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let mut box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCssPtr` to a `&Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_ref<F: FnOnce(&Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Dom>` struct
pub type AzDomPtrType = azul_core::dom::DomPtr;
#[no_mangle] pub use AzDomPtrType as AzDomPtr;
/// Creates a new `div` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_div() -> AzDomPtr { let object: Dom = Dom::div(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `body` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_body() -> AzDomPtr { let object: Dom = Dom::body(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
// Creates a new `Dom` instance whose memory is owned by the rust allocator
// Equivalent to the Rust `Dom::label()` constructor.
#[no_mangle] #[inline] pub extern "C" fn az_dom_label(text: AzStringPtr) -> AzDomPtr { let object: Dom = Dom::label(*az_string_downcast(text)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Reparents another `Dom` to be the child node of this `Dom`
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_child(dom: &mut AzDomPtr, child: AzDomPtr) { az_dom_downcast_refmut(dom, |d| { d.add_child(*az_dom_downcast(child)); }) }
/// Same as [`Dom::add_child`](#method.add_child), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_child(mut dom: AzDomPtr, child: AzDomPtr) -> AzDomPtr { az_dom_add_child(&mut dom, child); dom }
/// Destructor: Takes ownership of the `Dom` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_dom_delete(ptr: &mut AzDomPtr) { let _ = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Dom`>!.
#[no_mangle] #[inline] pub extern "C" fn az_dom_shallow_copy(ptr: &AzDomPtr) -> AzDomPtr { AzDomPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzDomPtr` to a `Box<Dom>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_dom_downcast(ptr: AzDomPtr) -> Box<Dom> { unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) } }
/// (private): Downcasts the `AzDomPtr` to a `&mut Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_refmut<F: FnOnce(&mut Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let mut box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzDomPtr` to a `&Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_ref<F: FnOnce(&Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `TextId` struct
pub type AzTextIdType = azul_core::app_resources::TextId;
#[no_mangle] pub use AzTextIdType as AzTextId;
/// Creates a new, unique `TextId`
#[no_mangle] #[inline] pub extern "C" fn az_text_id_new() -> AzTextId { let object: TextId = TextId::new(); object }
/// Destructor: Takes ownership of the `TextId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_text_id_delete(object: &mut AzTextId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_text_id_deep_copy(object: &AzTextId) -> AzTextId { object.clone() }

/// Re-export of rust-allocated (stack based) `ImageId` struct
pub type AzImageIdType = azul_core::app_resources::ImageId;
#[no_mangle] pub use AzImageIdType as AzImageId;
/// Creates a new, unique `ImageId`
#[no_mangle] #[inline] pub extern "C" fn az_image_id_new() -> AzImageId { let object: ImageId = ImageId::new(); object }
/// Destructor: Takes ownership of the `ImageId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_image_id_delete(object: &mut AzImageId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_image_id_deep_copy(object: &AzImageId) -> AzImageId { object.clone() }

/// Re-export of rust-allocated (stack based) `FontId` struct
pub type AzFontIdType = azul_core::app_resources::FontId;
#[no_mangle] pub use AzFontIdType as AzFontId;
/// Creates a new, unique `FontId`
#[no_mangle] #[inline] pub extern "C" fn az_font_id_new() -> AzFontId { let object: FontId = FontId::new(); object }
/// Destructor: Takes ownership of the `FontId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_font_id_delete(object: &mut AzFontId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_font_id_deep_copy(object: &AzFontId) -> AzFontId { object.clone() }

/// Re-export of rust-allocated (stack based) `ImageSource` struct
pub type AzImageSourceType = azul_core::app_resources::ImageSource;
#[no_mangle] pub use AzImageSourceType as AzImageSource;
/// Bytes of the image, encoded in PNG / JPG / etc. format
#[inline] #[no_mangle] pub extern "C" fn az_image_source_embedded(variant_data: AzU8VecPtr) -> AzImageSource { AzImageSource::Embedded(*az_u8_vec_downcast(variant_data)) }
/// References an (encoded!) image as a file from the file system that is loaded when necessary
#[inline] #[no_mangle] pub extern "C" fn az_image_source_file(variant_data: AzPathBufPtr) -> AzImageSource { AzImageSource::File(*az_path_buf_downcast(variant_data)) }
/// References a decoded (!) `RawImage` as the image source
#[inline] #[no_mangle] pub extern "C" fn az_image_source_raw(variant_data: AzRawImagePtr) -> AzImageSource { AzImageSource::Raw(*az_raw_image_downcast(variant_data)) }
/// Destructor: Takes ownership of the `ImageSource` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_image_source_delete(object: &mut AzImageSource) { match object { AzImageSource::Embedded(_) => { }, AzImageSource::File(_) => { }, AzImageSource::Raw(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_image_source_deep_copy(object: &AzImageSource) -> AzImageSource { object.clone() }

/// Re-export of rust-allocated (stack based) `FontSource` struct
pub type AzFontSourceType = azul_core::app_resources::FontSource;
#[no_mangle] pub use AzFontSourceType as AzFontSource;
/// Bytes are the bytes of the font file
#[inline] #[no_mangle] pub extern "C" fn az_font_source_embedded(variant_data: AzU8VecPtr) -> AzFontSource { AzFontSource::Embedded(*az_u8_vec_downcast(variant_data)) }
/// References a font from a file path, which is loaded when necessary
#[inline] #[no_mangle] pub extern "C" fn az_font_source_file(variant_data: AzPathBufPtr) -> AzFontSource { AzFontSource::File(*az_path_buf_downcast(variant_data)) }
/// References a font from from a system font identifier, such as `"Arial"` or `"Helvetica"`
#[inline] #[no_mangle] pub extern "C" fn az_font_source_system(variant_data: AzStringPtr) -> AzFontSource { AzFontSource::System(*az_string_downcast(variant_data)) }
/// Destructor: Takes ownership of the `FontSource` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_font_source_delete(object: &mut AzFontSource) { match object { AzFontSource::Embedded(_) => { }, AzFontSource::File(_) => { }, AzFontSource::System(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_font_source_deep_copy(object: &AzFontSource) -> AzFontSource { object.clone() }

/// Pointer to rust-allocated `Box<RawImage>` struct
#[no_mangle] #[repr(C)] pub struct AzRawImagePtr { ptr: *mut c_void }
/// Creates a new `RawImage` by loading the decoded bytes
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_new(decoded_pixels: AzU8VecPtr, width: usize, height: usize, data_format: AzRawImageFormat) -> AzRawImagePtr { let object: RawImage = RawImage { pixels: *az_u8_vec_downcast(decoded_pixels), image_dimensions: (width, height), data_format }; AzRawImagePtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `RawImage` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_delete(ptr: &mut AzRawImagePtr) { let _ = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`RawImage`>!.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_shallow_copy(ptr: &AzRawImagePtr) -> AzRawImagePtr { AzRawImagePtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzRawImagePtr` to a `Box<RawImage>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_raw_image_downcast(ptr: AzRawImagePtr) -> Box<RawImage> { unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) } }
/// (private): Downcasts the `AzRawImagePtr` to a `&mut Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_refmut<F: FnOnce(&mut Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let mut box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzRawImagePtr` to a `&Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_ref<F: FnOnce(&Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `RawImageFormat` struct
pub type AzRawImageFormatType = azul_core::app_resources::RawImageFormat;
#[no_mangle] pub use AzRawImageFormatType as AzRawImageFormat;
/// Bytes are in the R-unsinged-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_r8() -> AzRawImageFormat { AzRawImageFormat::R8 }
/// Bytes are in the R-unsinged-16bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_r16() -> AzRawImageFormat { AzRawImageFormat::R16 }
/// Bytes are in the RG-unsinged-16bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rg16() -> AzRawImageFormat { AzRawImageFormat::RG16 }
/// Bytes are in the BRGA-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_bgra8() -> AzRawImageFormat { AzRawImageFormat::BGRA8 }
/// Bytes are in the RGBA-floating-point-32bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgbaf32() -> AzRawImageFormat { AzRawImageFormat::RGBAF32 }
/// Bytes are in the RG-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rg8() -> AzRawImageFormat { AzRawImageFormat::RG8 }
/// Bytes are in the RGBA-signed-32bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgbai32() -> AzRawImageFormat { AzRawImageFormat::RGBAI32 }
/// Bytes are in the RGBA-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgba8() -> AzRawImageFormat { AzRawImageFormat::RGBA8 }
/// Destructor: Takes ownership of the `RawImageFormat` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_raw_image_format_delete(object: &mut AzRawImageFormat) { match object { AzRawImageFormat::R8 => { }, AzRawImageFormat::R16 => { }, AzRawImageFormat::RG16 => { }, AzRawImageFormat::BGRA8 => { }, AzRawImageFormat::RGBAF32 => { }, AzRawImageFormat::RG8 => { }, AzRawImageFormat::RGBAI32 => { }, AzRawImageFormat::RGBA8 => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_format_deep_copy(object: &AzRawImageFormat) -> AzRawImageFormat { object.clone() }

/// Pointer to rust-allocated `Box<WindowCreateOptions>` struct
#[no_mangle] #[repr(C)] pub struct AzWindowCreateOptionsPtr { ptr: *mut c_void }
// Creates a new `WindowCreateOptions` instance whose memory is owned by the rust allocator
// Equivalent to the Rust `WindowCreateOptions::new()` constructor.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_new(css: AzCssPtr) -> AzWindowCreateOptionsPtr { let object: WindowCreateOptions = WindowCreateOptions::new(*az_css_downcast(css)); AzWindowCreateOptionsPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `WindowCreateOptions` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_delete(ptr: &mut AzWindowCreateOptionsPtr) { let _ = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`WindowCreateOptions`>!.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_shallow_copy(ptr: &AzWindowCreateOptionsPtr) -> AzWindowCreateOptionsPtr { AzWindowCreateOptionsPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `Box<WindowCreateOptions>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_window_create_options_downcast(ptr: AzWindowCreateOptionsPtr) -> Box<WindowCreateOptions> { unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&mut Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_refmut<F: FnOnce(&mut Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let mut box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_ref<F: FnOnce(&Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
