// WARNING: autogenerated code for azul api version 0.1.0


//! Public API for Azul
//!
//! A single function can have multiple implementations depending on whether it is
//! compiled for the Rust-desktop target, the Rust-wasm target or the C API.
//!
//! For now, the crate simply re-exports azul_core and calls the c_api functions

#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico",
)]

#![allow(dead_code)]
#![allow(unused_imports)]

extern crate azul_core;
extern crate azul_css;
extern crate azul_native_style;
#[cfg(target_arch = "wasm32")]
extern crate azul_web;
#[cfg(not(target_arch = "wasm32"))]
extern crate azul_desktop;

use core::ffi::c_void;
use std::path::PathBuf;
use azul_core::{
    dom::Dom,
    callbacks::{RefAny, LayoutInfo},
    window::WindowCreateOptions,
    app_resources::*,
};
use azul_css::Css;
#[cfg(not(target_arch = "wasm32"))]
use azul_desktop::app::{App, AppConfig};
#[cfg(target_arch = "wasm32")]
use azul_web::app::{App, AppConfig};
/// Pointer to rust-allocated `Box<String>` struct
#[no_mangle] #[repr(C)] pub struct AzStringPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_unchecked(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_lossy(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::string::String::from_utf8_lossy(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `String` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_string_delete(ptr: &mut AzStringPtr) { let _ = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`String`>!.
#[no_mangle] #[inline] pub extern "C" fn az_string_shallow_copy(ptr: &AzStringPtr) -> AzStringPtr { AzStringPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzStringPtr` to a `Box<String>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_string_downcast(ptr: AzStringPtr) -> Box<String> { unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) } }
/// (private): Downcasts the `AzStringPtr` to a `&mut Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_refmut<F: FnOnce(&mut Box<String>)>(ptr: &mut AzStringPtr, func: F) { let mut box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzStringPtr` to a `&Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_ref<F: FnOnce(&Box<String>)>(ptr: &mut AzStringPtr, func: F) { let box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `Vec<u8>`
#[no_mangle] #[repr(C)] pub struct AzU8VecPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `Vec<u8>` by **copying** it from a bytes source
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_copy_from(ptr: *const u8, len: usize) -> AzU8VecPtr { let object: U8Vec = std::slice::from_raw_parts(ptr, len).to_vec(); AzU8VecPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `U8Vec` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_delete(ptr: &mut AzU8VecPtr) { let _ = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`U8Vec`>!.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_shallow_copy(ptr: &AzU8VecPtr) -> AzU8VecPtr { AzU8VecPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzU8VecPtr` to a `Box<Vec<u8>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_u8_vec_downcast(ptr: AzU8VecPtr) -> Box<Vec<u8>> { unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) } }
/// (private): Downcasts the `AzU8VecPtr` to a `&mut Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_refmut<F: FnOnce(&mut Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let mut box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzU8VecPtr` to a `&Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_ref<F: FnOnce(&Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `PathBuf`
#[no_mangle] #[repr(C)] pub struct AzPathBufPtr { ptr: *mut c_void }
/// Creates a new PathBuf from a String
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_new(path: AzStringPtr) -> AzPathBufPtr { let object: PathBuf = std::path::PathBuf::from(*az_string_downcast(path)); AzPathBufPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `PathBuf` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_delete(ptr: &mut AzPathBufPtr) { let _ = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`PathBuf`>!.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_shallow_copy(ptr: &AzPathBufPtr) -> AzPathBufPtr { AzPathBufPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzPathBufPtr` to a `Box<PathBuf>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_path_buf_downcast(ptr: AzPathBufPtr) -> Box<PathBuf> { unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) } }
/// (private): Downcasts the `AzPathBufPtr` to a `&mut Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_refmut<F: FnOnce(&mut Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let mut box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzPathBufPtr` to a `&Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_ref<F: FnOnce(&Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<AppConfig>` struct
#[no_mangle] #[repr(C)] pub struct AzAppConfigPtr { ptr: *mut c_void }
/// Creates a new AppConfig with default values
#[no_mangle] #[inline] pub extern "C" fn az_app_config_default() -> AzAppConfigPtr { let object: AppConfig = AppConfig::default(); AzAppConfigPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `AppConfig` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_delete(ptr: &mut AzAppConfigPtr) { let _ = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`AppConfig`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_shallow_copy(ptr: &AzAppConfigPtr) -> AzAppConfigPtr { AzAppConfigPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppConfigPtr` to a `Box<AppConfig>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_config_downcast(ptr: AzAppConfigPtr) -> Box<AppConfig> { unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) } }
/// (private): Downcasts the `AzAppConfigPtr` to a `&mut Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_refmut<F: FnOnce(&mut Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let mut box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppConfigPtr` to a `&Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_ref<F: FnOnce(&Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<App>` struct
#[no_mangle] #[repr(C)] pub struct AzAppPtr { ptr: *mut c_void }
/// Creates a new App instance from the given `AppConfig`
#[no_mangle] #[inline] pub extern "C" fn az_app_new(data: AzRefAny, config: AzAppConfigPtr, callback: AzLayoutCallback) -> AzAppPtr { let object: App = App::new(data, *az_app_config_downcast(config), callback).unwrap(); AzAppPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
#[no_mangle] #[inline] pub extern "C" fn az_app_run(app: AzAppPtr, window: AzWindowCreateOptionsPtr) { az_app_downcast(app).run(*az_window_create_options_downcast(window)) }
/// Destructor: Takes ownership of the `App` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_delete(ptr: &mut AzAppPtr) { let _ = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`App`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_shallow_copy(ptr: &AzAppPtr) -> AzAppPtr { AzAppPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppPtr` to a `Box<App>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_downcast(ptr: AzAppPtr) -> Box<App> { unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) } }
/// (private): Downcasts the `AzAppPtr` to a `&mut Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_refmut<F: FnOnce(&mut Box<App>)>(ptr: &mut AzAppPtr, func: F) { let mut box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppPtr` to a `&Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_ref<F: FnOnce(&Box<App>)>(ptr: &mut AzAppPtr, func: F) { let box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// The layout() callback fn
pub type AzLayoutCallback = fn(AzRefAny, AzLayoutInfoPtr) -> AzDomPtr;
/// Pointer to rust-allocated `Box<RefAny>` struct
pub use ::azul_core::callbacks::RefAny as AzRefAny;

/// Creates a new `RefAny` instance
#[no_mangle] pub extern "C" fn az_ref_any_new(ptr: *const u8, len: usize, type_id: u64, type_name: AzStringPtr, custom_destructor: fn(AzRefAny)) -> AzRefAny {
    AzRefAny::new_c(ptr, len, type_id, *az_string_downcast(type_name), custom_destructor)
}
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *const c_void { ptr.get_ptr(len, type_id) }
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_mut_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *mut c_void { ptr.get_mut_ptr(len, type_id) }
/// Creates a new reference of the pointer, pointing to the same object: WARNING: After calling this function you'll have two pointers to the same Box<`RefAny`>!.
#[no_mangle] pub extern "C" fn az_ref_any_shallow_copy(ptr: &AzRefAny) -> AzRefAny { ptr.clone() }
/// Destructor: Takes ownership of the `RefAny` pointer and deletes it.
#[no_mangle] pub extern "C" fn az_ref_any_delete(ptr: &mut AzRefAny) { az_ref_any_core_copy(ptr).drop_c() }
/// Copies the pointer without invoking the destructor
#[no_mangle] pub extern "C" fn az_ref_any_core_copy(ptr: &AzRefAny) -> AzRefAny {
    AzRefAny {
        _internal_ptr: ptr._internal_ptr,
        _internal_len: ptr._internal_len,
        _internal_layout_size: ptr._internal_layout_size,
        _internal_layout_align: ptr._internal_layout_align,
        type_id: ptr.type_id,
        type_name: ptr.type_name.clone(),
        strong_count: ptr.strong_count,
        is_currently_mutable: ptr.is_currently_mutable,
        custom_destructor: ptr.custom_destructor,
    }
}

/// Pointer to rust-allocated `Box<LayoutInfo>` struct
pub use ::azul_core::callbacks::LayoutInfoPtr as AzLayoutInfoPtr;
/// Destructor: Takes ownership of the `LayoutInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_delete<'a>(ptr: &mut AzLayoutInfoPtr) { let _ = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`LayoutInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_shallow_copy<'a>(ptr: &AzLayoutInfoPtr) -> AzLayoutInfoPtr { AzLayoutInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `Box<LayoutInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_layout_info_downcast<'a>(ptr: AzLayoutInfoPtr) -> Box<LayoutInfo<'a>> { unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&mut Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_refmut<'a, F: FnOnce(&mut Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let mut box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_ref<'a, F: FnOnce(&Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Css>` struct
#[no_mangle] #[repr(C)] pub struct AzCssPtr { ptr: *mut c_void }
/// Loads the native style for the given operating system
#[no_mangle] #[inline] pub extern "C" fn az_css_native() -> AzCssPtr { let object: Css = azul_native_style::native(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Returns an empty CSS style
#[no_mangle] #[inline] pub extern "C" fn az_css_empty() -> AzCssPtr { let object: Css = Css::empty(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `Css` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_css_delete(ptr: &mut AzCssPtr) { let _ = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Css`>!.
#[no_mangle] #[inline] pub extern "C" fn az_css_shallow_copy(ptr: &AzCssPtr) -> AzCssPtr { AzCssPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCssPtr` to a `Box<Css>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_css_downcast(ptr: AzCssPtr) -> Box<Css> { unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) } }
/// (private): Downcasts the `AzCssPtr` to a `&mut Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_refmut<F: FnOnce(&mut Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let mut box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCssPtr` to a `&Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_ref<F: FnOnce(&Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Dom>` struct
pub use ::azul_core::dom::DomPtr as AzDomPtr;
/// Creates a new `div` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_div() -> AzDomPtr { let object: Dom = Dom::div(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `body` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_body() -> AzDomPtr { let object: Dom = Dom::body(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
// Creates a new `Dom` instance whose memory is owned by the rust allocator
// Equivalent to the Rust `Dom::label()` constructor.
#[no_mangle] #[inline] pub extern "C" fn az_dom_label(text: AzStringPtr) -> AzDomPtr { let object: Dom = Dom::label(*az_string_downcast(text)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Reparents another `Dom` to be the child node of this `Dom`
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_child(dom: &mut AzDomPtr, child: AzDomPtr) { az_dom_downcast_refmut(dom, |d| { d.add_child(*az_dom_downcast(child)); }) }
/// Same as [`Dom::add_child`](#method.add_child), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_child(mut dom: AzDomPtr, child: AzDomPtr) -> AzDomPtr { az_dom_add_child(&mut dom, child); dom }
/// Destructor: Takes ownership of the `Dom` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_dom_delete(ptr: &mut AzDomPtr) { let _ = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Dom`>!.
#[no_mangle] #[inline] pub extern "C" fn az_dom_shallow_copy(ptr: &AzDomPtr) -> AzDomPtr { AzDomPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzDomPtr` to a `Box<Dom>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_dom_downcast(ptr: AzDomPtr) -> Box<Dom> { unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) } }
/// (private): Downcasts the `AzDomPtr` to a `&mut Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_refmut<F: FnOnce(&mut Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let mut box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzDomPtr` to a `&Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_ref<F: FnOnce(&Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<TextId>` struct
pub use ::azul_core::app_resources::TextId as AzTextIdPtr;
/// Creates a new, unique `TextId`
#[no_mangle] #[inline] pub extern "C" fn az_text_id_new() -> AzTextIdPtr { let object: TextId = TextId::new(); AzTextIdPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `TextId` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_text_id_delete(ptr: &mut AzTextIdPtr) { let _ = unsafe { Box::<TextId>::from_raw(ptr.ptr  as *mut TextId) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`TextId`>!.
#[no_mangle] #[inline] pub extern "C" fn az_text_id_shallow_copy(ptr: &AzTextIdPtr) -> AzTextIdPtr { AzTextIdPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzTextIdPtr` to a `Box<TextId>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_text_id_downcast(ptr: AzTextIdPtr) -> Box<TextId> { unsafe { Box::<TextId>::from_raw(ptr.ptr  as *mut TextId) } }
/// (private): Downcasts the `AzTextIdPtr` to a `&mut Box<TextId>` and runs the `func` closure on it
#[inline(always)] fn az_text_id_downcast_refmut<F: FnOnce(&mut Box<TextId>)>(ptr: &mut AzTextIdPtr, func: F) { let mut box_ptr: Box<TextId> = unsafe { Box::<TextId>::from_raw(ptr.ptr  as *mut TextId) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzTextIdPtr` to a `&Box<TextId>` and runs the `func` closure on it
#[inline(always)] fn az_text_id_downcast_ref<F: FnOnce(&Box<TextId>)>(ptr: &mut AzTextIdPtr, func: F) { let box_ptr: Box<TextId> = unsafe { Box::<TextId>::from_raw(ptr.ptr  as *mut TextId) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<ImageId>` struct
pub use ::azul_core::app_resources::ImageId as AzImageIdPtr;
/// Creates a new, unique `ImageId`
#[no_mangle] #[inline] pub extern "C" fn az_image_id_new() -> AzImageIdPtr { let object: ImageId = ImageId::new(); AzImageIdPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `ImageId` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_image_id_delete(ptr: &mut AzImageIdPtr) { let _ = unsafe { Box::<ImageId>::from_raw(ptr.ptr  as *mut ImageId) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`ImageId`>!.
#[no_mangle] #[inline] pub extern "C" fn az_image_id_shallow_copy(ptr: &AzImageIdPtr) -> AzImageIdPtr { AzImageIdPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzImageIdPtr` to a `Box<ImageId>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_image_id_downcast(ptr: AzImageIdPtr) -> Box<ImageId> { unsafe { Box::<ImageId>::from_raw(ptr.ptr  as *mut ImageId) } }
/// (private): Downcasts the `AzImageIdPtr` to a `&mut Box<ImageId>` and runs the `func` closure on it
#[inline(always)] fn az_image_id_downcast_refmut<F: FnOnce(&mut Box<ImageId>)>(ptr: &mut AzImageIdPtr, func: F) { let mut box_ptr: Box<ImageId> = unsafe { Box::<ImageId>::from_raw(ptr.ptr  as *mut ImageId) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzImageIdPtr` to a `&Box<ImageId>` and runs the `func` closure on it
#[inline(always)] fn az_image_id_downcast_ref<F: FnOnce(&Box<ImageId>)>(ptr: &mut AzImageIdPtr, func: F) { let box_ptr: Box<ImageId> = unsafe { Box::<ImageId>::from_raw(ptr.ptr  as *mut ImageId) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<FontId>` struct
pub use ::azul_core::app_resources::FontId as AzFontIdPtr;
/// Creates a new, unique `FontId`
#[no_mangle] #[inline] pub extern "C" fn az_font_id_new() -> AzFontIdPtr { let object: FontId = FontId::new(); AzFontIdPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `FontId` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_font_id_delete(ptr: &mut AzFontIdPtr) { let _ = unsafe { Box::<FontId>::from_raw(ptr.ptr  as *mut FontId) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`FontId`>!.
#[no_mangle] #[inline] pub extern "C" fn az_font_id_shallow_copy(ptr: &AzFontIdPtr) -> AzFontIdPtr { AzFontIdPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzFontIdPtr` to a `Box<FontId>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_font_id_downcast(ptr: AzFontIdPtr) -> Box<FontId> { unsafe { Box::<FontId>::from_raw(ptr.ptr  as *mut FontId) } }
/// (private): Downcasts the `AzFontIdPtr` to a `&mut Box<FontId>` and runs the `func` closure on it
#[inline(always)] fn az_font_id_downcast_refmut<F: FnOnce(&mut Box<FontId>)>(ptr: &mut AzFontIdPtr, func: F) { let mut box_ptr: Box<FontId> = unsafe { Box::<FontId>::from_raw(ptr.ptr  as *mut FontId) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzFontIdPtr` to a `&Box<FontId>` and runs the `func` closure on it
#[inline(always)] fn az_font_id_downcast_ref<F: FnOnce(&Box<FontId>)>(ptr: &mut AzFontIdPtr, func: F) { let box_ptr: Box<FontId> = unsafe { Box::<FontId>::from_raw(ptr.ptr  as *mut FontId) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<ImageSource>` struct
pub use ::azul_core::app_resources::ImageSource as AzImageSourcePtr;
/// Destructor: Takes ownership of the `ImageSource` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_image_source_delete(ptr: &mut AzImageSourcePtr) { let _ = unsafe { Box::<ImageSource>::from_raw(ptr.ptr  as *mut ImageSource) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`ImageSource`>!.
#[no_mangle] #[inline] pub extern "C" fn az_image_source_shallow_copy(ptr: &AzImageSourcePtr) -> AzImageSourcePtr { AzImageSourcePtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzImageSourcePtr` to a `Box<ImageSource>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_image_source_downcast(ptr: AzImageSourcePtr) -> Box<ImageSource> { unsafe { Box::<ImageSource>::from_raw(ptr.ptr  as *mut ImageSource) } }
/// (private): Downcasts the `AzImageSourcePtr` to a `&mut Box<ImageSource>` and runs the `func` closure on it
#[inline(always)] fn az_image_source_downcast_refmut<F: FnOnce(&mut Box<ImageSource>)>(ptr: &mut AzImageSourcePtr, func: F) { let mut box_ptr: Box<ImageSource> = unsafe { Box::<ImageSource>::from_raw(ptr.ptr  as *mut ImageSource) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzImageSourcePtr` to a `&Box<ImageSource>` and runs the `func` closure on it
#[inline(always)] fn az_image_source_downcast_ref<F: FnOnce(&Box<ImageSource>)>(ptr: &mut AzImageSourcePtr, func: F) { let box_ptr: Box<ImageSource> = unsafe { Box::<ImageSource>::from_raw(ptr.ptr  as *mut ImageSource) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<FontSource>` struct
pub use ::azul_core::app_resources::FontSource as AzFontSourcePtr;
/// Destructor: Takes ownership of the `FontSource` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_font_source_delete(ptr: &mut AzFontSourcePtr) { let _ = unsafe { Box::<FontSource>::from_raw(ptr.ptr  as *mut FontSource) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`FontSource`>!.
#[no_mangle] #[inline] pub extern "C" fn az_font_source_shallow_copy(ptr: &AzFontSourcePtr) -> AzFontSourcePtr { AzFontSourcePtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzFontSourcePtr` to a `Box<FontSource>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_font_source_downcast(ptr: AzFontSourcePtr) -> Box<FontSource> { unsafe { Box::<FontSource>::from_raw(ptr.ptr  as *mut FontSource) } }
/// (private): Downcasts the `AzFontSourcePtr` to a `&mut Box<FontSource>` and runs the `func` closure on it
#[inline(always)] fn az_font_source_downcast_refmut<F: FnOnce(&mut Box<FontSource>)>(ptr: &mut AzFontSourcePtr, func: F) { let mut box_ptr: Box<FontSource> = unsafe { Box::<FontSource>::from_raw(ptr.ptr  as *mut FontSource) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzFontSourcePtr` to a `&Box<FontSource>` and runs the `func` closure on it
#[inline(always)] fn az_font_source_downcast_ref<F: FnOnce(&Box<FontSource>)>(ptr: &mut AzFontSourcePtr, func: F) { let box_ptr: Box<FontSource> = unsafe { Box::<FontSource>::from_raw(ptr.ptr  as *mut FontSource) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<RawImage>` struct
#[no_mangle] #[repr(C)] pub struct AzRawImagePtr { ptr: *mut c_void }
/// Creates a new `RawImage` by loading the decoded bytes
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_new(decoded_pixels: AzU8VecPtr, width: usize, height: usize, data_format: AzRawImageFormatPtr) -> AzRawImagePtr { let object: RawImage = RawImage { pixels: *az_u8_vec_downcast(decoded_pixels), image_dimensions: (width, height), data_format }; AzRawImagePtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `RawImage` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_delete(ptr: &mut AzRawImagePtr) { let _ = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`RawImage`>!.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_shallow_copy(ptr: &AzRawImagePtr) -> AzRawImagePtr { AzRawImagePtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzRawImagePtr` to a `Box<RawImage>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_raw_image_downcast(ptr: AzRawImagePtr) -> Box<RawImage> { unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) } }
/// (private): Downcasts the `AzRawImagePtr` to a `&mut Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_refmut<F: FnOnce(&mut Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let mut box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzRawImagePtr` to a `&Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_ref<F: FnOnce(&Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<RawImageFormat>` struct
pub use ::azul_core::app_resources::RawImageFormat as AzRawImageFormatPtr;
/// Destructor: Takes ownership of the `RawImageFormat` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_format_delete(ptr: &mut AzRawImageFormatPtr) { let _ = unsafe { Box::<RawImageFormat>::from_raw(ptr.ptr  as *mut RawImageFormat) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`RawImageFormat`>!.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_format_shallow_copy(ptr: &AzRawImageFormatPtr) -> AzRawImageFormatPtr { AzRawImageFormatPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzRawImageFormatPtr` to a `Box<RawImageFormat>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_raw_image_format_downcast(ptr: AzRawImageFormatPtr) -> Box<RawImageFormat> { unsafe { Box::<RawImageFormat>::from_raw(ptr.ptr  as *mut RawImageFormat) } }
/// (private): Downcasts the `AzRawImageFormatPtr` to a `&mut Box<RawImageFormat>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_format_downcast_refmut<F: FnOnce(&mut Box<RawImageFormat>)>(ptr: &mut AzRawImageFormatPtr, func: F) { let mut box_ptr: Box<RawImageFormat> = unsafe { Box::<RawImageFormat>::from_raw(ptr.ptr  as *mut RawImageFormat) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzRawImageFormatPtr` to a `&Box<RawImageFormat>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_format_downcast_ref<F: FnOnce(&Box<RawImageFormat>)>(ptr: &mut AzRawImageFormatPtr, func: F) { let box_ptr: Box<RawImageFormat> = unsafe { Box::<RawImageFormat>::from_raw(ptr.ptr  as *mut RawImageFormat) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<WindowCreateOptions>` struct
#[no_mangle] #[repr(C)] pub struct AzWindowCreateOptionsPtr { ptr: *mut c_void }
// Creates a new `WindowCreateOptions` instance whose memory is owned by the rust allocator
// Equivalent to the Rust `WindowCreateOptions::new()` constructor.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_new(css: AzCssPtr) -> AzWindowCreateOptionsPtr { let object: WindowCreateOptions = WindowCreateOptions::new(*az_css_downcast(css)); AzWindowCreateOptionsPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `WindowCreateOptions` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_delete(ptr: &mut AzWindowCreateOptionsPtr) { let _ = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`WindowCreateOptions`>!.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_shallow_copy(ptr: &AzWindowCreateOptionsPtr) -> AzWindowCreateOptionsPtr { AzWindowCreateOptionsPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `Box<WindowCreateOptions>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_window_create_options_downcast(ptr: AzWindowCreateOptionsPtr) -> Box<WindowCreateOptions> { unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&mut Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_refmut<F: FnOnce(&mut Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let mut box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_ref<F: FnOnce(&Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
