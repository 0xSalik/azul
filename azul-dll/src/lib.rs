// WARNING: autogenerated code for azul api version 0.1.0


//! Public API for Azul
//!
//! A single function can have multiple implementations depending on whether it is
//! compiled for the Rust-desktop target, the Rust-wasm target or the C API.
//!
//! For now, the crate simply re-exports azul_core and calls the c_api functions

#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/azul_logo_full_min.svg.png",
    html_favicon_url = "https://raw.githubusercontent.com/maps4print/azul/master/assets/images/favicon.ico",
)]

#![allow(dead_code)]
#![allow(unused_imports)]

extern crate azul_core;
extern crate azul_css;
extern crate azul_native_style;
#[cfg(target_arch = "wasm32")]
extern crate azul_web;
#[cfg(not(target_arch = "wasm32"))]
extern crate azul_desktop;

use core::ffi::c_void;
use std::path::PathBuf;
use azul_core::{
    dom::Dom,
    callbacks::{RefAny, LayoutInfo, Callback, CallbackInfo, GlCallbackInfo, GlCallbackReturn, IFrameCallbackInfo, IFrameCallbackReturn},
    window::WindowCreateOptions,
    app_resources::{RawImage, RawImageFormat, FontId, TextId, ImageId},
};
use azul_css::Css;
#[cfg(not(target_arch = "wasm32"))]
use azul_desktop::app::{App, AppConfig};
#[cfg(target_arch = "wasm32")]
use azul_web::app::{App, AppConfig};
/// Pointer to rust-allocated `Box<String>` struct
#[no_mangle] #[repr(C)] pub struct AzStringPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_unchecked(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates + allocates a Rust `String` by **copying** it from another utf8-encoded string
#[no_mangle] #[inline] pub extern "C" fn az_string_from_utf8_lossy(ptr: *const u8, len: usize) -> AzStringPtr { let object: String = unsafe { std::string::String::from_utf8_lossy(std::slice::from_raw_parts(ptr, len)).to_string() }; AzStringPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `String` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_string_delete(ptr: &mut AzStringPtr) { let _ = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`String`>!.
#[no_mangle] #[inline] pub extern "C" fn az_string_shallow_copy(ptr: &AzStringPtr) -> AzStringPtr { AzStringPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzStringPtr` to a `Box<String>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_string_downcast(ptr: AzStringPtr) -> Box<String> { unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) } }
/// (private): Downcasts the `AzStringPtr` to a `&mut Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_refmut<F: FnOnce(&mut Box<String>)>(ptr: &mut AzStringPtr, func: F) { let mut box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzStringPtr` to a `&Box<String>` and runs the `func` closure on it
#[inline(always)] fn az_string_downcast_ref<F: FnOnce(&Box<String>)>(ptr: &mut AzStringPtr, func: F) { let box_ptr: Box<String> = unsafe { Box::<String>::from_raw(ptr.ptr  as *mut String) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `Vec<u8>`
#[no_mangle] #[repr(C)] pub struct AzU8VecPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `Vec<u8>` by **copying** it from a bytes source
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_copy_from(ptr: *const u8, len: usize) -> AzU8VecPtr { let object: Vec<u8> = unsafe { std::slice::from_raw_parts(ptr, len).to_vec() }; AzU8VecPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `U8Vec` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_delete(ptr: &mut AzU8VecPtr) { let _ = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`U8Vec`>!.
#[no_mangle] #[inline] pub extern "C" fn az_u8_vec_shallow_copy(ptr: &AzU8VecPtr) -> AzU8VecPtr { AzU8VecPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzU8VecPtr` to a `Box<Vec<u8>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_u8_vec_downcast(ptr: AzU8VecPtr) -> Box<Vec<u8>> { unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) } }
/// (private): Downcasts the `AzU8VecPtr` to a `&mut Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_refmut<F: FnOnce(&mut Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let mut box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzU8VecPtr` to a `&Box<Vec<u8>>` and runs the `func` closure on it
#[inline(always)] fn az_u8_vec_downcast_ref<F: FnOnce(&Box<Vec<u8>>)>(ptr: &mut AzU8VecPtr, func: F) { let box_ptr: Box<Vec<u8>> = unsafe { Box::<Vec<u8>>::from_raw(ptr.ptr  as *mut Vec<u8>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `Vec<String>`
#[no_mangle] #[repr(C)] pub struct AzStringVecPtr { ptr: *mut c_void }
/// Creates + allocates a Rust `Vec<String>` by **copying** it from a bytes source
#[no_mangle] #[inline] pub extern "C" fn az_string_vec_copy_from(ptr: *const AzStringPtr, len: usize) -> AzStringVecPtr { let object: Vec<String> = unsafe { std::slice::from_raw_parts(ptr, len).to_vec() }; AzStringVecPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `StringVec` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_string_vec_delete(ptr: &mut AzStringVecPtr) { let _ = unsafe { Box::<Vec<String>>::from_raw(ptr.ptr  as *mut Vec<String>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`StringVec`>!.
#[no_mangle] #[inline] pub extern "C" fn az_string_vec_shallow_copy(ptr: &AzStringVecPtr) -> AzStringVecPtr { AzStringVecPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzStringVecPtr` to a `Box<Vec<String>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_string_vec_downcast(ptr: AzStringVecPtr) -> Box<Vec<String>> { unsafe { Box::<Vec<String>>::from_raw(ptr.ptr  as *mut Vec<String>) } }
/// (private): Downcasts the `AzStringVecPtr` to a `&mut Box<Vec<String>>` and runs the `func` closure on it
#[inline(always)] fn az_string_vec_downcast_refmut<F: FnOnce(&mut Box<Vec<String>>)>(ptr: &mut AzStringVecPtr, func: F) { let mut box_ptr: Box<Vec<String>> = unsafe { Box::<Vec<String>>::from_raw(ptr.ptr  as *mut Vec<String>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzStringVecPtr` to a `&Box<Vec<String>>` and runs the `func` closure on it
#[inline(always)] fn az_string_vec_downcast_ref<F: FnOnce(&Box<Vec<String>>)>(ptr: &mut AzStringVecPtr, func: F) { let box_ptr: Box<Vec<String>> = unsafe { Box::<Vec<String>>::from_raw(ptr.ptr  as *mut Vec<String>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `PathBuf`
#[no_mangle] #[repr(C)] pub struct AzPathBufPtr { ptr: *mut c_void }
/// Creates a new PathBuf from a String
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_new(path: AzStringPtr) -> AzPathBufPtr { let object: PathBuf = std::path::PathBuf::from(*az_string_downcast(path)); AzPathBufPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `PathBuf` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_delete(ptr: &mut AzPathBufPtr) { let _ = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`PathBuf`>!.
#[no_mangle] #[inline] pub extern "C" fn az_path_buf_shallow_copy(ptr: &AzPathBufPtr) -> AzPathBufPtr { AzPathBufPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzPathBufPtr` to a `Box<PathBuf>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_path_buf_downcast(ptr: AzPathBufPtr) -> Box<PathBuf> { unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) } }
/// (private): Downcasts the `AzPathBufPtr` to a `&mut Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_refmut<F: FnOnce(&mut Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let mut box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzPathBufPtr` to a `&Box<PathBuf>` and runs the `func` closure on it
#[inline(always)] fn az_path_buf_downcast_ref<F: FnOnce(&Box<PathBuf>)>(ptr: &mut AzPathBufPtr, func: F) { let box_ptr: Box<PathBuf> = unsafe { Box::<PathBuf>::from_raw(ptr.ptr  as *mut PathBuf) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Wrapper over a Rust-allocated `Duration`
#[no_mangle] #[repr(C)] pub struct AzDurationPtr { ptr: *mut c_void }
/// Creates a new `Duration` from milliseconds
#[no_mangle] #[inline] pub extern "C" fn az_duration_from_millis(millis: u64) -> AzDurationPtr { let object: Duration = ; AzDurationPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `Duration` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_duration_delete(ptr: &mut AzDurationPtr) { let _ = unsafe { Box::<Duration>::from_raw(ptr.ptr  as *mut Duration) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Duration`>!.
#[no_mangle] #[inline] pub extern "C" fn az_duration_shallow_copy(ptr: &AzDurationPtr) -> AzDurationPtr { AzDurationPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzDurationPtr` to a `Box<Duration>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_duration_downcast(ptr: AzDurationPtr) -> Box<Duration> { unsafe { Box::<Duration>::from_raw(ptr.ptr  as *mut Duration) } }
/// (private): Downcasts the `AzDurationPtr` to a `&mut Box<Duration>` and runs the `func` closure on it
#[inline(always)] fn az_duration_downcast_refmut<F: FnOnce(&mut Box<Duration>)>(ptr: &mut AzDurationPtr, func: F) { let mut box_ptr: Box<Duration> = unsafe { Box::<Duration>::from_raw(ptr.ptr  as *mut Duration) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzDurationPtr` to a `&Box<Duration>` and runs the `func` closure on it
#[inline(always)] fn az_duration_downcast_ref<F: FnOnce(&Box<Duration>)>(ptr: &mut AzDurationPtr, func: F) { let box_ptr: Box<Duration> = unsafe { Box::<Duration>::from_raw(ptr.ptr  as *mut Duration) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<AppConfig>` struct
#[no_mangle] #[repr(C)] pub struct AzAppConfigPtr { ptr: *mut c_void }
/// Creates a new AppConfig with default values
#[no_mangle] #[inline] pub extern "C" fn az_app_config_default() -> AzAppConfigPtr { let object: AppConfig = AppConfig::default(); AzAppConfigPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `AppConfig` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_delete(ptr: &mut AzAppConfigPtr) { let _ = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`AppConfig`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_config_shallow_copy(ptr: &AzAppConfigPtr) -> AzAppConfigPtr { AzAppConfigPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppConfigPtr` to a `Box<AppConfig>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_config_downcast(ptr: AzAppConfigPtr) -> Box<AppConfig> { unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) } }
/// (private): Downcasts the `AzAppConfigPtr` to a `&mut Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_refmut<F: FnOnce(&mut Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let mut box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppConfigPtr` to a `&Box<AppConfig>` and runs the `func` closure on it
#[inline(always)] fn az_app_config_downcast_ref<F: FnOnce(&Box<AppConfig>)>(ptr: &mut AzAppConfigPtr, func: F) { let box_ptr: Box<AppConfig> = unsafe { Box::<AppConfig>::from_raw(ptr.ptr  as *mut AppConfig) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<App>` struct
#[no_mangle] #[repr(C)] pub struct AzAppPtr { ptr: *mut c_void }
/// Creates a new App instance from the given `AppConfig`
#[no_mangle] #[inline] pub extern "C" fn az_app_new(data: AzRefAny, config: AzAppConfigPtr, callback: AzLayoutCallback) -> AzAppPtr { let object: App = App::new(data, *az_app_config_downcast(config), callback).unwrap(); AzAppPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Runs the application. Due to platform restrictions (specifically `WinMain` on Windows), this function never returns.
#[no_mangle] #[inline] pub extern "C" fn az_app_run(app: AzAppPtr, window: AzWindowCreateOptionsPtr) { az_app_downcast(app).run(*az_window_create_options_downcast(window)) }
/// Destructor: Takes ownership of the `App` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_app_delete(ptr: &mut AzAppPtr) { let _ = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`App`>!.
#[no_mangle] #[inline] pub extern "C" fn az_app_shallow_copy(ptr: &AzAppPtr) -> AzAppPtr { AzAppPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzAppPtr` to a `Box<App>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_app_downcast(ptr: AzAppPtr) -> Box<App> { unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) } }
/// (private): Downcasts the `AzAppPtr` to a `&mut Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_refmut<F: FnOnce(&mut Box<App>)>(ptr: &mut AzAppPtr, func: F) { let mut box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzAppPtr` to a `&Box<App>` and runs the `func` closure on it
#[inline(always)] fn az_app_downcast_ref<F: FnOnce(&Box<App>)>(ptr: &mut AzAppPtr, func: F) { let box_ptr: Box<App> = unsafe { Box::<App>::from_raw(ptr.ptr  as *mut App) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// The layout() callback fn
pub type AzLayoutCallback = fn(AzRefAny, AzLayoutInfoPtr) -> AzDomPtr;
pub type AzCallbackReturn = AzUpdateScreen;
/// Callback for responding to window events
pub type AzCallback = fn(AzCallbackInfoPtr) -> AzCallbackReturn;
/// Pointer to rust-allocated `Box<CallbackInfo>` struct
pub type AzCallbackInfoPtrType = azul_core::callbacks::CallbackInfoPtr;
#[no_mangle] pub use AzCallbackInfoPtrType as AzCallbackInfoPtr;
/// Destructor: Takes ownership of the `CallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_callback_info_delete<'a>(ptr: &mut AzCallbackInfoPtr) { let _ = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`CallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_callback_info_shallow_copy<'a>(ptr: &AzCallbackInfoPtr) -> AzCallbackInfoPtr { AzCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `Box<CallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_callback_info_downcast<'a>(ptr: AzCallbackInfoPtr) -> Box<CallbackInfo<'a>> { unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) } }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `&mut Box<CallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<CallbackInfo<'a>>)>(ptr: &mut AzCallbackInfoPtr, func: F) { let mut box_ptr: Box<CallbackInfo<'a>> = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCallbackInfoPtr` to a `&Box<CallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_callback_info_downcast_ref<'a, F: FnOnce(&Box<CallbackInfo<'a>>)>(ptr: &mut AzCallbackInfoPtr, func: F) { let box_ptr: Box<CallbackInfo<'a>> = unsafe { Box::<CallbackInfo<'a>>::from_raw(ptr.ptr  as *mut CallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `UpdateScreen` struct
#[no_mangle] pub type AzUpdateScreen = Option<()>;

/// Re-export of rust-allocated (stack based) `Redraw` struct
#[no_mangle] pub static AzRedraw: AzUpdateScreen = azul_core::callbacks::Redraw;

/// Re-export of rust-allocated (stack based) `DontRedraw` struct
#[no_mangle] pub static AzDontRedraw: AzUpdateScreen = azul_core::callbacks::DontRedraw;

/// Callback for rendering iframes (infinite data structures that have to know how large they are rendered)
pub type AzIFrameCallback = fn(AzIFrameCallbackInfoPtr) -> AzIFrameCallbackReturnPtr;
/// Pointer to rust-allocated `Box<IFrameCallbackInfo>` struct
pub type AzIFrameCallbackInfoPtrType = azul_core::callbacks::IFrameCallbackInfoPtr;
#[no_mangle] pub use AzIFrameCallbackInfoPtrType as AzIFrameCallbackInfoPtr;
/// Destructor: Takes ownership of the `IFrameCallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_info_delete<'a>(ptr: &mut AzIFrameCallbackInfoPtr) { let _ = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`IFrameCallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_info_shallow_copy<'a>(ptr: &AzIFrameCallbackInfoPtr) -> AzIFrameCallbackInfoPtr { AzIFrameCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `Box<IFrameCallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_i_frame_callback_info_downcast<'a>(ptr: AzIFrameCallbackInfoPtr) -> Box<IFrameCallbackInfo<'a>> { unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) } }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `&mut Box<IFrameCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<IFrameCallbackInfo<'a>>)>(ptr: &mut AzIFrameCallbackInfoPtr, func: F) { let mut box_ptr: Box<IFrameCallbackInfo<'a>> = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzIFrameCallbackInfoPtr` to a `&Box<IFrameCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_info_downcast_ref<'a, F: FnOnce(&Box<IFrameCallbackInfo<'a>>)>(ptr: &mut AzIFrameCallbackInfoPtr, func: F) { let box_ptr: Box<IFrameCallbackInfo<'a>> = unsafe { Box::<IFrameCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut IFrameCallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<IFrameCallbackReturn>` struct
pub type AzIFrameCallbackReturnPtrType = azul_core::callbacks::IFrameCallbackReturnPtr;
#[no_mangle] pub use AzIFrameCallbackReturnPtrType as AzIFrameCallbackReturnPtr;
/// Destructor: Takes ownership of the `IFrameCallbackReturn` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_return_delete(ptr: &mut AzIFrameCallbackReturnPtr) { let _ = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`IFrameCallbackReturn`>!.
#[no_mangle] #[inline] pub extern "C" fn az_i_frame_callback_return_shallow_copy(ptr: &AzIFrameCallbackReturnPtr) -> AzIFrameCallbackReturnPtr { AzIFrameCallbackReturnPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `Box<IFrameCallbackReturn>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_i_frame_callback_return_downcast(ptr: AzIFrameCallbackReturnPtr) -> Box<IFrameCallbackReturn> { unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) } }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `&mut Box<IFrameCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_return_downcast_refmut<F: FnOnce(&mut Box<IFrameCallbackReturn>)>(ptr: &mut AzIFrameCallbackReturnPtr, func: F) { let mut box_ptr: Box<IFrameCallbackReturn> = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzIFrameCallbackReturnPtr` to a `&Box<IFrameCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_i_frame_callback_return_downcast_ref<F: FnOnce(&Box<IFrameCallbackReturn>)>(ptr: &mut AzIFrameCallbackReturnPtr, func: F) { let box_ptr: Box<IFrameCallbackReturn> = unsafe { Box::<IFrameCallbackReturn>::from_raw(ptr.ptr  as *mut IFrameCallbackReturn) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Callback for rendering to an OpenGL texture
pub type AzGlCallback = fn(AzGlCallbackInfoPtr) -> AzGlCallbackReturnPtr;
/// Pointer to rust-allocated `Box<GlCallbackInfo>` struct
pub type AzGlCallbackInfoPtrType = azul_core::callbacks::GlCallbackInfoPtr;
#[no_mangle] pub use AzGlCallbackInfoPtrType as AzGlCallbackInfoPtr;
/// Destructor: Takes ownership of the `GlCallbackInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_info_delete<'a>(ptr: &mut AzGlCallbackInfoPtr) { let _ = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`GlCallbackInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_info_shallow_copy<'a>(ptr: &AzGlCallbackInfoPtr) -> AzGlCallbackInfoPtr { AzGlCallbackInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `Box<GlCallbackInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_gl_callback_info_downcast<'a>(ptr: AzGlCallbackInfoPtr) -> Box<GlCallbackInfo<'a>> { unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) } }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `&mut Box<GlCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_info_downcast_refmut<'a, F: FnOnce(&mut Box<GlCallbackInfo<'a>>)>(ptr: &mut AzGlCallbackInfoPtr, func: F) { let mut box_ptr: Box<GlCallbackInfo<'a>> = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzGlCallbackInfoPtr` to a `&Box<GlCallbackInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_info_downcast_ref<'a, F: FnOnce(&Box<GlCallbackInfo<'a>>)>(ptr: &mut AzGlCallbackInfoPtr, func: F) { let box_ptr: Box<GlCallbackInfo<'a>> = unsafe { Box::<GlCallbackInfo<'a>>::from_raw(ptr.ptr  as *mut GlCallbackInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<GlCallbackReturn>` struct
pub type AzGlCallbackReturnPtrType = azul_core::callbacks::GlCallbackReturnPtr;
#[no_mangle] pub use AzGlCallbackReturnPtrType as AzGlCallbackReturnPtr;
/// Destructor: Takes ownership of the `GlCallbackReturn` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_return_delete(ptr: &mut AzGlCallbackReturnPtr) { let _ = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`GlCallbackReturn`>!.
#[no_mangle] #[inline] pub extern "C" fn az_gl_callback_return_shallow_copy(ptr: &AzGlCallbackReturnPtr) -> AzGlCallbackReturnPtr { AzGlCallbackReturnPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `Box<GlCallbackReturn>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_gl_callback_return_downcast(ptr: AzGlCallbackReturnPtr) -> Box<GlCallbackReturn> { unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) } }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `&mut Box<GlCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_return_downcast_refmut<F: FnOnce(&mut Box<GlCallbackReturn>)>(ptr: &mut AzGlCallbackReturnPtr, func: F) { let mut box_ptr: Box<GlCallbackReturn> = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzGlCallbackReturnPtr` to a `&Box<GlCallbackReturn>` and runs the `func` closure on it
#[inline(always)] fn az_gl_callback_return_downcast_ref<F: FnOnce(&Box<GlCallbackReturn>)>(ptr: &mut AzGlCallbackReturnPtr, func: F) { let box_ptr: Box<GlCallbackReturn> = unsafe { Box::<GlCallbackReturn>::from_raw(ptr.ptr  as *mut GlCallbackReturn) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<RefAny>` struct
pub use ::azul_core::callbacks::RefAny as AzRefAny;

/// Creates a new `RefAny` instance
#[no_mangle] pub extern "C" fn az_ref_any_new(ptr: *const u8, len: usize, type_id: u64, type_name: AzStringPtr, custom_destructor: fn(AzRefAny)) -> AzRefAny {
    AzRefAny::new_c(ptr, len, type_id, *az_string_downcast(type_name), custom_destructor)
}
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *const c_void { ptr.get_ptr(len, type_id) }
/// Returns the internal pointer of the `RefAny` as a `*mut c_void` or a nullptr if the types don't match
#[no_mangle] pub extern "C" fn az_ref_any_get_mut_ptr(ptr: &AzRefAny, len: usize, type_id: u64) -> *mut c_void { ptr.get_mut_ptr(len, type_id) }
/// Creates a new reference of the pointer, pointing to the same object: WARNING: After calling this function you'll have two pointers to the same Box<`RefAny`>!.
#[no_mangle] pub extern "C" fn az_ref_any_shallow_copy(ptr: &AzRefAny) -> AzRefAny { ptr.clone() }
/// Destructor: Takes ownership of the `RefAny` pointer and deletes it.
#[no_mangle] pub extern "C" fn az_ref_any_delete(ptr: &mut AzRefAny) { az_ref_any_core_copy(ptr).drop_c() }
/// Copies the pointer without invoking the destructor
#[no_mangle] pub extern "C" fn az_ref_any_core_copy(ptr: &AzRefAny) -> AzRefAny {
    AzRefAny {
        _internal_ptr: ptr._internal_ptr,
        _internal_len: ptr._internal_len,
        _internal_layout_size: ptr._internal_layout_size,
        _internal_layout_align: ptr._internal_layout_align,
        type_id: ptr.type_id,
        type_name: ptr.type_name.clone(),
        strong_count: ptr.strong_count,
        is_currently_mutable: ptr.is_currently_mutable,
        custom_destructor: ptr.custom_destructor,
    }
}

/// Pointer to rust-allocated `Box<LayoutInfo>` struct
pub type AzLayoutInfoPtrType = azul_core::callbacks::LayoutInfoPtr;
#[no_mangle] pub use AzLayoutInfoPtrType as AzLayoutInfoPtr;
/// Destructor: Takes ownership of the `LayoutInfo` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_delete<'a>(ptr: &mut AzLayoutInfoPtr) { let _ = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`LayoutInfo`>!.
#[no_mangle] #[inline] pub extern "C" fn az_layout_info_shallow_copy<'a>(ptr: &AzLayoutInfoPtr) -> AzLayoutInfoPtr { AzLayoutInfoPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `Box<LayoutInfo<'a>>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_layout_info_downcast<'a>(ptr: AzLayoutInfoPtr) -> Box<LayoutInfo<'a>> { unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) } }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&mut Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_refmut<'a, F: FnOnce(&mut Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let mut box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzLayoutInfoPtr` to a `&Box<LayoutInfo<'a>>` and runs the `func` closure on it
#[inline(always)] fn az_layout_info_downcast_ref<'a, F: FnOnce(&Box<LayoutInfo<'a>>)>(ptr: &mut AzLayoutInfoPtr, func: F) { let box_ptr: Box<LayoutInfo<'a>> = unsafe { Box::<LayoutInfo<'a>>::from_raw(ptr.ptr  as *mut LayoutInfo<'a>) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Css>` struct
#[no_mangle] #[repr(C)] pub struct AzCssPtr { ptr: *mut c_void }
/// Loads the native style for the given operating system
#[no_mangle] #[inline] pub extern "C" fn az_css_native() -> AzCssPtr { let object: Css = azul_native_style::native(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Returns an empty CSS style
#[no_mangle] #[inline] pub extern "C" fn az_css_empty() -> AzCssPtr { let object: Css = Css::empty(); AzCssPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `Css` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_css_delete(ptr: &mut AzCssPtr) { let _ = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Css`>!.
#[no_mangle] #[inline] pub extern "C" fn az_css_shallow_copy(ptr: &AzCssPtr) -> AzCssPtr { AzCssPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCssPtr` to a `Box<Css>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_css_downcast(ptr: AzCssPtr) -> Box<Css> { unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) } }
/// (private): Downcasts the `AzCssPtr` to a `&mut Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_refmut<F: FnOnce(&mut Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let mut box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCssPtr` to a `&Box<Css>` and runs the `func` closure on it
#[inline(always)] fn az_css_downcast_ref<F: FnOnce(&Box<Css>)>(ptr: &mut AzCssPtr, func: F) { let box_ptr: Box<Css> = unsafe { Box::<Css>::from_raw(ptr.ptr  as *mut Css) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<CssPropertyKey>` struct
#[no_mangle] #[repr(C)] pub struct AzCssPropertyKeyPtr { ptr: *mut c_void }
/// Destructor: Takes ownership of the `CssPropertyKey` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_css_property_key_delete(ptr: &mut AzCssPropertyKeyPtr) { let _ = unsafe { Box::<CssPropertyKey>::from_raw(ptr.ptr  as *mut CssPropertyKey) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`CssPropertyKey`>!.
#[no_mangle] #[inline] pub extern "C" fn az_css_property_key_shallow_copy(ptr: &AzCssPropertyKeyPtr) -> AzCssPropertyKeyPtr { AzCssPropertyKeyPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCssPropertyKeyPtr` to a `Box<CssPropertyKey>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_css_property_key_downcast(ptr: AzCssPropertyKeyPtr) -> Box<CssPropertyKey> { unsafe { Box::<CssPropertyKey>::from_raw(ptr.ptr  as *mut CssPropertyKey) } }
/// (private): Downcasts the `AzCssPropertyKeyPtr` to a `&mut Box<CssPropertyKey>` and runs the `func` closure on it
#[inline(always)] fn az_css_property_key_downcast_refmut<F: FnOnce(&mut Box<CssPropertyKey>)>(ptr: &mut AzCssPropertyKeyPtr, func: F) { let mut box_ptr: Box<CssPropertyKey> = unsafe { Box::<CssPropertyKey>::from_raw(ptr.ptr  as *mut CssPropertyKey) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCssPropertyKeyPtr` to a `&Box<CssPropertyKey>` and runs the `func` closure on it
#[inline(always)] fn az_css_property_key_downcast_ref<F: FnOnce(&Box<CssPropertyKey>)>(ptr: &mut AzCssPropertyKeyPtr, func: F) { let box_ptr: Box<CssPropertyKey> = unsafe { Box::<CssPropertyKey>::from_raw(ptr.ptr  as *mut CssPropertyKey) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Parsed CSS key-value pair
#[no_mangle] #[repr(C)] pub struct AzCssPropertyPtr { ptr: *mut c_void }
/// Parses a new CssProperty from a string
#[no_mangle] #[inline] pub extern "C" fn az_css_property_parse_from_string(key: AzCssPropertyKeyPtr, value: AzStringPtr) -> AzCssPropertyPtr { let object: CssProperty = CssPropertyValue::from_str(key, &*az_string_downcast(value)); AzCssPropertyPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `CssProperty` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_css_property_delete(ptr: &mut AzCssPropertyPtr) { let _ = unsafe { Box::<CssProperty>::from_raw(ptr.ptr  as *mut CssProperty) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`CssProperty`>!.
#[no_mangle] #[inline] pub extern "C" fn az_css_property_shallow_copy(ptr: &AzCssPropertyPtr) -> AzCssPropertyPtr { AzCssPropertyPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzCssPropertyPtr` to a `Box<CssProperty>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_css_property_downcast(ptr: AzCssPropertyPtr) -> Box<CssProperty> { unsafe { Box::<CssProperty>::from_raw(ptr.ptr  as *mut CssProperty) } }
/// (private): Downcasts the `AzCssPropertyPtr` to a `&mut Box<CssProperty>` and runs the `func` closure on it
#[inline(always)] fn az_css_property_downcast_refmut<F: FnOnce(&mut Box<CssProperty>)>(ptr: &mut AzCssPropertyPtr, func: F) { let mut box_ptr: Box<CssProperty> = unsafe { Box::<CssProperty>::from_raw(ptr.ptr  as *mut CssProperty) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzCssPropertyPtr` to a `&Box<CssProperty>` and runs the `func` closure on it
#[inline(always)] fn az_css_property_downcast_ref<F: FnOnce(&Box<CssProperty>)>(ptr: &mut AzCssPropertyPtr, func: F) { let box_ptr: Box<CssProperty> = unsafe { Box::<CssProperty>::from_raw(ptr.ptr  as *mut CssProperty) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Pointer to rust-allocated `Box<Dom>` struct
pub type AzDomPtrType = azul_core::dom::DomPtr;
#[no_mangle] pub use AzDomPtrType as AzDomPtr;
/// Creates a new `div` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_div() -> AzDomPtr { let object: Dom = Dom::div(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `body` node
#[no_mangle] #[inline] pub extern "C" fn az_dom_body() -> AzDomPtr { let object: Dom = Dom::body(); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `p` node with a given `String` as the text contents
#[no_mangle] #[inline] pub extern "C" fn az_dom_label(text: AzStringPtr) -> AzDomPtr { let object: Dom = Dom::label(*az_string_downcast(text)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `p` node from a (cached) text referenced by a `TextId`
#[no_mangle] #[inline] pub extern "C" fn az_dom_text(text_id: AzTextId) -> AzDomPtr { let object: Dom = Dom::text(*az_text_id_downcast(text_id)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new `img` node from a (cached) text referenced by a `ImageId`
#[no_mangle] #[inline] pub extern "C" fn az_dom_image(image_id: AzImageId) -> AzDomPtr { let object: Dom = Dom::image(*az_image_id_downcast(image_id)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new node which will render an OpenGL texture after the layout step is finished. See the documentation for [GlCallback]() for more info about OpenGL rendering callbacks.
#[no_mangle] #[inline] pub extern "C" fn az_dom_gl_callback(data: AzRefAny, callback: AzGlCallback) -> AzDomPtr { let object: Dom = Dom::gl_callback(azul_core::callbacks::GlCallback(callback)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Creates a new node with a callback that will return a `Dom` after being layouted. See the documentation for [IFrameCallback]() for more info about iframe callbacks.
#[no_mangle] #[inline] pub extern "C" fn az_dom_iframe_callback(data: AzRefAny, callback: AzGlCallback) -> AzDomPtr { let object: Dom = Dom::iframe(azul_core::callbacks::IFrameCallback(callback)); AzDomPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Adds a CSS ID (`#something`) to the DOM node
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_id(dom: &mut AzDomPtr, id: AzStringPtr) { az_dom_downcast_refmut(dom, |d| { d.add_id(*az_string_downcast(id)); }) }
/// Same as [`Dom::add_id`](#method.add_id), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_id(mut dom: AzDomPtr, id: AzStringPtr) -> AzDomPtr { az_dom_add_id(&mut dom, id); dom }
/// Same as calling [`Dom::add_id`](#method.add_id) for each CSS ID, but this function **replaces** all current CSS IDs
#[no_mangle] #[inline] pub extern "C" fn az_dom_set_ids(dom: &mut AzDomPtr, ids: AzVec<String>Ptr) { az_dom_downcast_refmut(dom, |d| { d.set_ids(*az_vec_string_downcast(ids)); }) }
/// Same as [`Dom::set_ids`](#method.set_ids), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_ids(mut dom: AzDomPtr, ids: AzVec<String>Ptr) -> AzDomPtr { az_dom_set_ids(&mut dom, ids); dom }
/// Adds a CSS class (`.something`) to the DOM node
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_class(dom: &mut AzDomPtr, class: AzStringPtr) { az_dom_downcast_refmut(dom, |d| { d.add_class(*az_string_downcast(class)); }) }
/// Same as [`Dom::add_class`](#method.add_class), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_class(mut dom: AzDomPtr, class: AzStringPtr) -> AzDomPtr { az_dom_add_class(&mut dom, class); dom }
/// Same as calling [`Dom::add_class`](#method.add_class) for each class, but this function **replaces** all current classes
#[no_mangle] #[inline] pub extern "C" fn az_dom_set_classes(dom: &mut AzDomPtr, classes: AzVec<String>Ptr) { az_dom_downcast_refmut(dom, |d| { d.set_classes(*az_vec_string_downcast(classes)); }) }
/// Same as [`Dom::set_classes`](#method.set_classes), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_classes(mut dom: AzDomPtr, classes: AzVec<String>Ptr) -> AzDomPtr { az_dom_set_classes(&mut dom, ids); dom }
/// Adds a [`Callback`](callbacks/type.Callback) that acts on the `data` the `event` happens
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_callback(dom: &mut AzDomPtr, event: AzEventFilter, data: AzRefAny, callback: AzCallback) { az_dom_downcast_refmut(dom, |d| { d.add_callback(event, data, Callback(callback)); }) }
/// Same as [`Dom::add_callback`](#method.add_callback), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_callback(dom: &mut AzDomPtr, event: AzEventFilter, data: AzRefAny, callback: AzCallback) { az_dom_add_callback(&mut dom, event, data, callback); dom }
/// Overrides the CSS property of this DOM node with a value (for example `"width = 200px"`)
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_dynamic_css_override(dom: &mut AzDomPtr, prop: AzCssPropertyPtr) { az_dom_downcast_refmut(dom, |d| { d.add_dynamic_css_override(event, az_css_property_downcast(prop)); }) }
/// Same as [`Dom::add_dynamic_css_override`](#method.add_dynamic_css_override), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_dynamic_css_override(dom: &mut AzDomPtr, prop: AzCssPropertyPtr) { az_dom_add_dynamic_css_override(&mut dom, prop); dom }
/// Sets the `is_draggable` attribute of this DOM node (default: false)
#[no_mangle] #[inline] pub extern "C" fn az_dom_set_is_draggable(dom: &mut AzDomPtr, is_draggable: bool) { az_dom_downcast_refmut(dom, |d| { d.is_draggable(event, is_draggable); }) }
/// Same as [`Dom::set_is_draggable`](#method.set_is_draggable), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_is_draggable(dom: &mut AzDomPtr, is_draggable: bool) { az_dom_set_is_draggable(&mut dom, is_draggable); dom }
/// Sets the `tabindex` attribute of this DOM node (makes an element focusable - default: None)
#[no_mangle] #[inline] pub extern "C" fn az_dom_set_tab_index(dom: &mut AzDomPtr, tab_index: AzTabIndex) { az_dom_downcast_refmut(dom, |d| { d.set_tab_index(event, tab_index); }) }
/// Same as [`Dom::set_tab_index`](#method.set_tab_index), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_tab_index(dom: &mut AzDomPtr, tab_index: AzTabIndex) { az_dom_set_tab_index(&mut dom, tab_index); dom }
/// Reparents another `Dom` to be the child node of this `Dom`
#[no_mangle] #[inline] pub extern "C" fn az_dom_add_child(dom: &mut AzDomPtr, child: AzDomPtr) { az_dom_downcast_refmut(dom, |d| { d.add_child(*az_dom_downcast(child)); }) }
/// Same as [`Dom::add_child`](#method.add_child), but as a builder method
#[no_mangle] #[inline] pub extern "C" fn az_dom_with_child(mut dom: AzDomPtr, child: AzDomPtr) -> AzDomPtr { az_dom_add_child(&mut dom, child); dom }
/// Returns if the DOM node has a certain CSS ID
#[no_mangle] #[inline] pub extern "C" fn az_dom_has_id(dom: &AzDomPtr, id: AzStringPtr) -> AzboolPtr { az_dom_downcast_refmut(dom, |d| { d.has_id(&*az_string_downcast(id)); }) }
/// Returns if the DOM node has a certain CSS class
#[no_mangle] #[inline] pub extern "C" fn az_dom_has_class(dom: &AzDomPtr, class: AzStringPtr) -> AzboolPtr { az_dom_downcast_refmut(dom, |d| { d.has_class(&*az_string_downcast(class)); }) }
/// Destructor: Takes ownership of the `Dom` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_dom_delete(ptr: &mut AzDomPtr) { let _ = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`Dom`>!.
#[no_mangle] #[inline] pub extern "C" fn az_dom_shallow_copy(ptr: &AzDomPtr) -> AzDomPtr { AzDomPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzDomPtr` to a `Box<Dom>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_dom_downcast(ptr: AzDomPtr) -> Box<Dom> { unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) } }
/// (private): Downcasts the `AzDomPtr` to a `&mut Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_refmut<F: FnOnce(&mut Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let mut box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzDomPtr` to a `&Box<Dom>` and runs the `func` closure on it
#[inline(always)] fn az_dom_downcast_ref<F: FnOnce(&Box<Dom>)>(ptr: &mut AzDomPtr, func: F) { let box_ptr: Box<Dom> = unsafe { Box::<Dom>::from_raw(ptr.ptr  as *mut Dom) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `EventFilter` struct
pub type AzEventFilterType = azul_core::dom::EventFilter;
#[no_mangle] pub use AzEventFilterType as AzEventFilter;
#[inline] #[no_mangle] pub extern "C" fn az_event_filter_hover(variant_data: AzHoverEventFilter) -> AzEventFilter { AzEventFilter::Hover(*az_hover_event_filter_downcast(variant_data)) }
#[inline] #[no_mangle] pub extern "C" fn az_event_filter_not(variant_data: AzNotEventFilter) -> AzEventFilter { AzEventFilter::Not(*az_not_event_filter_downcast(variant_data)) }
#[inline] #[no_mangle] pub extern "C" fn az_event_filter_focus(variant_data: AzFocusEventFilter) -> AzEventFilter { AzEventFilter::Focus(*az_focus_event_filter_downcast(variant_data)) }
#[inline] #[no_mangle] pub extern "C" fn az_event_filter_window(variant_data: AzWindowEventFilter) -> AzEventFilter { AzEventFilter::Window(*az_window_event_filter_downcast(variant_data)) }
/// Destructor: Takes ownership of the `EventFilter` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_event_filter_delete(object: &mut AzEventFilter) { match object { AzEventFilter::Hover(_) => { }, AzEventFilter::Not(_) => { }, AzEventFilter::Focus(_) => { }, AzEventFilter::Window(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_event_filter_deep_copy(object: &AzEventFilter) -> AzEventFilter { object.clone() }

/// Re-export of rust-allocated (stack based) `HoverEventFilter` struct
pub type AzHoverEventFilterType = azul_core::dom::HoverEventFilter;
#[no_mangle] pub use AzHoverEventFilterType as AzHoverEventFilter;
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_mouse_over() -> AzHoverEventFilter { AzHoverEventFilter::MouseOver }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_mouse_down() -> AzHoverEventFilter { AzHoverEventFilter::MouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_left_mouse_down() -> AzHoverEventFilter { AzHoverEventFilter::LeftMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_right_mouse_down() -> AzHoverEventFilter { AzHoverEventFilter::RightMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_middle_mouse_down() -> AzHoverEventFilter { AzHoverEventFilter::MiddleMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_mouse_up() -> AzHoverEventFilter { AzHoverEventFilter::MouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_left_mouse_up() -> AzHoverEventFilter { AzHoverEventFilter::LeftMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_right_mouse_up() -> AzHoverEventFilter { AzHoverEventFilter::RightMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_middle_mouse_up() -> AzHoverEventFilter { AzHoverEventFilter::MiddleMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_mouse_enter() -> AzHoverEventFilter { AzHoverEventFilter::MouseEnter }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_mouse_leave() -> AzHoverEventFilter { AzHoverEventFilter::MouseLeave }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_scroll() -> AzHoverEventFilter { AzHoverEventFilter::Scroll }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_scroll_start() -> AzHoverEventFilter { AzHoverEventFilter::ScrollStart }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_scroll_end() -> AzHoverEventFilter { AzHoverEventFilter::ScrollEnd }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_text_input() -> AzHoverEventFilter { AzHoverEventFilter::TextInput }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_virtual_key_down() -> AzHoverEventFilter { AzHoverEventFilter::VirtualKeyDown }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_virtual_key_up() -> AzHoverEventFilter { AzHoverEventFilter::VirtualKeyUp }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_hovered_file() -> AzHoverEventFilter { AzHoverEventFilter::HoveredFile }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_dropped_file() -> AzHoverEventFilter { AzHoverEventFilter::DroppedFile }
#[inline] #[no_mangle] pub extern "C" fn az_hover_event_filter_hovered_file_cancelled() -> AzHoverEventFilter { AzHoverEventFilter::HoveredFileCancelled }
/// Destructor: Takes ownership of the `HoverEventFilter` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_hover_event_filter_delete(object: &mut AzHoverEventFilter) { match object { AzHoverEventFilter::MouseOver => { }, AzHoverEventFilter::MouseDown => { }, AzHoverEventFilter::LeftMouseDown => { }, AzHoverEventFilter::RightMouseDown => { }, AzHoverEventFilter::MiddleMouseDown => { }, AzHoverEventFilter::MouseUp => { }, AzHoverEventFilter::LeftMouseUp => { }, AzHoverEventFilter::RightMouseUp => { }, AzHoverEventFilter::MiddleMouseUp => { }, AzHoverEventFilter::MouseEnter => { }, AzHoverEventFilter::MouseLeave => { }, AzHoverEventFilter::Scroll => { }, AzHoverEventFilter::ScrollStart => { }, AzHoverEventFilter::ScrollEnd => { }, AzHoverEventFilter::TextInput => { }, AzHoverEventFilter::VirtualKeyDown => { }, AzHoverEventFilter::VirtualKeyUp => { }, AzHoverEventFilter::HoveredFile => { }, AzHoverEventFilter::DroppedFile => { }, AzHoverEventFilter::HoveredFileCancelled => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_hover_event_filter_deep_copy(object: &AzHoverEventFilter) -> AzHoverEventFilter { object.clone() }

/// Re-export of rust-allocated (stack based) `FocusEventFilter` struct
pub type AzFocusEventFilterType = azul_core::dom::FocusEventFilter;
#[no_mangle] pub use AzFocusEventFilterType as AzFocusEventFilter;
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_mouse_over() -> AzFocusEventFilter { AzFocusEventFilter::MouseOver }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_mouse_down() -> AzFocusEventFilter { AzFocusEventFilter::MouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_left_mouse_down() -> AzFocusEventFilter { AzFocusEventFilter::LeftMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_right_mouse_down() -> AzFocusEventFilter { AzFocusEventFilter::RightMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_middle_mouse_down() -> AzFocusEventFilter { AzFocusEventFilter::MiddleMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_mouse_up() -> AzFocusEventFilter { AzFocusEventFilter::MouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_left_mouse_up() -> AzFocusEventFilter { AzFocusEventFilter::LeftMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_right_mouse_up() -> AzFocusEventFilter { AzFocusEventFilter::RightMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_middle_mouse_up() -> AzFocusEventFilter { AzFocusEventFilter::MiddleMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_mouse_enter() -> AzFocusEventFilter { AzFocusEventFilter::MouseEnter }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_mouse_leave() -> AzFocusEventFilter { AzFocusEventFilter::MouseLeave }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_scroll() -> AzFocusEventFilter { AzFocusEventFilter::Scroll }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_scroll_start() -> AzFocusEventFilter { AzFocusEventFilter::ScrollStart }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_scroll_end() -> AzFocusEventFilter { AzFocusEventFilter::ScrollEnd }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_text_input() -> AzFocusEventFilter { AzFocusEventFilter::TextInput }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_virtual_key_down() -> AzFocusEventFilter { AzFocusEventFilter::VirtualKeyDown }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_virtual_key_up() -> AzFocusEventFilter { AzFocusEventFilter::VirtualKeyUp }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_focus_received() -> AzFocusEventFilter { AzFocusEventFilter::FocusReceived }
#[inline] #[no_mangle] pub extern "C" fn az_focus_event_filter_focus_lost() -> AzFocusEventFilter { AzFocusEventFilter::FocusLost }
/// Destructor: Takes ownership of the `FocusEventFilter` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_focus_event_filter_delete(object: &mut AzFocusEventFilter) { match object { AzFocusEventFilter::MouseOver => { }, AzFocusEventFilter::MouseDown => { }, AzFocusEventFilter::LeftMouseDown => { }, AzFocusEventFilter::RightMouseDown => { }, AzFocusEventFilter::MiddleMouseDown => { }, AzFocusEventFilter::MouseUp => { }, AzFocusEventFilter::LeftMouseUp => { }, AzFocusEventFilter::RightMouseUp => { }, AzFocusEventFilter::MiddleMouseUp => { }, AzFocusEventFilter::MouseEnter => { }, AzFocusEventFilter::MouseLeave => { }, AzFocusEventFilter::Scroll => { }, AzFocusEventFilter::ScrollStart => { }, AzFocusEventFilter::ScrollEnd => { }, AzFocusEventFilter::TextInput => { }, AzFocusEventFilter::VirtualKeyDown => { }, AzFocusEventFilter::VirtualKeyUp => { }, AzFocusEventFilter::FocusReceived => { }, AzFocusEventFilter::FocusLost => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_focus_event_filter_deep_copy(object: &AzFocusEventFilter) -> AzFocusEventFilter { object.clone() }

/// Re-export of rust-allocated (stack based) `NotEventFilter` struct
pub type AzNotEventFilterType = azul_core::dom::NotEventFilter;
#[no_mangle] pub use AzNotEventFilterType as AzNotEventFilter;
#[inline] #[no_mangle] pub extern "C" fn az_not_event_filter_hover(variant_data: AzHoverEventFilter) -> AzNotEventFilter { AzNotEventFilter::Hover(*az_hover_event_filter_downcast(variant_data)) }
#[inline] #[no_mangle] pub extern "C" fn az_not_event_filter_focus(variant_data: AzFocusEventFilter) -> AzNotEventFilter { AzNotEventFilter::Focus(*az_focus_event_filter_downcast(variant_data)) }
/// Destructor: Takes ownership of the `NotEventFilter` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_not_event_filter_delete(object: &mut AzNotEventFilter) { match object { AzNotEventFilter::Hover(_) => { }, AzNotEventFilter::Focus(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_not_event_filter_deep_copy(object: &AzNotEventFilter) -> AzNotEventFilter { object.clone() }

/// Re-export of rust-allocated (stack based) `WindowEventFilter` struct
pub type AzWindowEventFilterType = azul_core::dom::WindowEventFilter;
#[no_mangle] pub use AzWindowEventFilterType as AzWindowEventFilter;
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_mouse_over() -> AzWindowEventFilter { AzWindowEventFilter::MouseOver }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_mouse_down() -> AzWindowEventFilter { AzWindowEventFilter::MouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_left_mouse_down() -> AzWindowEventFilter { AzWindowEventFilter::LeftMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_right_mouse_down() -> AzWindowEventFilter { AzWindowEventFilter::RightMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_middle_mouse_down() -> AzWindowEventFilter { AzWindowEventFilter::MiddleMouseDown }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_mouse_up() -> AzWindowEventFilter { AzWindowEventFilter::MouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_left_mouse_up() -> AzWindowEventFilter { AzWindowEventFilter::LeftMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_right_mouse_up() -> AzWindowEventFilter { AzWindowEventFilter::RightMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_middle_mouse_up() -> AzWindowEventFilter { AzWindowEventFilter::MiddleMouseUp }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_mouse_enter() -> AzWindowEventFilter { AzWindowEventFilter::MouseEnter }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_mouse_leave() -> AzWindowEventFilter { AzWindowEventFilter::MouseLeave }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_scroll() -> AzWindowEventFilter { AzWindowEventFilter::Scroll }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_scroll_start() -> AzWindowEventFilter { AzWindowEventFilter::ScrollStart }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_scroll_end() -> AzWindowEventFilter { AzWindowEventFilter::ScrollEnd }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_text_input() -> AzWindowEventFilter { AzWindowEventFilter::TextInput }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_virtual_key_down() -> AzWindowEventFilter { AzWindowEventFilter::VirtualKeyDown }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_virtual_key_up() -> AzWindowEventFilter { AzWindowEventFilter::VirtualKeyUp }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_hovered_file() -> AzWindowEventFilter { AzWindowEventFilter::HoveredFile }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_dropped_file() -> AzWindowEventFilter { AzWindowEventFilter::DroppedFile }
#[inline] #[no_mangle] pub extern "C" fn az_window_event_filter_hovered_file_cancelled() -> AzWindowEventFilter { AzWindowEventFilter::HoveredFileCancelled }
/// Destructor: Takes ownership of the `WindowEventFilter` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_window_event_filter_delete(object: &mut AzWindowEventFilter) { match object { AzWindowEventFilter::MouseOver => { }, AzWindowEventFilter::MouseDown => { }, AzWindowEventFilter::LeftMouseDown => { }, AzWindowEventFilter::RightMouseDown => { }, AzWindowEventFilter::MiddleMouseDown => { }, AzWindowEventFilter::MouseUp => { }, AzWindowEventFilter::LeftMouseUp => { }, AzWindowEventFilter::RightMouseUp => { }, AzWindowEventFilter::MiddleMouseUp => { }, AzWindowEventFilter::MouseEnter => { }, AzWindowEventFilter::MouseLeave => { }, AzWindowEventFilter::Scroll => { }, AzWindowEventFilter::ScrollStart => { }, AzWindowEventFilter::ScrollEnd => { }, AzWindowEventFilter::TextInput => { }, AzWindowEventFilter::VirtualKeyDown => { }, AzWindowEventFilter::VirtualKeyUp => { }, AzWindowEventFilter::HoveredFile => { }, AzWindowEventFilter::DroppedFile => { }, AzWindowEventFilter::HoveredFileCancelled => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_window_event_filter_deep_copy(object: &AzWindowEventFilter) -> AzWindowEventFilter { object.clone() }

/// Re-export of rust-allocated (stack based) `TabIndex` struct
pub type AzTabIndexType = azul_core::dom::TabIndex;
#[no_mangle] pub use AzTabIndexType as AzTabIndex;
/// Automatic tab index, similar to simply setting `focusable = "true"` or `tabindex = 0`, (both have the effect of making the element focusable)
#[inline] #[no_mangle] pub extern "C" fn az_tab_index_auto() -> AzTabIndex { AzTabIndex::Auto }
///  Set the tab index in relation to its parent element (`tabindex = n`)
#[inline] #[no_mangle] pub extern "C" fn az_tab_index_override_in_parent(variant_data: usize) -> AzTabIndex { AzTabIndex::OverrideInParent(variant_data) }
/// Elements can be focused in callbacks, but are not accessible via keyboard / tab navigation (`tabindex = -1`)
#[inline] #[no_mangle] pub extern "C" fn az_tab_index_no_keyboard_focus() -> AzTabIndex { AzTabIndex::NoKeyboardFocus }
/// Destructor: Takes ownership of the `TabIndex` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_tab_index_delete(object: &mut AzTabIndex) { match object { AzTabIndex::Auto => { }, AzTabIndex::OverrideInParent => { }, AzTabIndex::NoKeyboardFocus => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_tab_index_deep_copy(object: &AzTabIndex) -> AzTabIndex { object.clone() }

/// Re-export of rust-allocated (stack based) `TextId` struct
pub type AzTextIdType = azul_core::app_resources::TextId;
#[no_mangle] pub use AzTextIdType as AzTextId;
/// Creates a new, unique `TextId`
#[no_mangle] #[inline] pub extern "C" fn az_text_id_new() -> AzTextId { let object: TextId = TextId::new(); object }
/// Destructor: Takes ownership of the `TextId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_text_id_delete(object: &mut AzTextId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_text_id_deep_copy(object: &AzTextId) -> AzTextId { object.clone() }

/// Re-export of rust-allocated (stack based) `ImageId` struct
pub type AzImageIdType = azul_core::app_resources::ImageId;
#[no_mangle] pub use AzImageIdType as AzImageId;
/// Creates a new, unique `ImageId`
#[no_mangle] #[inline] pub extern "C" fn az_image_id_new() -> AzImageId { let object: ImageId = ImageId::new(); object }
/// Destructor: Takes ownership of the `ImageId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_image_id_delete(object: &mut AzImageId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_image_id_deep_copy(object: &AzImageId) -> AzImageId { object.clone() }

/// Re-export of rust-allocated (stack based) `FontId` struct
pub type AzFontIdType = azul_core::app_resources::FontId;
#[no_mangle] pub use AzFontIdType as AzFontId;
/// Creates a new, unique `FontId`
#[no_mangle] #[inline] pub extern "C" fn az_font_id_new() -> AzFontId { let object: FontId = FontId::new(); object }
/// Destructor: Takes ownership of the `FontId` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_font_id_delete(object: &mut AzFontId) { }
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_font_id_deep_copy(object: &AzFontId) -> AzFontId { object.clone() }

/// Re-export of rust-allocated (stack based) `ImageSource` struct
pub type AzImageSourceType = azul_core::app_resources::ImageSource;
#[no_mangle] pub use AzImageSourceType as AzImageSource;
/// Bytes of the image, encoded in PNG / JPG / etc. format
#[inline] #[no_mangle] pub extern "C" fn az_image_source_embedded(variant_data: AzU8VecPtr) -> AzImageSource { AzImageSource::Embedded(*az_u8_vec_downcast(variant_data)) }
/// References an (encoded!) image as a file from the file system that is loaded when necessary
#[inline] #[no_mangle] pub extern "C" fn az_image_source_file(variant_data: AzPathBufPtr) -> AzImageSource { AzImageSource::File(*az_path_buf_downcast(variant_data)) }
/// References a decoded (!) `RawImage` as the image source
#[inline] #[no_mangle] pub extern "C" fn az_image_source_raw(variant_data: AzRawImagePtr) -> AzImageSource { AzImageSource::Raw(*az_raw_image_downcast(variant_data)) }
/// Destructor: Takes ownership of the `ImageSource` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_image_source_delete(object: &mut AzImageSource) { match object { AzImageSource::Embedded(_) => { }, AzImageSource::File(_) => { }, AzImageSource::Raw(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_image_source_deep_copy(object: &AzImageSource) -> AzImageSource { object.clone() }

/// Re-export of rust-allocated (stack based) `FontSource` struct
pub type AzFontSourceType = azul_core::app_resources::FontSource;
#[no_mangle] pub use AzFontSourceType as AzFontSource;
/// Bytes are the bytes of the font file
#[inline] #[no_mangle] pub extern "C" fn az_font_source_embedded(variant_data: AzU8VecPtr) -> AzFontSource { AzFontSource::Embedded(*az_u8_vec_downcast(variant_data)) }
/// References a font from a file path, which is loaded when necessary
#[inline] #[no_mangle] pub extern "C" fn az_font_source_file(variant_data: AzPathBufPtr) -> AzFontSource { AzFontSource::File(*az_path_buf_downcast(variant_data)) }
/// References a font from from a system font identifier, such as `"Arial"` or `"Helvetica"`
#[inline] #[no_mangle] pub extern "C" fn az_font_source_system(variant_data: AzStringPtr) -> AzFontSource { AzFontSource::System(*az_string_downcast(variant_data)) }
/// Destructor: Takes ownership of the `FontSource` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_font_source_delete(object: &mut AzFontSource) { match object { AzFontSource::Embedded(_) => { }, AzFontSource::File(_) => { }, AzFontSource::System(_) => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_font_source_deep_copy(object: &AzFontSource) -> AzFontSource { object.clone() }

/// Pointer to rust-allocated `Box<RawImage>` struct
#[no_mangle] #[repr(C)] pub struct AzRawImagePtr { ptr: *mut c_void }
/// Creates a new `RawImage` by loading the decoded bytes
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_new(decoded_pixels: AzU8VecPtr, width: usize, height: usize, data_format: AzRawImageFormat) -> AzRawImagePtr { let object: RawImage = RawImage { pixels: *az_u8_vec_downcast(decoded_pixels), image_dimensions: (width, height), data_format }; AzRawImagePtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `RawImage` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_delete(ptr: &mut AzRawImagePtr) { let _ = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`RawImage`>!.
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_shallow_copy(ptr: &AzRawImagePtr) -> AzRawImagePtr { AzRawImagePtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzRawImagePtr` to a `Box<RawImage>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_raw_image_downcast(ptr: AzRawImagePtr) -> Box<RawImage> { unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) } }
/// (private): Downcasts the `AzRawImagePtr` to a `&mut Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_refmut<F: FnOnce(&mut Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let mut box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzRawImagePtr` to a `&Box<RawImage>` and runs the `func` closure on it
#[inline(always)] fn az_raw_image_downcast_ref<F: FnOnce(&Box<RawImage>)>(ptr: &mut AzRawImagePtr, func: F) { let box_ptr: Box<RawImage> = unsafe { Box::<RawImage>::from_raw(ptr.ptr  as *mut RawImage) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }

/// Re-export of rust-allocated (stack based) `RawImageFormat` struct
pub type AzRawImageFormatType = azul_core::app_resources::RawImageFormat;
#[no_mangle] pub use AzRawImageFormatType as AzRawImageFormat;
/// Bytes are in the R-unsinged-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_r8() -> AzRawImageFormat { AzRawImageFormat::R8 }
/// Bytes are in the R-unsinged-16bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_r16() -> AzRawImageFormat { AzRawImageFormat::R16 }
/// Bytes are in the RG-unsinged-16bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rg16() -> AzRawImageFormat { AzRawImageFormat::RG16 }
/// Bytes are in the BRGA-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_bgra8() -> AzRawImageFormat { AzRawImageFormat::BGRA8 }
/// Bytes are in the RGBA-floating-point-32bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgbaf32() -> AzRawImageFormat { AzRawImageFormat::RGBAF32 }
/// Bytes are in the RG-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rg8() -> AzRawImageFormat { AzRawImageFormat::RG8 }
/// Bytes are in the RGBA-signed-32bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgbai32() -> AzRawImageFormat { AzRawImageFormat::RGBAI32 }
/// Bytes are in the RGBA-unsigned-8bit format
#[inline] #[no_mangle] pub extern "C" fn az_raw_image_format_rgba8() -> AzRawImageFormat { AzRawImageFormat::RGBA8 }
/// Destructor: Takes ownership of the `RawImageFormat` pointer and deletes it.
#[no_mangle] #[inline] #[allow(unused_variables)] pub extern "C" fn az_raw_image_format_delete(object: &mut AzRawImageFormat) { match object { AzRawImageFormat::R8 => { }, AzRawImageFormat::R16 => { }, AzRawImageFormat::RG16 => { }, AzRawImageFormat::BGRA8 => { }, AzRawImageFormat::RGBAF32 => { }, AzRawImageFormat::RG8 => { }, AzRawImageFormat::RGBAI32 => { }, AzRawImageFormat::RGBA8 => { }, }
}
/// Copies the object
#[no_mangle] #[inline] pub extern "C" fn az_raw_image_format_deep_copy(object: &AzRawImageFormat) -> AzRawImageFormat { object.clone() }

/// Pointer to rust-allocated `Box<WindowCreateOptions>` struct
#[no_mangle] #[repr(C)] pub struct AzWindowCreateOptionsPtr { ptr: *mut c_void }
// Creates a new `WindowCreateOptions` instance whose memory is owned by the rust allocator
// Equivalent to the Rust `WindowCreateOptions::new()` constructor.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_new(css: AzCssPtr) -> AzWindowCreateOptionsPtr { let object: WindowCreateOptions = WindowCreateOptions::new(*az_css_downcast(css)); AzWindowCreateOptionsPtr { ptr: Box::into_raw(Box::new(object)) as *mut c_void } }
/// Destructor: Takes ownership of the `WindowCreateOptions` pointer and deletes it.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_delete(ptr: &mut AzWindowCreateOptionsPtr) { let _ = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) }; }
/// Copies the pointer: WARNING: After calling this function you'll have two pointers to the same Box<`WindowCreateOptions`>!.
#[no_mangle] #[inline] pub extern "C" fn az_window_create_options_shallow_copy(ptr: &AzWindowCreateOptionsPtr) -> AzWindowCreateOptionsPtr { AzWindowCreateOptionsPtr { ptr: ptr.ptr } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `Box<WindowCreateOptions>`. Note that this takes ownership of the pointer.
#[inline(always)] fn az_window_create_options_downcast(ptr: AzWindowCreateOptionsPtr) -> Box<WindowCreateOptions> { unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) } }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&mut Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_refmut<F: FnOnce(&mut Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let mut box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&mut box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
/// (private): Downcasts the `AzWindowCreateOptionsPtr` to a `&Box<WindowCreateOptions>` and runs the `func` closure on it
#[inline(always)] fn az_window_create_options_downcast_ref<F: FnOnce(&Box<WindowCreateOptions>)>(ptr: &mut AzWindowCreateOptionsPtr, func: F) { let box_ptr: Box<WindowCreateOptions> = unsafe { Box::<WindowCreateOptions>::from_raw(ptr.ptr  as *mut WindowCreateOptions) };func(&box_ptr);ptr.ptr = Box::into_raw(box_ptr) as *mut c_void; }
